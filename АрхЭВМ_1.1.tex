\documentclass{article}
\input{Headers/header}

\geometry{margin=1in}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyfoot[L]{}
\fancyfoot[C]{Иванов Тимофей}
\fancyfoot[R]{\pagename\ \thepage}
\fancyhead[L]{}
\fancyhead[R]{\leftmark}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}

\usepackage{adjustbox}
\usepackage[outputdir=D:/Projects/ct-notes/Output, cache=false]{minted}
\usemintedstyle{tango}

\usepackage{pgf}
\newcommand{\eval}[1]{\pgfmathparse{#1}\pgfmathresult}

\usepackage{stackengine,scalerel}

\usetikzlibrary{circuits.logic.IEC,circuits.logic.US}
\tikzset{
    every node/.style={
        not gate IEC symbol={},
        or gate IEC symbol={$\scriptstyle1$},
        nor gate IEC symbol={$\scriptstyle1$}
    }
}
\tikzstyle{branch}=[fill,shape=circle,minimum size=3pt,inner sep=0pt]
\tikzstyle{neg}=[draw=black,fill=white,circle,left,inner sep=0pt,minimum size=2pt]
\usepackage{circuitikz}
\ctikzset{resistor=european}

\geometry{legalpaper, paperheight=16383pt, margin=1in}
\setcounter{totalnumber}{100}
\pagestyle{empty}

\begin{document}
    \section{Представление чисел.}
    \paragraph{\undercolorblack{orange}{Беззнаковое целое число}.}
    В целом, тут всё просто. Если рассмотреть восьмибитное целое число, то получится что-то такое:
    \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \foreach\i in {0,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
        }
    \end{tikzpicture}}, где снизу написаны \textit{веса} ячеек. То есть число, записанное тут, имеет 8 двоичных знаков и, чтобы получить само число, нужно умножить каждый двоичный знак на вес и сложить результаты. То есть, например, такая штука: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \foreach\i in {0,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
        }

        \node[scale=2] at (.5,.5) {0};
        \node[scale=2] at (1.5,.5) {1};
        \node[scale=2] at (2.5,.5) {0};
        \node[scale=2] at (3.5,.5) {0};
        \node[scale=2] at (4.5,.5) {0};
        \node[scale=2] at (5.5,.5) {1};
        \node[scale=2] at (6.5,.5) {0};
        \node[scale=2] at (7.5,.5) {1};
    \end{tikzpicture}} равна $64+4+1=69$. Совершенно очевидно, что так любое число представимо единственным образом в такой форме, её легко складывать, и вообще всё хорошо с этой формой. Но есть ещё о чём поговорить.\\
    Например, о количестве битов в байте. 8, вы думаете? А вот зря. По определению, байт --- это минимальная обращаемая ячейка памяти. И нигде не сказано про его размер. На заре компьютерных технологий количество битов в байте могло быть очень разным. Были и по 6, и по 8, и по сколько только не было. Сейчас всё намного менее разнообразно по двум причинам. С одной стороны, программы пытаются адаптироваться к железу, работая лучше на определённых системах. С другой же стороны, производители железа создают такие архитектуры, на которых часто используемые алгоритмы работают оптимально. Поэтому если сейчас кто-то создаст компьютер с другим количеством бит, половина программ на нём не запустится, а другая будет работать очень неоптимально. Тем не менее, в сетевом взаимодействии нигде не используется термин ``байт'', а для 8 бит вводят новый.\\
    Ещё можно поговорить о том, почему биты в байте располагаются именно так, как я нарисовал. Именно как, хочется задать вопрос. А вот абсолютно не важно, ведь \textbf{никаким} образом нельзя обратиться к биту напрямую. Можно сделать как-нибудь так: \mintinline{c}{a & 1}, но тогда никто не знает, будет ли это \textit{первый} бит или \textit{последний}, только то, что он будет младшим. А вот где он... Тем не менее, вообще бывают побитовые алгоритмы, но в каждом из них необходимо документацию о том, какой бит где. Причём существуют оба варианта.
    \paragraph{\undercolorblack{orange}{Знаковое целое число}.}
    Вот тут уже интереснее. И есть целых 7 способов такие штуки хранить.
    \subparagraph{\undercolorblack{orange}{Бит под знак}.}
    Выглядит ровно также, как звучит. Один бит отдаётся под знак, оставшаяся часть хранит модуль числа. Обычно, левый \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \node at (.5,-.25) {$+$/$-$};
        \foreach\i in {1,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
        }
    \end{tikzpicture}}. Возникает вопрос: а 0 в первом бите --- это $+$ или $-$? Вообще, зависит от разных вещей, но обычно $+$, чтобы положительные числа сохраняли запись. У этой штуки есть проблема. В ней есть две записи, равных одному числу (нулю): \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \node at (.5,-.25) {$+$/$-$};
        \node[scale=2] at (.5,.5) {0};
        \foreach\i in {1,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
            \node[scale=2] at (\i+.5,.5) {0};
        }
    \end{tikzpicture}} и \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \node at (.5,-.25) {$+$/$-$};
        \node[scale=2] at (.5,.5) {1};
        \foreach\i in {1,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
            \node[scale=2] at (\i+.5,.5) {0};
        }
    \end{tikzpicture}}. Получается, чтобы сравнить две таких записи на равенство, надо сначала сравнить их побитово, а если они не равны, то проверить, не являются ли они нулями разных знаков. И из-за двух разных одинаковых чисел у нас ужат диапазон хранимых значений до $[-127:127]$.
    \subparagraph{\undercolorblack{orange}{Сдвиг-128 и сдвиг-127}.}
    Давайте заметим следующий факт. У нас возможных вариаций битов --- чётное количество, а значит, если мы хотим хранить всё без повторений, то положительных и отрицательных чисел не получится поровну.\\
    Идея форм сдвиг-N состоит в следующем. Мы храним обычное беззнаковое число, но интерпретируем его, как число на 128/127 меньше. Пример: $-5$ мы сдвигаем на, например, 128, получаем 123, значит в системе сдвиг-128 оно будет храниться так: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);

            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {1};
            \node[scale=2] at (2.5,.5) {1};
            \node[scale=2] at (3.5,.5) {1};
            \node[scale=2] at (4.5,.5) {1};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {1};
            \node[scale=2] at (7.5,.5) {1};
    \end{tikzpicture}}. А, например, 5 в той же системе хранится так: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);

        \node[scale=2] at (.5,.5) {1};
        \node[scale=2] at (1.5,.5) {0};
        \node[scale=2] at (2.5,.5) {0};
        \node[scale=2] at (3.5,.5) {0};
        \node[scale=2] at (4.5,.5) {0};
        \node[scale=2] at (5.5,.5) {1};
        \node[scale=2] at (6.5,.5) {0};
        \node[scale=2] at (7.5,.5) {1};
    \end{tikzpicture}}, ведь как беззнаковое число это равно $128+5=133$. Безусловный плюс этих систем в том, что положительные числа хранятся похоже на свои беззнаковые варианты, а также в том, что тут также легко определить знак числа, как и в первом варианте.
    \subparagraph{\undercolorblack{orange}{Дополнительный код} (также известный, как дополнение до двух).}
    Вот как это выглядит: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \node at (.5,-.25) {$-128$};
        \foreach\i in {1,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
        }
    \end{tikzpicture}}. Сначала возникает вопрос, что это за ересь, но, когда станут понятны все плюсы этого, появится вопрос, как люди до такого додумались вообще. Итак, что в этой системе хорошего? Цельный диапазон $[-128:127]$ без дубликатов и дыр, положительные числа совпадают с беззнаковыми вариантами, сложение и вычитание работают вообще один в один как в беззнаковых. А есть ещё следующая штука.\\
    Модулярная арифметика. Все операции выполняются по фиксированному модулю (в случае с беззнаковыми восьмибитными числами --- 256). Этот термин значит, что при сложении \mintinline{c}{254} и \mintinline{c}{3} получится \mintinline{c}{1}, а не что-то непонятное. То есть есть диапазон $[0:255]$, и если выйти за его пределы с одной стороны, то вернёшься с другой. И вот если конвертировать беззнаковое число в знаковое в дополнительном коде, с точки зрения модулярной арифметики с байтами не придётся делать ничего. Пример этому. Мы хотим получить максимальное беззнаковое число. А это значит, что можно просто на один шаг выйти из нуля в отрицательную сторону. То есть если в беззнаковых операциях получится \mintinline{c}{-1}, он превратится именно в то, что нужно. Так вот, имея дополнительный код, никаких операций делать не придётся, а можно просто представить знаковый  \mintinline{c}{-1} как беззнаковое число. \textbf{Бесплатно}! Совершив тем самым 0 операций. А модулярная арифметика вообще бывает очень удобной. Если вы уверены, что у вас адекватный ответ, но необязательно адекватные промежуточные вычисления, то париться о них нет никакой необходимости. \mintinline{c}{250 + 10 - 20} равно \mintinline{c}{240}, а не чему-то непонятному. Хотя, так-то это зависит от предметной области. В обработке изображений если у вас получается сверхбелая точка, логично считать, что оно просто белая, а не чёрная (это называется арифметикой с насыщением). И в арифметике с насыщением, понятно, \mintinline{c}{250 + 10 - 20} уже не равно \mintinline{c}{240}. Всё зависит от того, что вам нужно. Иногда модулярная арифметика. Иногда --- с насыщением. А иногда, как в строении атомных реакторов, если значение становится больше максимального, это, скорее всего, ошибка, о которой нужно сигнализировать, а не пытаться что-то дальше считать.\\
    Тем не менее, указанный способ является самым популярным в современных компьютерах. Говорят, что создатели C++20 провели исследование, согласно которому только одна компания производит железо, в котором не используется дополнение до двух (а используется дополнение до одного). Компания называется UNIVAC, а ещё, судя по всему, дополнение до одного е неё программное, а не аппаратное. Поэтому в тот же C++20, вроде как планируют на обязательной основе написать, что числа обязаны быть в дополнительном коде.
    \subparagraph{\undercolorblack{orange}{Дополнение до единицы}.}
    Это выглядит похоже на дополнение до 2, но немного по другому: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \node at (.5,-.25) {$-127$};
        \foreach\i in {1,...,7} {
            \node at (\i+.5,-.25) {\eval{int(2^(7-\i))}};
        }
    \end{tikzpicture}}. Что в этом хорошего? Ну, например, легко делающаяся операция \mintinline{c}{-a}, простая инверсия всех битов (в дополнении до двух надо ещё единицу прибавить). Но тут и плохого тоже есть. Например, опять два нуля и урезанный диапазон.\\
    Кстати. Какой минимальный диапазон должен поддерживать \mintinline{c}{int} по стандарту языка C? Так вот, $[-32767:32767]$. Заметьте, тут $2^{16}-1$ число, то есть стандарт C поддерживает возможность урезанного диапазона. Для беззнаковых чисел постулируется модулярная арифметика, а знаковые можно хранить любым удобным образом. Как я уже говорил, в C++20 хотят потребовать дополнительный код. А вот C обходится с переполнениями очень обтекаемо и, согласно стандарту, \mintinline{c}{32767 + 10} --- это undefined behaviour. Окей, а почему это важно вообще, зачем в C++20 что-то новое пытаться вводить? Да, всё просто на самом деле. Компиляторы --- штука хитрая, поэтому, если в стандарте указано <<undefined behaviour>>, то это оно и будет. Например, рассмотрим такой цикл:
    \begin{minted}{c}
        for (int i = 10; i > 2; i++)
    \end{minted}
    Как это хочется, чтобы работало? \mintinline{c}{i} дойдёт до переполнения, отрицательное число будет меньше \mintinline{c}{2}, цикл прекратится. Как оптимизатор может при большом желании посмотреть на это? Десять больше двух, оно увеличивается, переполнения не существует, потому что undefined behaviour (туда вполне может закрасться арифметика с насыщением), значит этот цикл --- бесконечный. Заменим же его на \mintinline{c}{while (1)}! А по стандарту оптимизатор может так сделать, ему никто не мешает. Если по стандарту undefined behaviour, то компилятор может интерпретировать программу так, как ему хочется.\\
    Интересный факт про новые стандарты C и C++. Разработчики C так-то не очень рвутся что-либо постулировать. Они достаточно консервативны, поэтому за всё время существования языка пометили как \mintinline{c}{deprecated} только одну функцию. Да и вообще, при введении новых вещей в первую очередь разработчики C думают о старых программах. Например, в C встроенный логический тип не называется \mintinline{cpp}{bool}, а называется \mintinline{c}{_Bool}. А вдруг вы называли в вашей программе переменную словом \mintinline{text}{bool}. Однако, вы можете подключить заголовочный файл \mintinline{c}{<stdbool.h>}, который сделает вам макросы на \mintinline{c}{bool}, \mintinline{c}{true} и \mintinline{c}{false}, которого в старых программах нет.
    \subparagraph{\undercolorblack{orange}{Код с чередованием}.}
    В математике мы привыкли к тому, что к числу можно дописать слева нули или убрать их, от чего оно не изменится. И это периодически бывает полезно и в программировании, но ни одна из выше перечисленных систем не обладала этим свойством. А если мы вдруг этого очень хотим, то что? Зачем, надо бы спросить. Вообще, можно захотеть делать коды переменной длины. Или лёгкое преобразование между типами разного размера (как \mintinline{c}{int} в \mintinline{c}{long long}). Например, это можно сделать так: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[very thin] (0,0) -- (8,0);
        \foreach\i in {0,...,7} {
            \draw[very thin] (\i+.5,0) -- (\i+.5,-.25);
            \node at (\i+.5,-.5) {$\eval{int(\i-4)}$};
        }
        \draw[ultra thin, ->] (4.5,0) arc (0:180:.5);
        \draw[ultra thin, ->] (3.5,0) arc (180:360:1);
        \draw[ultra thin, ->] (5.5,0) arc (0:180:1.5);
        \draw[ultra thin, ->] (2.5,0) arc (180:360:2);
        \draw[ultra thin, ->] (6.5,0) arc (0:180:2.5);
        \draw[ultra thin, ->] (1.5,0) arc (180:360:3);
        \draw[ultra thin, ->] (7.5,0) arc (0:180:3.5);
    \end{tikzpicture}}. То есть можно пронумеровать целые числа так, как на рисунке, а потом хранить их номер (как беззнаковое число). Как тогда это будет выглядеть?\\
    \begin{tabular}{|c|c|}
        \hline
        Число & Его представление\\
        \hline
        0 & \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);

            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {0};
        \end{tikzpicture}}\\
        \hline
        $-1$ & \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);
            
            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {1};
        \end{tikzpicture}}\\
        \hline
        1 & \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);
            
            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {1};
            \node[scale=2] at (7.5,.5) {0};
        \end{tikzpicture}}\\
        \hline
        $-2$ & \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);

            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {1};
            \node[scale=2] at (7.5,.5) {1};
        \end{tikzpicture}}\\
        \hline
        2 & \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) grid (8,1);

            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {1};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {0};
        \end{tikzpicture}}\\
        \hline
    \end{tabular}\\
    Замечаете? Младший бит содержит в себе знак, а все остальные --- модуль для положительных чисел и модуль${}-1$ для отрицательных. То есть чтобы получить модуль числа, можно к его части без младшего бита этот младший бит прибавить. Это, кажется, все достоинства такой формы. А, ну, ещё нормальный диапазон и отсутствие двух нулей.
    \subparagraph{\undercolorblack{orange}{Система счисления с основанием $-2$}.}
    К хранению отрицательных чисел можно подходить математически: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
        \draw[step=1cm,black,very thin] (0,0) grid (8,1);
        \foreach\i in {0,...,7} {
            \node at (\i+.5,-.25) {$\eval{int((-2)^(7-\i))}$};
        }
    \end{tikzpicture}}. Это даёт нам очень странный диапазон от $-170$ до 85, то есть отрицательных значений вдвое больше, чем положительных. Правда, это верно только пока количество бит чётно, если оно нечётно, то положительных чисел получается больше. А ещё это опять масштабируемо.
    \subparagraph{\undercolorblack{orange}{Симметрическая система счисления}.}
    Необязательно, вообще говоря, использовать двоичную систему счисления. Как вы думаете, что использовалось в арифмометрах? Правильно, десятичная. Потому что людям в ней удобно считать. А вот машинам --- нет. И, \textit{возможно}, это ещё и неэффективно. Почему ``\textit{возможно}''? А потому что математики исследовали, что же лучше. Делалось это следующим образом. Мы знаем, что $2^{10}\approx10^3$. А это значит, что 3 десятичных знака несут примерно столько же информации, что и 10 двоичных. Однако, двоичные разряды намного проще передавать, чем десятичные. Аккуратно всё посчитав, математики нашли систему счисления с самым оптимальным основанием, которым оказалось... $e$. Мы не извращенцы, поэтому дробные, а тем более иррациональные основания мы использовать не будем, а будем 3 или 2. Оптимальнее получается троичная. И компьютеры, использующие её, были, но она не прижилась. А сейчас против неё говорит огромная куча алгоритмов, которые заточены под двоичную систему счисления. Ячейки в троичной системе называются тритами, а минимальная обращаемая область памяти --- трайтом.\\
    Итак, к чему это я. А к тому, что для последнего способа нам понадобится система счисления с нечётным основанием. Например, та же самая троичная. В классической троичной системе для хранения чисел использовались бы триты со значениями 0, 1 и 2. В симметрической же троичной, пригодной для хранения отрицательных чисел, используются 0, 1 и $-1$. Последнее обычно обозначают за Z, как число 10 в шестнадцатиричной --- за A. Плюсы данной формы очевидны. Она легко складывается и вычитается (совершенно обычным образом), её легко обратить (превратив 1 в Z, а Z --- в 1), диапазон значений полностью симметричный, один ноль. Единственное, в чём проблема, это перевод в классическую троичную систему счисления может быть проблематичным, но, кто знает, может он и не понадобился бы.\\
    Однако у троичной (как и любой другой недвоичной) есть проблемы. Она не исследовано. В исследование двоичной было вложено столько денег и столько человеко-часов, сколько не было вложено никуда ещё. Поэтому, несмотря на такое удобство, перехода на троичную систему ждать в скором времени не приходится. Однако, этот переход может произойти частично, например в шинах данных, чтобы без увеличения тактовой частоты быстрее передавать данные.
    \paragraph{\undercolorblack{orange}{Дробные числа}.}
    Для начала надо вообще понять, как работают в дроби в двоичной системе счисления. Ну, на самом деле как в десятичной, первый разряд после точки идёт с весом $\frac12$, второй --- $\frac14$ и т.д. Например, $1001.011=2^3+2^0+2^{1/4}+2^{1/8}=9.275$. Чтобы перевести дробную часть числа из десятичной системы в двоичную, надо сделать что-то следующее: 0.375\textrightarrow\underline0.75\textrightarrow\underline1.5\textrightarrow\underline1.0. То есть мы умножаем число на 2 до посинения и во всех числах, кроме первого записываем целую часть в ответ, а потом отбрасываем его. Например, как выглядит в двоичной системе 0.1? Ну, очень просто. 0.1\textrightarrow\underline0.2\textrightarrow\underline0.4\textrightarrow\underline0.8\textrightarrow\underline1.6\textrightarrow\underline1.2\textrightarrow\underline0.4, а дальше цикл. То есть у нас получается 0.0001100110.., что можно также записать как $0.0(0011)$. Кстати говоря есть теорема, согласно которой, если число было конечной или бесконечной периодической дробью в одной системе счисления с целым основанием, то оно будет конечной либо бесконечной периодической дробью в любой другой. Но, к сожалению, то, что конечное превращается в конечное, --- не правда.\\
    Итак, как же это кодировать. Есть два существенно отличающихся друг от друга способа.
    \subparagraph{\undercolorblack{orange}{Дробные числа с фиксированной точкой}.}
    Суть тут в следующем. Берётся любой возможный формат хранения целых чисел, а потом ставится \textit{фантомная точка} в каком-то конкретном месте. То есть, например, берётся 16-битное число, но говорится, что мы интерпретируем его старшие 8 битов --- как целую часть, а младшие --- как дробную.\\
    В стандартных процессорах x86 нет поддержки чисел с фиксированной точкой. Да и в стандарте C ничего про них не сказано. А почему? А потому что их можно очень легко эмулировать, имея целые числа. Несложно заметить, что дробные числа с фиксированной точкой можно складывать и вычитать, вообще не зная о том, в каком месте у них точка (и есть ли она вообще). А вот с умножением чуть-чуть сложнее. Пусть у нас есть два числа в формате 16.16 --- a и b. Тогда несложно догадаться, что $A=a\cdot2^{16}$ --- это то число, которое по факту записано a, и аналогично с b. А мы хотим получить $c=a\cdot b$. А это значит, если умножить A на B, то мы получим $C\cdot2^{16}$. Но с перемножением $a$ и $b$ есть проблема, переполнение. Ну так не беда, приведём его к более широкому типу, а потом сузим обратно. Итого вот код:
    \begin{minted}{c}
        int mult_16_16(int A, int B)
        {
            return (int)(((__int64)A * B) / 0x10000); // 0x10000 --- это 2**16.
        }
    \end{minted}
    Здесь возникает проблема в том, что деление на \mintinline{c}{0x10000} может округлить неправильно, но это мелочи, это можно за\mintinline{c}{if}ать.\\
    Давайте поговорим про деление. Деление --- это плохо. Сложение и вычитание выполняются примерно за 1 такт процессора. Умножение (на современных машинах) --- 3--5 тактов, а деление --- во первый никто не знает, а вто вторых может быть больше 100 тактов. В новых Intel'овских процессорах, однако, смогли ускорить его до 20. Поэтому оптимизаторы, если им позволить, будут заменять деление на умножение и сдвиг. Сдвиг, понятно, нужен только для \mintinline{c}{int}. \mintinline{c}{float}'ы оптимизируются как умножение и взятие обратного чуть ли не всегда (потому что эта пара действий быстрее деления), а \mintinline{c}{int}'ы только для констант времени компиляции, для которых можно предсказать, что там. Это можно даже увидеть самому, скомпилировав \mintinline{c}{x / 10}. В результате вы увидите не деление, а умножение и сдвиг.\\
    \subparagraph{\undercolorblack{orange}{Вычисляем разные штуки в столбик}.}
    Квадратный корень, например. Рассмотрим число 23409. Побъём его на куски по 2 цифры (с конца): \setstackgap{S}{1.5pt}
    \stackMath\def\stackalignment{r}
    \(
    \stackunder{
        \overline{\underline234\underline{09}}
    }{}
    \). Теперь рассмотрим самый левый разряд. Смотрим, квадрату чего оно равно. Ну, 1. Записываем в ответ 1 и в остаток $2-1=1$. После этого сносим 2 цифры.
    \let\ph\phantom
    \setstackgap{S}{1.5pt}
    \stackMath\def\stackalignment{r}
    \(
    \stackunder{
        \stackon[1pt]{\overline{23409}}{1}
    }{
        \Shortstack[l]{{\underline{1}} 134\ph{00}}
    }
    \). Теперь делаем следующее. Берём пока имеющийся ответ, умножаем его на 2, приписываем слева цифру x. И теперь ищем такой x, что имеющееся 2x (как двузначное число), будучи умноженным на x даёт что-то снизу близкое к 134. Это 5, потому что $25\cdot5=125\leqslant134$, а $26\cdot6=156>134$. Значит мы вставляет в ответ 5 и вычитаем 125:
    \setstackgap{S}{1.5pt}
    \stackMath\def\stackalignment{r}
    \(
    \stackunder{
        \stackon[1pt]{\overline{23409}}{15}
    }{
        \Shortstack[l]{{\underline{1}} 134 {\underline{125}} \ph{00}909}
    }
    \). Теперь снова берём ответ (15), умножаем на 2 (30), пытаемся найти x, который, будучи умноженным на 30x даёт что-то близкое к 909. Да это же x=3! итак, далее:
    \setstackgap{S}{1.5pt}
    \stackMath\def\stackalignment{r}
    \(
    \stackunder{
        \stackon[1pt]{\overline{23409}}{153}
    }{
        \Shortstack[l]{{\underline{1}} 134 {\underline{125}} \ph{00}909 {\ph{00}\underline{909}}
            \ph{0000}0}
    }
    \). Ну, вот и ответ, 153. Выглядит как-то очень сложно.\\
    Но в двоичной это, как ни странно, проще, ведь там x --- это либо 1, либо 0. И на 2 умножать быстро. Возьмём число от балды. Например, такое 1\underline{01}11\underline{01}10\underline{11}:
    \stackMath\def\stackalignment{r}
    \(
    \stackunder{
        \stackon[1pt]{\overline{10111011011}\ph{000000}}{100110.10...\ph{.0000}}
    }{
        \Shortstack[l]{{\underline{1}} 001 {\ph{00}\underline0} \ph{00}111 {\ph{0000}\underline0} \ph{00}11101 {\ph{00}\underline{10001}} \ph{000}110110 {\ph{000}\underline{100101}} \ph{0000}1000111 {\ph{0000000000}\underline0} \ph{0000}100011100 {\ph{00000}\underline{10011001}} \ph{00000}1000001000 {\ph{00000000000000}\underline0} \ph{00000}100000100000}
    }
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{10\text x {\underline{\ph{00}\text x}} \text x0\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{100\text x {\underline{\ph{000}\text x}} \text x00\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{1000\text x {\underline{\ph{0000}\text x}} \text x000\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{10010\text x {\underline{\ph{00000}\text x}} \text x00\text x0\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{100110\text x {\underline{\ph{000000}\text x}} \text x00\text x\text x0\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{1001100\text x {\underline{\ph{0000000}\text x}} \text x00\text x\text x00\text x}
    \)
    \stackMath\def\stackalignment{r}
    \(
    \Shortstack[l]{10011010\text x {\underline{\ph{00000000}\text x}} \text x00\text x\text x0\text x0\text x}
    \).
    \let\ph\undefined
    Прекрасно. Что можно сказать про это? А то, что это можно в процессорах использовать при большом желании. Разумеется, с разными оптимизациями (например, считать по несколько цифр сразу). А ещё есть мем считания в столбик. Оно работает одинаково в любой системе счисления.\\
    Кстати, а хрен ли оно вообще работает? Формально доказывать не будем, но смотрите, как забавно. Пусть $y=y_1y_2$, где $y_1$, $y_2$ -- цифры. То есть $y=10\cdot y_1+y_2$. Тогда $y^2=100y_1^2+20y_1y_2+y_2^2$. Что-то пока не очевидно. А так: $y^2=100y_1^2+(20y_1+y_2)y_2$? Ну, уже лучше. То есть мы берём, обрезаем последние 2 цифры, берём корень максимально точно, умножаем полученное число на 2, приписываем $y_2$ и ищем его по рассказанному алгоритму.
    \subparagraph{\undercolorblack{orange}{Числа с плавающей точкой}.}
    Как мы уже поняли, числа с фиксированной точкой не требуют специализированного железа, особых вычислений и т.п. В отличие от чисел с плавающей точкой, которые везде, кроме, возможно, микроконтроллеров, такого требуют.\\
    Итак, что такое \mintinline{c}{float}? Пусть у нас есть некоторое число (например, 12345609). Тогда рассмотрим показательную форму этого числа: $1.2345607\cdot10^7$. Для $0.0013402$ такой показательной формой будет $1.3402\cdot10^{-3}$. Показательная форма раскладывает наше число на \textit{мантиссу} (1.2345607/1.3402) и \textit{экспоненту} ($10^7$/$10^{-3}$). Зачем такое применяется физиками? Потому что она во-первых компактна, если есть бешеная математическая константа (вида $10^{17}$), а во-вторых её необязательно знать точно, погрешность получится маленькая. К тому же, если мы не знаем какую-то точность, в обычной форме нам придётся врать, а в показательной форме норм. Так вот, то же самое справедливо для двоичных дробей. Рассмотрим уже известное нам число 5.375, в двоичной форме равное 101.011. Она равна $1.01011\cdot2^2$. Это смешение двоичной и десятичной системы, но и пофиг.\\
    Есть проблема с тем, что непонятно, что нам нужнее, экспонента или мантисса. Подо что отводить больше знаков? В самом начале все были кто во что горазд. И к чему это привело? Пусть у нас в программе на C есть число $\pi$. И что будет, если будет две железки, в которых разное количество бит под мантиссу и экспоненту. И если вам критична близость вашего значения $\pi$ к истинному его значению, то ваша программа будет давать разные результаты на разном железе. И это полный посос, всё надо конвертировать. Если у вас мантисса меньше, чем нужно, вы постоянно округляете. А если меньше экспонента, то число может к вам физически не поместиться. Когда люди это поняли, они быстро приняли формат IEEE-754, который живее всех живых, к нему выходят ревизии, правящие разные вещи, и в котором даже есть стандартизация чисел с десятичной плавающей точкой, которая тем не менее, используется только IBM и никем другим. О'кей, главный вопрос --- сколько мы хотим битов, ведь для разных задач может захотеться больше точности или меньше её. \textit{single precision} --- 1/8/23. Это знак, экспонента и мантисса соответственно. Мантисса кодируется в формате бит под знак (это и есть тот самый знак в начале). А экспонента кодируется со смещением с округлением вниз. А почему? Эти числа можно сортировать как целые таким образом, но это ни на что не влияет. Короче, нам никто не ответит, почему. О'кей, больше битов: \textit{double precision} --- 1/11/52. Это то, что было в стандарте изначально, но потом его дополнили до \textit{quad precision} --- 1/15/112 и \textit{half precision} --- 1/5/10. Мы будем всё рассматривать на примере последнего, так как она короче всего. Закодируем в ней наше число $1.01011\cdot2^2$. Знак --- 0. Сдвиг осуществляется на 15, то есть 2 переходит в 17, то есть 10001. А с мантиссой интересно. Поскольку число всегда начинается с ``1.'', её можно не хранить, а хранить только дробную часть. То есть получим такую мантиссу: 0101100000. Итого \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) rectangle (1,1);
            \draw[step=1cm,black,very thin] (1,0) rectangle (6,1);
            \draw[step=1cm,black,very thin] (6,0) rectangle (16,1);
            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {1};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {1};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {1};
            \node[scale=2] at (8.5,.5) {0};
            \node[scale=2] at (9.5,.5) {1};
            \node[scale=2] at (10.5,.5) {1};
            \node[scale=2] at (11.5,.5) {0};
            \node[scale=2] at (12.5,.5) {0};
            \node[scale=2] at (13.5,.5) {0};
            \node[scale=2] at (14.5,.5) {0};
            \node[scale=2] at (15.5,.5) {0};
        \end{tikzpicture}}. В шестнадцатиричной получается 0x4560.\\
    Какая точность числа в битах в half precision? Мы знаем о числе 11 его бит (10 мантиссы с начальную единичку). Числа с фиксированной точкой имеют абсолютную точность (соседние числа отличаются на $\frac1{256}$, например). А тут разность соседних чисел зависит от экспоненты, то есть от того, насколько число большое. Сравним теперь что-нибудь. Насколько большой диапазон кодируется в 16.16? Самое большое по модулю значение --- это 32768 ($\pm1$). А самое близкое к нулю число --- это $\frac1{65536}$. А что с плавающей точкой (single)? Вообще, согласно IEEE максимальная и минимальная экспонента --- специальные случаи, которые мы не учитываем пока. Самое большое число --- $2^{127}$ (это самая большая экспонента). Это примерно $10^{38}$. И самое близкое к $0$ число --- $10^{-38}$. А в double precision вообще $10^{308}$. Это зачем так много? Для промежуточных вычислений. Иногда и такого может не хватить. Но редко.\\
    Теперь крайние случаи. Закодируем самое маленькое число, большее нуля (\mintinline{c}{a}) (в half). Самая маленькая нормальная экспонента содержит код 1, то есть числовое значение -14, а мантисса --- 0. А следующее (\mintinline{c}{b})? Такая же экспонента, но мантисса --- 1. Понятно, что \mintinline{c}{a == b} --- это \mintinline{c}{0}, \mintinline{c}{a > b} --- это \mintinline{c}{1}. Однако, при этом \mintinline{c}{a - b} --- это \mintinline{c}{0}. Что-то какая-то дичь. Как такое решать? Это первый специальный случай. Когда все биты экспоненты --- нули, хранится \textit{денормализованное число}. В экспоненте у них такое же число, как и у самых маленьких нормальных экспонент (а не то, что написано), но мантиссу мы представляем не как ``1.'', а как ``0.''. Тогда разность \mintinline{c}{a-b} --- это $1.000\ldots001\cdot2^{-\alpha}-1.000\ldots000\cdot2^{-\alpha}=0.000\ldots001\cdot2^{-\alpha}$ что выражается в half как \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) rectangle (1,1);
            \draw[step=1cm,black,very thin] (1,0) rectangle (6,1);
            \draw[step=1cm,black,very thin] (6,0) rectangle (16,1);
            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {0};
            \node[scale=2] at (8.5,.5) {0};
            \node[scale=2] at (9.5,.5) {0};
            \node[scale=2] at (10.5,.5) {0};
            \node[scale=2] at (11.5,.5) {0};
            \node[scale=2] at (12.5,.5) {0};
            \node[scale=2] at (13.5,.5) {0};
            \node[scale=2] at (14.5,.5) {0};
            \node[scale=2] at (15.5,.5) {1};
        \end{tikzpicture}} ($\alpha=-14$). Теперь понятно, как выглядит 0, вот так: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) rectangle (1,1);
            \draw[step=1cm,black,very thin] (1,0) rectangle (6,1);
            \draw[step=1cm,black,very thin] (6,0) rectangle (16,1);
            \node[scale=2] at (.5,.5) {0};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {0};
            \node[scale=2] at (8.5,.5) {0};
            \node[scale=2] at (9.5,.5) {0};
            \node[scale=2] at (10.5,.5) {0};
            \node[scale=2] at (11.5,.5) {0};
            \node[scale=2] at (12.5,.5) {0};
            \node[scale=2] at (13.5,.5) {0};
            \node[scale=2] at (14.5,.5) {0};
            \node[scale=2] at (15.5,.5) {0};
        \end{tikzpicture}}. Или так: \adjustbox{valign=t}{\begin{tikzpicture}[scale=.45, every node/.style={scale=0.6}]
            \draw[step=1cm,black,very thin] (0,0) rectangle (1,1);
            \draw[step=1cm,black,very thin] (1,0) rectangle (6,1);
            \draw[step=1cm,black,very thin] (6,0) rectangle (16,1);
            \node[scale=2] at (.5,.5) {1};
            \node[scale=2] at (1.5,.5) {0};
            \node[scale=2] at (2.5,.5) {0};
            \node[scale=2] at (3.5,.5) {0};
            \node[scale=2] at (4.5,.5) {0};
            \node[scale=2] at (5.5,.5) {0};
            \node[scale=2] at (6.5,.5) {0};
            \node[scale=2] at (7.5,.5) {0};
            \node[scale=2] at (8.5,.5) {0};
            \node[scale=2] at (9.5,.5) {0};
            \node[scale=2] at (10.5,.5) {0};
            \node[scale=2] at (11.5,.5) {0};
            \node[scale=2] at (12.5,.5) {0};
            \node[scale=2] at (13.5,.5) {0};
            \node[scale=2] at (14.5,.5) {0};
            \node[scale=2] at (15.5,.5) {0};
        \end{tikzpicture}}. До этого ещё дойдём. Денормализованные числа расширяют диапазон чисел, близких к 0. Они могут до $2^{-24}$. Но в этих числах есть проблема, мы знаем в них очень мало бит. Вот про это денормализованное числа мы знаем ровно один бит. Другая проблема --- при любых операциях железо пытается нормализовать число.\\
    А если у нас экспонента максимальна, то что? Это делится на 2 подслучая. Первый: мантисса полностью состоит из нулей. Тогда у вас закодирована $\infty$ или $-\infty$, в зависимости от бита-знака. Это даёт нам возможность делить \mintinline{c}{3.0 / 0.0} и получать бесконечность, делить \mintinline{c}{3.0 / -0.0} и получать отрицательную бесконечность и т.п. Эти бесконечности ведут себя как в математике, совершенно естественно. Но их тоже нужно отдельно поддерживать. Но это легче, чем денормализованные числа. А вот второй подслучай интереснее. Мы получаем так называемый NaN (Not a Number). Это зверёк, который имеет интересные свойства. Во-первых у него нет знака. Во-вторых, любая операция с ними даёт вам того же самого зверька. Только операция с двумя зверьками даёт вам какого-то конкретного одного из них. Нужны зверьки для того, чтобы сообщать об ошибках. Если вы вычтете бесконечность из самой себя, поделите 0 на 0, или сделаете ещё что-то бессмысленное, получится зверёк. Кроме $0^0$, это вполне может быть равно 1. Что с этими зверьками хорошего? Во-первых, если ваш ответ зависит от зверька, получится зверёк, а если у вас есть \mintinline{c}{if}, в связи с которым от зверька ничего не зависит, программа не крашится. Во-вторых, можно заполнять неинициализированную память зверьками. У зверьков есть интересное свойство. Они никогда ничему не равны. Даже себе. А также, не больше и не меньше. Только с операцией \mintinline{c}{!=} они согласны, причём всегда. В частности \mintinline{c}{if (a == a)} --- это проверка на зверька. Которая ещё и быстрее работает, чем \mintinline{c}{isnan}. Умный оптимизатор, кстати, может заставить \mintinline{c}{isnan} так и работать. Но это ещё и не самое интересное. Самое интересное, что зверьки ещё и разные бывают: сигнальные и тихие. Суть их в следующем. Если железо умеет кидать исключение, то при любой операции с сигнальным зверьком, оно это исключение кидает. В противном случае, просто получается тихий зверёк. Но даже не совсем так, например, x86 умеет, но не будет, если его не заставить. Сигнального зверька нельзя породить как-нибудь, кроме как руками. В новых стандартах есть специальная функция, которая получает один аргумент, от которого \textit{как-то} зависит тихость зверька.\\
    Поехали конкретно в C. По факту \mintinline{c}{float} --- это single precision. По стандарту, опять же нет, у него даже точка может быть чуть ли не десятичная. Даже константа специальная есть для этого. \mintinline{c}{double} --- это double precision. А вот кто такой \mintinline{c}{long double} --- вопрос. Где-то может быть и quad precision, но вполне может быть double precision. Это всегда правда для компиляторов Microsoft. GCC (не под Windows) можно заставить считать, что это quad. Но на x86 он будет программным, если в принципе будет, потому что аппаратного в принципе нет. Но ещё \mintinline{c}{long double} может быть extended precision (1/15/64). Это непонятная штука, она хранит первый бит мантиссы зачем-то, не входит в стандарт, но аппаратно поддерживается x86. Можно заставить компилировать Clang компилировать \mintinline{c}{long double} в него и Intel'овские компиляторы. О'кей, а что с half. Его очень любят в видеокартах, потому что обычно больше точности и не надо, а работает быстрее. А проблема в том, что в геймерском железе специально режут скорости double precision, она в 64 раза медленнее single precision. И только в крутых видеокартах для научных вычислений --- в 2--3 раза. half начинают вводить как тип для вычислений (а не для передачи данных) только сейчас. Но он только в современных картах AMD быстрее, чем single. В современных NVIDIA --- такая же скорость.\\
    Ещё есть такое существо: bfloat: 1/8/7. Его очень в нейросетях любят, где не очень нужна точность, но очень нужны степени. Вдобавок оно очень хорошо конвертируется в single precision. Поэтому сейчас начинает выходить железо с аппаратной поддержкой вот этого.\\
    Что с поддержкой специальных случаев? Большинство железа нормально поддерживает бесконечности и зверьков. Кроме, например, PS2, который не умеет в них, поэтому с его эмуляцией есть сложности, если переводить бесконечности в него, то будет проблема. А вот на денормализованные могут забивать. В x86 есть проблема в их скорости, там они реализованы через микрокод, поэтому их скорость может быть раз в 100 медленнее, чем у нормальных чисел. Но можно включить режим ``считать денормализованные нулями'', но тогда понятно, будут баги. А могут они просто всегда не поддерживаться, а считаться нулями.\\
    Про компиляторы. Компиляторы не очень хотят жить по стандарту IEEE-754. Потому что тогда они даже не могут упростить \mintinline{c}{a = b + 0.0} в \mintinline{c}{a = b}, потому что для \mintinline{c}{b} равного \mintinline{c}{-0.0} результат \mintinline{c}{-0.0 + 0.0} равен \mintinline{c}{0.0}, а не \mintinline{c}{-0.0}, как хочется. Причём \mintinline{c}{a = b - 0.0} можно упростить всегда. Что с этим делать? Обычно у компилятора есть два варианта работы с дробными числами strict и fast. первый работает по стандарту, а второй --- как попало, но побыстрее. Например, при конверсии дробного числа в целое не всегда округляет его в сторону нуля.
    \paragraph{\undercolorblack{orange}{Округление}.}
    В дробных числах мы округляем довольно часто, а делать это можно по-разному. Пусть у нас есть $3.456$ и нам нужно округлить последнюю цифру. Сначала надо понять, что есть только 2 варианта ответа: $3.45$ и $3.46$. И способов округления есть много, и много из них используются.
    \subparagraph{\undercolorblack{orange}{Округление к нулю}.} Это просто отбрасывание дробной части. Именно это используется в C при целочисленном делении и конверсии \mintinline{c}{float}'ов и \mintinline{c}{double}'ов в целочисленные типы. Пример. $3.456$ округлится до $3.45$, а вот $-3.456$ округлится до $-3.45$.
    \subparagraph{\undercolorblack{orange}{Округление к $-\infty$ и $+\infty$}.} В просторечии --- округление \textit{вверх} и \textit{вниз}. Округление к $-\infty$ можно часто спутать с округлением к нулю, но округление к $-\infty$ округлит $-3.456$ к $-3.46$.
    \subparagraph{\undercolorblack{orange}{Округление от нуля}.} Существует, но используется редко. Понятно, что делает.
    \subparagraph{\undercolorblack{orange}{К ближайшему целому}.} Если первая округляемая цифра больше либо равно половины разряда, округляется от нуля, иначе --- к нулю. Есть у этого способа проблема. Пусть мы генерируем случайные (равномерно распределённые числа), которым мы округляем только последнюю цифру. Тогда среднее значение округлённых чисел будет больше, чем у оригиналов. Потому что у нас 5 вариантов округляемых цифр, для которых мы добавляем значение (5, 6, 7, 8 и 9), и 4 --- для которых вычитаем (1, 2, 3, 4). 0 мы тут не рассматриваем, он не генерирует ошибку. Поэтому используют багфикс:
    \subparagraph{\undercolorblack{orange}{К ближайшему чётному}.} Если то, что мы округляем (не только последняя цифра), меньше половины последнего сохраняемого разряда (не числа в этом разряде, а самого разряда) --- к нулю. Если больше --- от нуля. Если равно --- то так, чтобы последняя цифра после округления была чётной. Более понятно это можно записать так: Если есть ближайшее, то к нему. Если нет, то к тому, у которого последняя цифра --- чётная. Это фиксит неравномерную ошибку, а также, что интересно работает в любой системе счисления. В двоичной системе, например, так. Если в нужном нам разряде --- 0, то всегда к нулю. Если там 1, то нужно посмотреть на всё остальное. Если там что-то есть, то округляем от нуля. А если нет, то уже смотрим на последний неокругляемый разряд. Например, $0.0111$ при округлении последней цифры округлится до $0.100$.\\
    Если нам не надо округлять что-то умное (картинку, например), то это самый умный способ, который можно придумать. Кроме, понятно, такого же, но на практике гораздо реже используемого округления к нечётному. И обычно это и используется в промежуточных вычислениях в \mintinline{c}{float}'ах. Некоторые железки (например, x86) позволяют выбирать, какое округление мы хотим (но по умолчанию всё равно к ближайшему чётному).
    
    Пусть у нас есть массив чисел с плавающей точкой, и хочется найти сумму всех значений.
    \begin{minted}{c}
        float sum(float *data, size_t len)
        {
            float s = 0;
            for (size_t i = 0; i < len; i++)
                s += data[i];
            return s;
        }
    \end{minted}
    Вопрос в том, что такое \mintinline{c}{size_t}? Это беззнаковый тип такого размера, что значение годится для хранения индексов объектов в памяти. То есть в 32-битных системах это обычно 32-битный \mintinline{c}{unsigned}, а в 64-битных --- 64-битный. Смысл использования этого типа? Если написать обычный \mintinline{c}{unsigned} (или ещё хуже \mintinline{c}{signed int}), то максимальный индекс будет 4 (или вообще 2) миллиарда (что в 64-битных системах может не хватить). Просто так написать там \mintinline{c}{long long} --- тоже не вариант, ведь в 32-битных системах вы будете намного медленнее работать, чем необходимо. Именно поэтому, многие библиотечные функции (\mintinline{c}{strlen}, например) возвращают именно \mintinline{c}{size_t}.\\
    На что ещё в этом коде нужно обратить внимание? На сложение. В каждом сложении есть неявное округление, которое даёт нам ошибку. При этом ошибка накапливается. Поэтому, если мы просто изменим тип \mintinline{c}{s} на \mintinline{c}{double} (а возвращать всё равно будем \mintinline{c}{float}), то мы получим два разных значения. И их разность --- почти полностью ошибка \mintinline{c}{float}'а. Ну, хорошо, а если у нас изначально массив \mintinline{c}{double}'ов? То есть вопрос состоит в том, как увеличить точность без использования аппаратно более точного типа.
    \begin{minted}{c}
        float ksum(float *data, size_t len)
        {
            float s = 0, c = 0;            
            for (size_t i = 0; i < len; i++)
            {
                float y = data[i] - c;
                float t = s + y;
                c = t - s - y;
                s = t;
            }
            return s;
        }
    \end{minted}
    На первой итерации \mintinline{c}{y} --- это первый элемент массива. \mintinline{c}{t} и \mintinline{c}{s} --- тоже. \mintinline{c}{c} --- это \mintinline{c}{0}. Смотрим вторую итерацию. \mintinline{c}{y} --- второй элемент. \mintinline{c}{t} --- сумма первых двух элементов массива. А дальше уже что-то интересное. Представим, что первое число было очень большим, а второе --- очень маленьким (настолько, что оно вообще не внесло в сумму результат). Тогда \mintinline{c}{-c} будет хранить это самое маленькое число (т.е. ошибку при сложении). И к третьему числу мы попытаемся эту ошибку прибавить. И вот этот алгоритм (алгоритм суммирования Кэхэна  или Kahan summation) намного более точен. Ещё точнее он будет, если предварительно отсортировать массив по возрастанию. Понятно, что он намного медленнее. Даже медленнее, чем суммирование в \mintinline{c}{double}'ах, поэтому он нужен не всегда. Есть библиотека double double, которая симулирует более высокую точность, чем \mintinline{c}{double}, используя два \mintinline{c}{double}'а. Мы, кстати, тоже это делаем, про сути.\\
    А ещё тут можно посмотреть на оптимизаторы. По стандарту нельзя заменить \mintinline{c}{a + b + c} на \mintinline{c}{a + c + b}, если, например, \mintinline{c}{b} --- это больше число, а \mintinline{c}{a} и \mintinline{c}{c} --- равные числа порядка трети младшего разряда \mintinline{c}{b}. Тогда \mintinline{c}{a + b} просто равно \mintinline{c}{b}, а вот \mintinline{c}{(a + c) + b} --- нет. Поэтому, кстати, если не специфицировать порядок сложения в параллельных вычислениях, то могут получиться разные результаты. Например, если сумма близка к нулю, то значения могут получится как положительными, так и отрицательными.\\
    Давайте дальше поговорим про оптимизаторы. Мы уже говорили про ключи strict и fast. Так вот при ключе fast компилятор может (и, скорее всего, будет) соптимизировать суммирование Кэхэна до обычного суммирования, которые мы писали раньше. Но это вообще не единственный подводный камень. Например, в нашем коде \mintinline{c}{c - s} может стать бесконечным, а \mintinline{c}{- y} после этого должен вернуть его на место. Поэтому, промежуточные вычисления можно производить в \mintinline{c}{double}'ах, если хочется. И компиляторы даже сами такое умеют. И это тоже ключи компилятора. Короче, в плавающей точке нужно быть аккуратным, а если аккуратным быть не хочется, ст\'{о}ит задуматься о фиксированной точке.
    \section{Логические выражения, логические схемы и подобное.}
    Итак, у нас есть основные операции: not, and, or, xor. Как мы знаем, в математичке их обозначают как $\neg$, $\land$, $\lor$ и $\oplus$. Логические операции, подобно математическим, имеют приоритет. Самая высокоприоритетная --- $\neg$, потом $\land$, потом $\oplus$, и только в конце $\lor$. Как их писать в языках? Сначала ст\'{о}ит вспомнить про то, что есть побитовые, а есть логические. Побитовые --- это \mintinline{c}{~}, \mintinline{c}{&}, \mintinline{c}{|} и \mintinline{c}{^}. Логические --- \mintinline{c}{!}, \mintinline{c}{&&}, \mintinline{c}{||} и отсутствие всякого знака для xor. Вообще говоря, можно считать его как \mintinline{c}{!=}, но тогда надо оба аргумента привести к типу \mintinline{c}{bool} (которого, кстати, как мы помним, не существует), но тогда и побитовый xor будет работать.\\
    Локальный филиал дискретки. Логические схемы можно рисовать. И есть два способа, уродский и нормальный. Уродский (также известный как американский) выглядит так:
    \begin{center}\begin{tikzpicture}[circuit logic US]
        \node[not gate, draw] (not) {};
        \draw ($(not.input) - (.25,0)$) -- (not.input);
        \draw (not.output) -- ($(not.output) + (.25,0)$);
        
        \node[and gate, draw, logic gate inputs=nn] (and) at ($(not) + (2,0)$) {};
        \draw ($(and.input 1) - (.25,0)$) -- (and.input 1);
        \draw ($(and.input 2) - (.25,0)$) -- (and.input 2);
        \draw (and.output) -- ($(and.output) + (.25,0)$);
        
        \node[or gate, draw, logic gate inputs=nn] (or) at ($(and) + (2,0)$) {};
        \draw ($(or.input 1) - (.25,0)$) -- (or.input 1);
        \draw ($(or.input 2) - (.25,0)$) -- (or.input 2);
        \draw (or.output) -- ($(or.output) + (.25,0)$);
        
        \node[xor gate, draw, logic gate inputs=nn] (xor) at ($(or) + (2,0)$) {};
        \draw ($(xor.input 1) - (.25,0)$) -- (xor.input 1);
        \draw ($(xor.input 2) - (.25,0)$) -- (xor.input 2);
        \draw (xor.output) -- ($(xor.output) + (.25,0)$);
    \end{tikzpicture}\end{center}
    А нормальный (европейский и российский):
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
        \node[not gate, draw] (not) {};
        \draw ($(not.input) - (.25,0)$) -- (not.input);
        \draw (not.output) -- ($(not.output) + (.25,0)$);
        
        \node[and gate, draw, logic gate inputs=nn] (and) at ($(not) + (2,0)$) {};
        \draw ($(and.input 1) - (.25,0)$) -- (and.input 1);
        \draw ($(and.input 2) - (.25,0)$) -- (and.input 2);
        \draw (and.output) -- ($(and.output) + (.25,0)$);
        
        \node[or gate, draw, logic gate inputs=nn] (or) at ($(and) + (2,0)$) {};
        \draw ($(or.input 1) - (.25,0)$) -- (or.input 1);
        \draw ($(or.input 2) - (.25,0)$) -- (or.input 2);
        \draw (or.output) -- ($(or.output) + (.25,0)$);
        
        \node[xor gate, draw, logic gate inputs=nn] (xor) at ($(or) + (2,0)$) {};
        \draw ($(xor.input 1) - (.25,0)$) -- (xor.input 1);
        \draw ($(xor.input 2) - (.25,0)$) -- (xor.input 2);
        \draw (xor.output) -- ($(xor.output) + (.25,0)$);
    \end{tikzpicture}\end{center}
    Конкретно на картинке изображён российский формат. Европейский отличается от него тем, что в отрицании пишут $1$, а в дизъюнкции --- ${\geqslant}1$. Чем лучше нормальный? Во-первых не нужны художественные способности, а во-вторых, можно обвести кусок схемы в прямоугольник, как-нибудь его назвать и писать внутри прямоугольничков своё название, отсылаясь к этой части схемы. Ровно так можно построить, например, and, or и xor на несколько входов, используя двухвходовые.
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
        \node (x0) at (0,0) {};
        \node (x1) at (0,-.5) {};
        \node (x2) at (0,-1) {};
        \node[and gate, draw, logic gate inputs=nn, anchor=input 1] at ($(x0)+(1,0)$) (And1) {};
        \node[and gate, draw, logic gate inputs=nn, anchor=input 1] at ($(And1.output)+(1,0)$) (And2) {};
        \draw (x0) -- (And1.input 1);
        \draw (x1) -- ($(x1)+(.75,0)$) |- (And1.input 2);
        \draw (And1.output) -- (And2.input 1);
        \draw (x2) -- ($(x2)+(2.25,0)$) |- (And2.input 2);
        \draw (And2.output) -- ($(And2.output)+(.5,0)$);
    \end{tikzpicture}\end{center}
    Давайте сделаем полусумматор (HSUM) с двумя входами и двумя выходами. При этом входы у него равнозначные, а выходы --- разные, <<с>> и <<s>>. Этот элемент складывает два битовых числа и в качестве s возвращает сумму, а в качестве c --- переполнение.
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
        \node (a) at (0,.25) {};
        \node (b) at (0,-.25) {};
        \node[and gate, draw, logic gate inputs=nn, anchor=input 1] at (1.75,1) (And) {};
        \node[xor gate, draw, logic gate inputs=nn, anchor=input 1] at (1.75,-1) (Xor) {};
        \draw (a) -- ($(a)+(.75,0)$) node[branch] {} -- (And.input 1);
        \draw (a) -- ($(a)+(.75,0)$) node[branch] {} -- (Xor.input 1);
        \draw (b) -- ($(b)+(.75,0)$) node[branch] {} -- (And.input 2);
        \draw (b) -- ($(b)+(.75,0)$) node[branch] {} -- (Xor.input 2);
        \draw (And.output) -- ([xshift=0.5cm]And.output) node[above] {$c$};
        \draw (Xor.output) -- ([xshift=0.5cm]Xor.output) node[above] {$s$};
    \end{tikzpicture}\end{center}
    Теперь давайте сделаем сумматор (SUM), у которого есть 3 входа. Третий --- это перенос предыдущего разряда. Его можно построить несколькими разными способами, и любой из них работает. Один из них выглядит так:
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
        \node (a) at (-.25,.25) {};
        \node (b) at (-.25,0) {};
        \node (c) at (-.25,-.25) {};
        \node[or gate, draw, logic gate inputs=nnn, or gate IEC symbol={$\scriptstyle{=}1$}] at (2.5,1) (Xor) {};
        \node[or gate, draw, logic gate inputs=nn] at (1.75,-.5) (Or1) {};
        \node[or gate, draw, logic gate inputs=nn] at (1.75,-2) (Or2) {};
        \node[or gate, draw, logic gate inputs=nn] at (1.75,-3.5) (Or3) {};
        \node[and gate, draw, logic gate inputs=nnn] at (3,-2) (And) {};
        \draw (a) -- ++(1.25,0) node[branch] (a') {} |- (Xor.input 1);
        \draw (b) -- ++(1,0) node[branch] (b') {} |- (Xor.input 2);
        \draw (c) -- ++(.75,0) node[branch] (c') {} |- (Xor.input 3);
        \draw (a) -- (a') |- (Or1.input 1);
        \draw (b) -- (b') |- (Or1.input 2);
        \draw (a) -- (a') |- (Or2.input 1);
        \draw (c) -- (c') |- (Or2.input 2);
        \draw (b) -- (b') |- (Or3.input 1);
        \draw (c) -- (c') |- (Or3.input 2);
        \draw (Or1.output) -- ++(.25,0) |- (And.input 1);
        \draw (Or2.output) -- (And.input 2);
        \draw (Or3.output) -- ++(.25,0) |- (And.input 3);
        \draw (Xor.output) -- ([xshift=1cm]Xor.output) node[above] {$s$};
        \draw (And.output) -- ([xshift=0.5cm]And.output) node[above] {$c$};
    \end{tikzpicture}\end{center}
    Второй ---
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
        \node[or gate, or gate IEC symbol={$\scriptstyle\mathrm{HSUM}$}, draw, logic gate inputs=nn] at (0,0) (Sum0) {};
        \node[rotate=180, or gate, or gate IEC symbol={$\phantom{\scriptstyle\mathrm{HSUM}}$}, draw, logic gate inputs=nn] at (0,0) (Sum0') {};
        \draw ($(Sum0.input 1)-(.5,0)$) -- (Sum0.input 1);
        \draw ($(Sum0.input 2)-(.5,0)$) -- (Sum0.input 2);
        \draw (Sum0'.input 2) -- ([xshift=0.5cm]Sum0'.input 2) node[above] {$c$};
        
        \node[or gate, or gate IEC symbol={$\scriptstyle\mathrm{HSUM}$}, draw, logic gate inputs=nn] at (2,-1.5) (Sum1) {};
        \node[rotate=180, or gate, or gate IEC symbol={$\phantom{\scriptstyle\mathrm{HSUM}}$}, draw, logic gate inputs=nn] at (2,-1.5) (Sum1') {};
        \draw (Sum0'.input 1) -- ([xshift=0.5cm]Sum0'.input 1) node[right] {$s$} |- (Sum1.input 1);
        \draw ($(Sum1.input 2)-(2.5,0)$) -- (Sum1.input 2);
        \draw (Sum1'.input 2) -- ([xshift=0.5cm]Sum1'.input 2) node[right] {$c$};
        \draw (Sum1'.input 1) -- ([xshift=2.5cm]Sum1'.input 1) node[below] {$s$};
        
        \node[or gate, draw, logic gate inputs=nn] at (4,0) (Or) {};
        \draw ([xshift=0.5cm]Sum0'.input 2) -- (Or.input 1);
        \draw ([xshift=0.5cm]Sum1'.input 2) |- (Or.input 2);
        \draw (Or.output) -- ([xshift=.5cm]Or.output) node[above] {$c$};
    \end{tikzpicture}\end{center}
    Как в программировании, код, который делает что-то, можно написать по-разному. Ещё, с горя можно рисовать СДНФ. Или СКНФ. И, как и код, схемы можно оптимизировать. Мы этим заниматься не будем, потому что мы пока не понимаем, какие элементы дороже ст\'{о}ят, а какие --- дешевле. Без этого оптимизация бессмысленна.\\
    Ещё можно сделать элемент с двумя входами ($a$ и $b$) и одним выходом ($q$), который работает так:\\
    \begin{tabular}{cc|l}
        $a$ & $b$ & $q$\\
        \hline
        0 & 0 & сохранение того значения, которое было в начале времён\\
        0 & 1 & 0\\
        1 & 0 & 1\\
        1 & 1 & не важно\\
    \end{tabular}\\
    Есть проблема, это логический элемент второго порядка, он имеет какое-то своё внутреннее состояние. Канонический способ его построить выглядит так.
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
            \node[label=90:$R$] (r) at (0,1) {};
            \node[nor gate, draw, logic gate inputs=nn,anchor=input 1] (Nor1) at ($(r)+(1.5,0)$) {};
            \draw (r) -- (Nor1.input 1);
            \draw (Nor1.output) -- ++(1.5,0) node[above] {$Q$};
            
            \node[label=-90:$S$] (s) at (0,-1) {};
            \node[nor gate, draw, logic gate inputs=nn,anchor=input 2] (Nor2) at ($(s)+(1.5,0)$) {};
            \draw (s) -- (Nor2.input 2);
            \draw (Nor2.output) -- ++(1.5,0) node[below] {$\overline Q$};
            
            \draw (Nor1.input 2) -- ++(-.5,0) -- ++(0,-.5) node[inner sep=0pt] (A) {};
            \draw (Nor2.input 1) -- ++(-.5,0) -- ++(0,.5) node[inner sep=0pt] (B) {};
            \draw (Nor1.output) -- ++(.5,0) node[branch] {} -- ++(0,-.5) -- (B);
            \draw (Nor2.output) -- ++(.5,0) node[branch] {} -- ++(0,.5) -- (A);
    \end{tikzpicture}\end{center}
    Более того, на самом деле это ещё и наиболее оптимальный способ её построить. Полученная штука является простейшей ячейкой памяти. Ещё по стандарту она называется RS-триггер (S --- set, установить бит в 1, R --- reset, сбросить бит в 0). Выход $\overline Q$ ей так-то не нужен, но вообще удобно, что его можно получить без лишнего применения инверсии.\\
    Прежде чем переходить к следующим видам триггеров, нужно решить проблемку. Пусть есть процессор частотой 3ГГц. На какое расстояние распространяется информация за один такт? $3\times10^8\frac{\text{м}}{\text{с}}\frac1{3\text{ГГц}}=0.1\text{м}=10\text{см}$. Иначе говоря, за один такт с одного конца материнской платы до другой мы не можем передать сигнал. Даже теоретически. И это одна из проблем роста тактовой частоты. Именно поэтому 4ГГц было давно, а 5ГГц мы как-то взять не можем. Потому что возникает куча физических проблем, особенно если пытаться массово производить такие процессоры. Просто один хрен мы произведём это так, чтобы было прибыльно.\\
    И это далеко не единственная проблема. Пусть у нас есть провода, по которым мы настолько быстро меняем сигнал. А значит провод превращаются в катушку индуктивности, а два рядом расположенных провода --- в трансформатор. Как мы можем помнить из курсов физики, трансформатор --- это штука, которая из-за разных индуктивностей катушки меняет напряжение. Причём чем больше частота, тем эффективнее. А у нас 3ГГц. Для сравнения, даже в зарядных устройствах используются трансформаторы с частотой в несколько МГц максимум, а чаще --- КГц. Пусть мы передаем по одному проводу $010101010$, а по другому --- $0$. Тогда в первом уменьшится амплитуда этих $1$, а второй просто будет давать флуктуации. И это 2 провода, а если их много, то получается полный хаос, который ещё и не по тактам, потому что катушки с задержкой работают. Можно почитать про Ethernet. Там написано, что соотношение чего-то разумного к шуму, как стояние рядом с турбиной самолёта, в связи с чем там пытаются очень хитро закодировать всё.\\
    Поэтому все очень надеются на оптические компьютеры. Вот, оптическая линия связи работает прекрасно, фотонам индифферентно в полной мере, летят ли другие фотоны, не летят ли, вдоль они летят или поперёк. Проблема в стыковке оптоволокна. Его гнуть нельзя, специальные конверторы нужны. Вдобавок оптоволокно дешевле только если его на длинные расстояния передавать. Итого, оптика пока только теоретическая. А ещё у фотонов есть проблема. То, что фотоны друг другу не мешают, значит, что их трудно ловить и трудно ими управлять. Электроны легко управляются магнитным полем, а фотоны --- нет.\\
    Вдобавок если есть провода, то никто не гарантирует, что сигналы придут одновременно. То есть если вы передаёте \mintinline{c}{char} в 8 бит, то у вас могут придти некоторые биты, а некоторые --- нет. И будет непонятное промежуточное состояние. Поэтому придумали провод синхронизации, который передаёт 0, пока мы не уверены, что всё дошло, а потом --- 1. Вот RS-триггер, например, может и жить асинхронно, потому что переключение одного провода не может ничего сломать до того, как придёт переключение второго провода. Но есть и синхронный вариант, где мы добавляем вход $c$. Он, как несложно понять, выглядит так:
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
            \node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\scriptstyle\mathrm{RS}$}] (RS) at (0,0) {};
            \node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\phantom{\scriptstyle\mathrm{RS}}$},rotate=180] (RS') at (RS) {};
            \draw (RS'.input 1) -- ++(.5,0) node[below] {$\overline Q$};
            \draw (RS'.input 2) -- ++(.5,0) node[above] {$Q$};
            \draw (RS.input 1) node[above left] {$\scriptscriptstyle r$} -- ++(-.5,0) -- ++(0,.5) -- ++(-.5,0) node[and gate, draw, logic gate inputs=nn,anchor=output] (And1) {};
            \draw (RS.input 2) node[below left] {$\scriptscriptstyle s$} -- ++(-.5,0) -- ++(0,-.5) -- ++(-.5,0) node[and gate, draw, logic gate inputs=nn,anchor=output] (And2) {};
            \draw (And1.input 1) -- ++(-1,0) node[above] (R) {$R$};
            \draw (And2.input 2) -- ++(-1,0) node[below] (S) {$S$};
            \node (C) at ($(And1.input 2)+(And2.input 1)+(1,0)$) {};
            \draw (C) node[left] {$C$} -- ++(0.5,0) node[branch] (b) {} |- (And1.input 2);
            \draw (b) |- (And2.input 1);
    \end{tikzpicture}\end{center}
    Но ст\'{о}ит сказать, что синхронизация бывает двух видов. У нас --- синхронизация по уровню. То есть элемент работает, пока $c=1$. А есть синхронизация по фронту, при которой элемент работает только в момент перехода $0\to1$. Это мы на схеме изобразить не сможем, для него нужно специальное электронное устройство, там нужно опускаться ниже, чем в логические элементы. Но на самом деле синхронизация и так, и так постоянно переключается, поэтому не так важно, какая именно синхронизация используется. Именно на синхронизации, кстати, работает разгон разных железок. Есть отдельный тактовый генератор, генерирующий синхронизацию, и если разогнать его, все элементы будут работать быстрее. Но понятно, что могут получится артефакты из-за того, что значение ещё не успело придти до синхронизации.\\
    Итак, у нас есть синхронный RS-триггер. Давайте построим ещё триггеров. Все следующие триггеры будут синхронными всегда. Есть D-триггер:\\
    \begin{tabular}{c|c}
        $d$ & $q$\\
        \hline
        0 & 0\\
        1 & 1\\
    \end{tabular}\\
    Почему это триггер, а не просто провод? Потому что у него есть синхронизация, если там $0$, то он сохраняет значение, а не читает вход. Построить его, уже имея синхронный RS-триггер, очень легко:
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
            \node[and gate, draw, logic gate inputs=nnn, and gate IEC symbol={$\scriptstyle\mathrm{RS}$}] (RS) at (0,0) {};
            \node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\phantom{\scriptstyle\mathrm{RS}}$},rotate=180] (RS') at (RS) {};
            \draw (RS'.input 1) -- ++(.5,0) node[below] {$\overline Q$};
            \draw (RS'.input 2) -- ++(.5,0) node[above] {$Q$};
            \draw (RS.input 1) node[above left] {$\scriptscriptstyle r$} -- ++(-1/3,0) node[not gate, draw, scale=1/3, anchor=output] (Not) {};
            \draw (RS.input 2) node[above left] {$\scriptscriptstyle c$} -- ++(-1.5,0) node[above] {$C$};
            \draw (RS.input 3) node[below left] {$\scriptscriptstyle s$} -- ++(-1.5,0) node[below] {$D$};
            \draw ($(RS.input 3)-(.75,0)$) node[branch] {} |- (Not.input);
    \end{tikzpicture}\end{center}
    А что есть мы хотим сделать модуль MEM на 8 бит, который принимает $A_0$, $A_1$, $A_2$ как индекс записываемого/читаемого бита, $R/W$ --- пишем мы или читаем, $D$ --- если пишем, то что, $C$ --- синхронизацию и возвращает $Q$ --- прочитанный бит, если есть. Сначала заметим, что нам нужно 8 триггеров, так как хранится 8 бит значений. А это значит, что нам нужно по трём числам $A_0$, $A_1$ и $A_2$ понять, в какой триггер надо записать значение. Спойлеры, нам ещё надо будет это значение вернуть, а значит нужно обратное преобразование, зная 8 выходов триггеров вернуть нужный. Это осуществляется при помощи таких элементов как мультиплексор и демультиплексор. Внутри их обоих обычно есть общая часть, которая называется <<3 to 8 decoder>>:
    \begin{center}\begin{tikzpicture}[circuit logic IEC]
            \foreach\i in {0,...,7}
            {
                \node[and gate, draw, logic gate inputs=nnn, scale=2/3] at (0,-\i*.75) (And\i) {};
                \draw (And\i.output) -- ++(.5,0) node[right] {$Q_{\i}$};
            }
            \foreach\i in {1,...,6}
            {
                \draw (And\i.input 1) -- ++(-.5,0) node[branch] {};
                \draw (And\i.input 2) -- ++(-.75,0) node[branch] {};
                \draw (And\i.input 3) -- ++(-1,0) node[branch] {};
            }
            \draw (And0.input 1) node[neg] {} -- ++(-.5,0) |- (And7.input 1);
            \draw (And0.input 2) node[neg] {} -- ++(-.75,0) |- (And7.input 2);
            \draw (And0.input 3) node[neg] {} -- ++(-1,0) |- (And7.input 3);
            \node[neg] at (And1.input 2) {};
            \node[neg] at (And1.input 3) {};
            \node[neg] at (And2.input 1) {};
            \node[neg] at (And2.input 3) {};
            \node[neg] at (And3.input 3) {};
            \node[neg] at (And4.input 1) {};
            \node[neg] at (And4.input 2) {};
            \node[neg] at (And5.input 2) {};
            \node[neg] at (And6.input 1) {};
            
            \draw ($(And0.input 1)!.5!(And5.input 3)-(.5,0)$) node[branch] {} -- ++(-1,0) node[left] {$A_0$};
            \draw ($(And1.input 1)!.5!(And6.input 3)-(.75,0)$) node[branch] {} -- ++(-1,0) node[left] {$A_1$};
            \draw ($(And2.input 1)!.5!(And7.input 3)-(1,0)$) node[branch] {} -- ++(-1,0) node[left] {$A_2$};
    \end{tikzpicture}\end{center}
    Мультиплексор (MUX) и демультиплексор (DEMUX) крафтятся из него соответственно вот так:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[draw=white,and gate, and gate IEC symbol={$\scriptstyle\substack{\mathrm{3to8}\\\mathrm{dec}}$}, logic gate inputs=nnn, scale=2] at (0,1.5) (3to8) {};
            \node[draw, and gate, and gate IEC symbol={$\scriptstyle\phantom{\mathrm{3to8}}$}, logic gate inputs=nnnnnnnn, rotate=180,scale=2] at (0,1.5) (3to8') {};
            \foreach\i in {0,...,2}
            {
                \pgfmathparse{int(\i+1)}
                \draw (3to8.input \pgfmathresult) -- ++(-.5,0) node[left] {$A_{\i}$};
            }
            \node[or gate, draw, logic gate inputs=nnnnnnnn] at (5.5,-2.625) (Or) {};
            \draw (Or.output) -- ++(.5,0) node[above] {$Q$};
            \foreach\i in {0,...,7}
            {
                \node[and gate, draw, logic gate inputs=nnn, scale=2/3] at (3.5,-\i*.75) (And\i) {};
                \pgfmathparse{int(8-\i)}
                \draw (3to8'.input \pgfmathresult) -- ++(.25+\pgfmathresult/4,0) |- (And\i.input 1);
                \pgfmathparse{int(\i+1)}
                \draw (And\i.output) -- (Or.input \pgfmathresult);
                \draw (And\i.input 2) -- ++(-4.5,0) node[left] {$D_{\i}$};
            }
            \node[above right] at (3to8'.input 8) {$\scriptscriptstyle q_0$};
            \node[below right] at (3to8'.input 1) {$\scriptscriptstyle q_7$};
        \end{tikzpicture}
        \begin{tikzpicture}[circuit logic IEC]
            \node[draw=white,and gate, and gate IEC symbol={$\scriptstyle\substack{\mathrm{3to8}\\\mathrm{dec}}$}, logic gate inputs=nnn, scale=2] at (0,1.5) (3to8) {};
            \node[draw, and gate, and gate IEC symbol={$\scriptstyle\phantom{\mathrm{3to8}}$}, logic gate inputs=nnnnnnnn, rotate=180,scale=2] at (0,1.5) (3to8') {};
            \foreach\i in {0,...,2}
            {
                \pgfmathparse{int(\i+1)}
                \draw (3to8.input \pgfmathresult) -- ++(-.5,0) node[left] {$A_{\i}$};
            }
            \foreach\i in {0,...,7}
            {
                \node[and gate, draw, logic gate inputs=nnn, scale=2/3] at (3.5,-\i*.75) (And\i) {};
                \pgfmathparse{int(8-\i)}
                \draw (3to8'.input \pgfmathresult) -- ++(.25+\pgfmathresult/4,0) |- (And\i.input 1);
                \pgfmathparse{int(\i+1)}
                \draw (And\i.output) -- ++(.5,0) node[right] {$Q_{\i}$};
            }
            \foreach\i in {1,...,6}
            {
                \draw (And\i.input 2) -- ++(-.25,0) node[branch] {};
            }
            \draw (And7.input 2) -- ++(-.25,0) node[branch] (D) {} |- (And0.input 2);
            \draw (D) -- ++(-4.25,0) node [left] {$D$};
            \node[above right] at (3to8'.input 8) {$\scriptscriptstyle q_0$};
            \node[below right] at (3to8'.input 1) {$\scriptscriptstyle q_7$};
        \end{tikzpicture}
    \end{center}
    Используя их уже довольно просто построить MEM.
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[draw=white,and gate, and gate IEC symbol={$\scriptstyle\mathrm{DEMUX}$}, logic gate inputs=nnnnnnn, scale=2] at (0,0) (DEMUX) {};
            \node[draw, and gate, and gate IEC symbol={$\scriptstyle\phantom{\mathrm{DEMUX}}$}, logic gate inputs=nnnnnnnn, rotate=180,scale=2] at (0,0) (DEMUX') {};
            \foreach\i in {0,...,2}
            {
                \pgfmathparse{int(\i+1)}
                \draw (DEMUX.input \pgfmathresult) -- ++(-1.25+\i/4,0) node[branch] (A\i) {} -- ++(-1-\i/4,0) node[left] {$A_{\i}$};
            }
            \node[above left] at (DEMUX.input 1) {$\scriptscriptstyle a_0$};
            \node[below left] at (DEMUX.input 3) {$\scriptscriptstyle a_2$};
            \node[below left] at (DEMUX.input 7) {$\scriptscriptstyle d$};
            \node[above right] at (DEMUX'.input 8) {$\scriptscriptstyle q_0$};
            \node[below right] at (DEMUX'.input 1) {$\scriptscriptstyle q_7$};
            \draw (DEMUX.input 7) -- ++(-.5,0) node[draw,and gate,logic gate inputs=nn,anchor=output] (And) {};
            \draw (And.input 1) -- ++(-.5,0) node[left] {$R/W$};
            \draw (And.input 2) -- ++(-.5,0) node[left] {$C$};
            
            \foreach\i in {0,...,7}
            {
                \node[and gate, and gate IEC symbol={$\scriptstyle\mathrm D$}, draw, logic gate inputs=nn] at (4,4.5625-\i*1.25) (D\i) {};
                \node[above left] at (D\i.input 1) {$\scriptscriptstyle d$};
                \node[below left] at (D\i.input 2) {$\scriptscriptstyle c$};
                \pgfmathparse{int(8-\i)}
                \let\ind\pgfmathresult
                \pgfmathparse{int(3.5-abs(3.5-\i))}
                \draw (DEMUX'.input \ind) -- ++(.5+\pgfmathresult/4,0) |- (D\i.input 2);
            }
            \foreach\i in {1,...,6}
            {
                \draw (D\i.input 1) -- ++(-.5,0) node[branch] {};
            }
            \draw (D7.input 1) -- ++(-.5,0) node[branch] (D) {} |- (D0.input 1);
            \draw (D) -- ++(-6,0) node [left] {$D$};
            
            \node[draw,and gate, and gate IEC symbol={$\scriptstyle\mathrm{MUX}$}, logic gate inputs=nnnnnnnnnnnnnn, scale=2] at (9,0) (MUX) {};
            \foreach\i in {0,...,2}
            {
                \pgfmathparse{int(\i+1)}
                \draw (MUX.input \pgfmathresult) -- ++(-.75-\i/4,0) -- ++(0,4) -| (A\i);
            }
            \node[above left] at (MUX.input 1) {$\scriptscriptstyle a_0$};
            \node[below left] at (MUX.input 3) {$\scriptscriptstyle a_2$};
            \node[above left] at (MUX.input 7) {$\scriptscriptstyle d_0$};
            \node[below left] at (MUX.input 14) {$\scriptscriptstyle d_8$};
            \foreach\i in {0,...,7}
            {
                \pgfmathparse{int(7+\i)}
                \let\ind\pgfmathresult
                \pgfmathparse{int(abs(4-\i)-4)}
                \draw (D\i.output) -- ++(1.5+\pgfmathresult/4,0) |- (MUX.input \ind);
            }
            \draw (MUX.output) -- ++(.5,0) node[right] {$Q$};
        \end{tikzpicture}
    \end{center}
    У нас получился игрушечный модуль памяти. Почему игрушечный? Потому что для памяти в 1GB понадобится такая куча проводов, что все уже упомянутые проблемы вступят в силу.\\
    Ещё есть JK-триггер:
    \begin{tabular}{cc|l}
        $j$ & $k$ & $q$\\
        \hline
        0 & 0 & сохранение\\
        0 & 1 & 0\\
        1 & 0 & 1\\
        1 & 1 & инверсия внутреннего состояния\\
    \end{tabular}\\
    Понятно, что это только синхронно, иначе инверсия может работать непонятно насколько большое количество раз. Таким образом получится генератор случайных чисел. Более того, мы хотим синхронизировать её по уровню, то есть пока мы держим $J=K=C=1$, состояние не должно меняться. \sout{Построение JK-триггера оставим как домашнее задание читателю.} Нет, не оставим. Давайте рассмотрим вот такую схему:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[and gate,scale=3,logic gate inputs=nnn,and gate IEC symbol={$\mathrm{RS}$}] (RS) {};
            \node[and gate,scale=3,and gate IEC symbol={$\phantom{\mathrm{RS}}$},rotate=180] (RS') {};
            \node[above left] at (RS.input 1) {$\scriptscriptstyle r$};
            \node[above left] at (RS.input 2) {$\scriptscriptstyle c$};
            \node[below left] at (RS.input 3) {$\scriptscriptstyle s$};
            \node[below right] at (RS'.input 1) {$\scriptscriptstyle\overline q$};
            \node[above right] at (RS'.input 2) {$\scriptscriptstyle q$};
            \draw (RS.input 1) -- ++(-.5, 0) node[and gate,anchor=output] (And1) {};
            \draw (RS'.input 2) -- ++(.5,0) to[short, *-] ++(0,2) -- ++(-4,0) |- (And1.input 1);
            \draw (RS.input 3) -- ++(-.5, 0) node[and gate,anchor=output] (And2) {};
            \draw (RS'.input 1) -- ++(.5,0) to[short, *-] ++(0,-2) -- ++(-4,0) |- (And2.input 2);
            \draw (And1.input 2) -- ++(-1,0) node[left] {$K$};
            \draw (And2.input 1) -- ++(-1,0) node[left] {$J$};
            \draw (RS.input 2) -- (RS.input 2 -| And1.input 1) -- ++(-1,0) node[left] {$C$};
            \draw (RS'.input 2) -- ++(1,0) node[right] {$Q$};
            \draw (RS'.input 1) -- ++(1,0) node[right] {$\overline Q$};
        \end{tikzpicture}
    \end{center}
    Если присмотреться, то можно заметить, что она делает почти то, что нужно, если её на вход подать две единицы, она инвертирует состояние. Проблема в том, что тут синхронизация должна работать по фронту, а не по уровню, ведь если сделать по уровню, то триггер как раз и будет постоянно инвертировать своё состояние, вследствие чего мы не будем знать ответ. Чтобы это пофиксить, достаточно добавить второй RS-триггер, который будет хранить то самое предыдущее состояние, которое мы хотим инвертировать. Вот так выглядит схема:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[and gate,scale=3,logic gate inputs=nnn,and gate IEC symbol={$\mathrm{RS}$}] (RS) {};
            \node[and gate,scale=3,logic gate inputs=nnn,and gate IEC symbol={$\phantom{\mathrm{RS}}$},rotate=180] at (RS) (RS') {};
            \node[above left] at (RS.input 1) {$\scriptscriptstyle r$};
            \node[above left] at (RS.input 2) {$\scriptscriptstyle c$};
            \node[below left] at (RS.input 3) {$\scriptscriptstyle s$};
            \node[below right] at (RS'.input 1) {$\scriptscriptstyle\overline q$};
            \node[above right] at (RS'.input 3) {$\scriptscriptstyle q$};
            
            \draw (RS'.input 3) -- ++(1.5,0) node[and gate,scale=3,logic gate inputs=nnn,and gate IEC symbol={$\mathrm{RS}$},anchor=input 1] (RS2) {};
            \draw (RS'.input 1) -- (RS2.input 3);
            \node[and gate,scale=3,logic gate inputs=nnn,and gate IEC symbol={$\phantom{\mathrm{RS}}$},rotate=180] at (RS2) (RS2') {};
            \node[above left] at (RS2.input 1) {$\scriptscriptstyle s$};
            \node[above left] at (RS2.input 2) {$\scriptscriptstyle c$};
            \node[below left] at (RS2.input 3) {$\scriptscriptstyle r$};
            \node[below right] at (RS2'.input 1) {$\scriptscriptstyle\overline q$};
            \node[above right] at (RS2'.input 3) {$\scriptscriptstyle q$};
            
            \draw (RS.input 1) -- ++(-1, 0) node[and gate,anchor=output] (And1) {};
            \draw (RS.input 3) -- ++(-1, 0) node[and gate,anchor=output] (And2) {};
            \draw (RS2'.input 3) -- ++(.5,0) to[short, *-] ++(0,1.5) -- (\currentnode -| And1.input 1) -- ++(-.5,0) |- (And1.input 1);
            \draw (RS2'.input 1) -- ++(.5,0) to[short, *-] ++(0,-1.5) -- (\currentnode -| And2.input 2) -- ++(-.5,0) |- (And2.input 2);
            
            \draw (And1.input 2) -- ++(-1,0) node[left] {$K$};
            \draw (And2.input 1) -- ++(-1,0) node[left] {$J$};
            \draw (RS.input 2) -- (\currentnode -| And1.input 1) -- ++(-1,0) node[left] {$C$};
            \draw (RS2'.input 3) -- ++(1,0) node[right] {$Q$};
            \draw (RS2'.input 1) -- ++(1,0) node[right] {$\overline Q$};
            
            \draw (RS2.input 2) -- ++(-.25,0) node[not gate,anchor=output,scale=.75] (Not) {};
            \draw (RS.input 2) -- ++(-.5,0) to[short,*-] ++(0,-1.75) -- (\currentnode -| {$(RS'.input 1)!.3!(RS2.input 3)$}) |- (Not.input);
        \end{tikzpicture}
    \end{center}
    Что в этой схеме хорошего, а что плохого? Хорошего --- она работает. Плохого --- она работает с опозданием. То есть сначала ей подают 1 на синхронизацию, и работает первый триггер, а потом 0 --- и работает второй, выдавая ответ. То есть ответ выдаётся на половину такта позже, чем приходит синхронизация. И это либо надо править, либо как-то с этим жить. Можно ли это поправить, если мы переставим элемент <<НЕ>> от второго триггера к первому? На первый взгляд, да. Но не дайте себя обмануть. В таком случае первый триггер будет сохранять значения, когда синхронизация ещё не пришла. А пока синхронизации нет, на проводах может быть абсолютно всё, что угодно. В частности, мы можем менять первый RS-триггер так, как нам вздумается, хотя не должны бы. Но как-то же это можно исправить? Да, можно. Можно оставить <<НЕ>> на своём месте, но просто выходы $Q$ и $\overline Q$ брать не с выходов второго триггера, а с выходов первого. И задержка пропадёт, хотя всё останется правильно работающим.
    \paragraph{\undercolorblack{orange}{Закапывание в логические элементы}.}
    Сначала надо понимать, что всё можно делать по разному. В древние времена были варианты реализации логических элементов: TTL, RTL, DTL, PMOS, NMOS. Сейчас они все мертвы, в высокоскоростных штуках работает только CMOS. Самое первое поколение устройств (если не брать совсем средневековые штуки) было основано на реле. На катушку индуктивности подаётся ток, появляется магнитное поле, которое примагничивает проводок от одного контакта к другому. Проблема в том, что контакты при частом замыкании/размыкании теряют качество. А таких реле нужно очень много. Есть домик, который набит реле. Они безумно щёлкают и постоянно ломаются. Если посчитать вероятность поломки хотя бы одного из них, то получится, что хоть что-то ломается постоянно. То есть по сути у тебя есть специально обученный монгол, который регулярно их чинит. И это лучше шестерёнок, но всё ещё хреново.
    Следующий этап --- лампы, которые работают на нитях накаливания. А они перегорают. И опять, учитывая их количество, постоянно. Чуть-чуть реже, но не сильно. Зато не щёлкают, а гудят! И работают чуть быстрее.
    Дальше транзисторы. За счёт отсутствия механического взаимодействия и нагрева, они так часто не ломаются, и это прекрасно.
    Потом электронные схемы (кучка транзисторов на одном кристалле), единственный плюс которых --- уменьшенный размер. Потом появились большие и сверхбольшие интегральные схемы с той же самой сутью, а дальше никто не считает, битва шла только за размеры.\\
    Итак, мы живём в транзисторах. А в каких транзисторах? Исходно были биполярные, но сейчас их полностью вытеснили полевые. Мы ещё изучим принцип их работы, а пока давайте посмотрим, как что обозначать. Биполярный транзистор обозначается так:
    \begin{center}
        \begin{tikzpicture}
            \node[pnp] (T) at (0,0) {};
            \node[left] at (T.base) {База};
            \node[below] at (T.collector) {Коллектор};
            \node[above] at (T.emitter) {Эмиттер};
            \draw ($(T)-(0.18,0)$) circle [radius=14pt];
        \end{tikzpicture}
    \end{center}
    (Конкретно на картинке изображён pnp-транзистор.) А полевые --- много как. Конкретно мы будем обозначать их вот так:
    \begin{center}
        \begin{tikzpicture}
            \node[nmos] (T) at (0,0) {};
            \node[left] at (T.gate) {Затвор};
            \node[above] at (T.drain) {Сток};
            \node[below] at (T.source) {Исток};
        \end{tikzpicture}
        \begin{tikzpicture}
            \node[pmos] (T) at (0,0) {};
            \node[left] at (T.gate) {Затвор};
            \node[below] at (T.drain) {Сток};
            \node[above] at (T.source) {Исток};
        \end{tikzpicture}
    \end{center}
    Ещё можно обвести в кружочек, но это обычно значит, что это отдельный элемент. Полевых транзисторов бывает великое множество, конкретно на картинке изображены полевые транзисторы с изолированным затвором и каналом, работающем на обогащение. Слева --- n-тип, справа --- p-тип. Именно этих двух типов транзисторы обычно используются в вычислительной технике.\\
    Почему раньше использовались биполярные? Потому что они были быстрее. Но в них, чтобы они пропускали ток от эмиттера к коллектору, нужно, чтобы от базы тоже шёл ток. И это потери энергии. Раньше на них не обращали внимания, а потом поняли, что это самое количество энергии не масштабируется. И эта энергия тратится на поддержание замкнутого состояния. У полевых же транзисторов энергия тратится на переключение, что оптимальнее. К тому же у полевых транзисторов при уменьшении размера растёт скорость.\\
    Чтобы понять, как работает транзистор, надо понять, что такое диод. Это полупроводник, одна часть которого n-типа, а вторая --- p-типа. Что такое полупроводник? Это элемент, промежуточный между проводниками и диэлектриками. Более того, такой, который может менять своё состояние в зависимости от разных штук. Химически чистые полупроводники имеют высокое сопротивление. Но есть добавить к ним очень небольшое количество примеси, можно создать на кристалле избыток либо электронов, либо <<дырок>> (мест в атоме под электроны, не занятые таковыми). И то, и другое, грубо говоря, явлется свободными заряженными частицами. Оба типа примесей приводят к тому, что сопротивление полупроводника становится небольшим. Но интересные штуки получатся, когда мы сплавим два полупроводника разных типов вместе.
    \begin{center}
        \begin{tikzpicture}
            \draw[pattern=north west lines,pattern color=red, opacity=.5] (0,.5) rectangle (1,-.5);
            \draw[pattern=north east lines,pattern color=blue, opacity=.5] (0,.5) rectangle (-1,-.5);
            \node[scale=1.5] at (.5,0) {$\mathbf p$};
            \node[scale=1.5] at (-.5,0) {$\mathbf n$};
            \draw (1,0) -- ++(.5,0);
            \draw (-1,0) -- ++(-.5,0);
        \end{tikzpicture}
        \hspace{5cm}
        \begin{tikzpicture}
            \draw (1.5,0) to[diode] (-1.5,0);
        \end{tikzpicture}
    \end{center}
    Лишние электроны n-части переместятся в p-часть, что создаст диэлектрический запирающий слой, через который ток течь не может. Если мы приложим положительный потенциал к n, а отрицательный --- к p, то это запирание только увеличится, ток никуда не потечёт, пока не приложить очень большое напряжение (пробив, по сути, запирающий слой). А вот если поменять полярность, то дырки будут ползти в сторону электронов, а электроны --- в обратную. То есть ток как раз потечёт. Это можно применять, например, для превращения переменного тока в постоянный. Если у нас есть переменный ток:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 6cm, height = 4cm,
                trig format plots = rad,
                xmin = -1, xmax = 5,
                ymin = -1.5, ymax = 1.5,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                x axis line style = {->},
                y axis line style = {draw=none},
                xtick = \empty,
                ytick = \empty,
                ]
                \addplot[domain=-1:5,samples=100,red] {sin(5*x)};
            \end{axis}
        \end{tikzpicture}
    \end{center}
    То, применив диод, получим
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 6cm, height = 4cm,
                trig format plots = rad,
                xmin = -1, xmax = 5,
                ymin = -1.5, ymax = 1.5,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                x axis line style = {->},
                y axis line style = {draw=none},
                xtick = \empty,
                ytick = \empty,
                ]
                \addplot[domain=-2*pi/5:-pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=0:pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=2*pi/5:3*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=4*pi/5:5*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=6*pi/5:7*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=8*pi/5:9*pi/5,samples=15,red] {sin(5*x)};
            \end{axis}
        \end{tikzpicture}
    \end{center}
    Применив специальную конструкцию из четырёх диодов (диодный мост), получим:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 6cm, height = 4cm,
                trig format plots = rad,
                xmin = -1, xmax = 5,
                ymin = -1.5, ymax = 1.5,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                x axis line style = {->},
                y axis line style = {draw=none},
                xtick = \empty,
                ytick = \empty,
                ]
                \addplot[domain=-2*pi/5:-pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=-pi/5:0,samples=15,red] {-sin(5*x)};
                \addplot[domain=0:pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=pi/5:2*pi/5,samples=15,red] {-sin(5*x)};
                \addplot[domain=2*pi/5:3*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=3*pi/5:4*pi/5,samples=15,red] {-sin(5*x)};
                \addplot[domain=4*pi/5:5*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=5*pi/5:6*pi/5,samples=15,red] {-sin(5*x)};
                \addplot[domain=6*pi/5:7*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=7*pi/5:8*pi/5,samples=15,red] {-sin(5*x)};
                \addplot[domain=8*pi/5:9*pi/5,samples=15,red] {sin(5*x)};
                \addplot[domain=9*pi/5:10*pi/5,samples=15,red] {-sin(5*x)};
            \end{axis}
        \end{tikzpicture}
    \end{center}
    И только добавив в эту конструкцию конденсатор (или более сложный фильтр), можно получить что-то похожее на постоянный ток.\\
    Полевой транзистор --- штука чуть более хитрая. Вот она:
    \begin{center}
        \begin{tikzpicture}
            \draw[green,fill] (-2/3,1) rectangle (2/3,1+1/12);
            \draw (-2,1) rectangle (2,-1);
            \draw[pattern=north east lines,pattern color=blue, opacity=.5] (-1-1/3,1/3) rectangle (-2/3,1);
            \node[scale=1.5] at ($(-1-1/3,1/3)!.5!(-2/3,1)$) {$\mathbf n$};
            \draw (-1,1) -- ++(0,1) node[above] {Исток};
            \draw[pattern=north east lines,pattern color=blue, opacity=.5] (1+1/3,1/3) rectangle (2/3,1);
            \node[scale=1.5] at ($(1+1/3,1/3)!.5!(2/3,1)$) {$\mathbf n$};
            \draw (1,1) -- ++(0,1) node[above] {Сток};
            \draw (-2/3,1+1/12) -- (2/3,1+1/12);
            \draw (0,1+1/12) -- ++(0,1+1/12) node[above] {Затвор};
            \draw (0,-1) -- ++(0,-1) node[below] {Подложка};
            \draw[dashed,pattern=north east lines,pattern color=red,opacity=1/3] (2,1) -- (1+2/3,1) to[in=-100,out=-80,distance=2cm] (-1-2/3,1) -- (-2,1) -- (-2,-1) -- (2,-1) -- cycle;
            \node[scale=1] at (0,-5/6) {$\mathbf p$};
        \end{tikzpicture}
    \end{center}
    $\mathbf p$ --- это полупроводник с очень маленькой концентрацией <<дырок>>, $\mathbf n$ --- это полупроводник с концентрацией электронов побольше. Белое --- это практически чистый полупроводник, а зелёное --- диэлектрик. Если приложить напряжение между стоком и истоком, то тока нам не будет, ведь сопротивление чистого полупроводника там высокое, ток не потечёт. Но что будет, если приложить положительное напряжение на затвор? У нас немного увеличится подложка (область с дырками), так как электрончики будут немножко вырываться от кремния в сторону затвора. Но на провод они не побегут, ибо там находится изолятор, около которого они и осядут. Там образуется избыток электронов. И вот именно по этому каналу и могут течь электроны от стока до истока. Конкретно тут описан n-тип, в p-типе просто всё инвертировано. Ему на затвор, понятно, надо подавать отрицательное напряжение. Теперь видно, почему энергия тут тратится только на переключение состояния, а не на его поддержание. Теперь вопрос: зачем тут подложка? А вот потому что подложка может случайно накопить заряд из окружающей среды. Небольшой, но для создания канала много энергии и не нужно. И вот поэтому подложку обычно соединяют с землёй.
    Кстати, по-английски этот транзистор называют MOSFET (metal-oxide-semiconductor field-effect transistor), что очень точно описывает его устройство: первые 3 слова --- это его составные части, а field-effect --- это принцип работы, он управляется полем.
    \paragraph{\undercolorblack{orange}{Детально о логиках}.}
    Рассмотрим NMOS. Он использует резисторы и транзисторы n-типа.
    \begin{center}
        \begin{tikzpicture}
            \node[tlground] (GND) {};
            \node[nmos,anchor=source] at (GND.north) (T) {};
            \node[ocirc] at (T.gate) (in) {};
            \node[above] at (in) {v\textsubscript{in}};
            \draw (T.drain) to[short,*-] ++(.5,0) node[ocirc] (out) {};
            \node[above] at (out) {v\textsubscript{out}};
            \draw (T.drain) to[R] ++(0,2) node[tground,rotate=45] {};
        \end{tikzpicture}
    \end{center}
    Ст\'{о}ит заметить, что логики бывают двух типов, позитивная и негативная. В позитивной логике уровень логического значения <<1>> выше <<0>>. В негативной --- наоборот. В NMOS, например, <<0>> --- это 0, а <<1>> --- это какое-то положительное количество вольт. Если на входе 0, то транзистор имеет какое-то большое сопротивление. Пусть 1 МОм. А резистор, пусть 1 КОм. Тогда (при 0 на входе) у нас получается делитель напряжения. Сопротивлением резистора почти можно пренебречь (по сравнению с транзистором-то), а значит на выходе получится напряжение, то есть <<1>>. Если же у нас транзистор открыт, будем считать его сопротивление 1 Ом. Тогда наоборот, мы теряем почти всё напряжение на резисторе, на выходе у нас почти 0. Почему от этого отказались? Через транзистор и резистор (при 1 на входе) течёт немаленький ток, что даёт нам пожирание большого количества энергии, особенно учитывая количество таких элементов. Та же проблема у биполярных транзисторов по определению. И вот тут приходит CMOS.
    \begin{center}
        \begin{tikzpicture}
            \node[tlground] (GND) {};
            \node[nmos,anchor=source] at (GND.north) (NT) {};
            \draw (NT.gate) -- ++(0,1.5) node[pmos,anchor=gate] (PT) {};
            \draw (NT.drain) -- (PT.drain);
            \node[tground,rotate=45] at (PT.source) {};
            \draw ($(NT.gate)!.5!(PT.gate)$) to[short,*-] ++(-.5,0) node[ocirc] (in) {};
            \node[above] at (in) {v\textsubscript{in}};
            \draw ($(NT.drain)!.5!(PT.drain)$) to[short,*-] ++(.5,0) node[ocirc] (out) {};
            \node[above] at (out) {v\textsubscript{out}};
        \end{tikzpicture}
    \end{center}
    Если подать на вход 0, то нижний транзистор закрыт (у него везде 0), а верхний --- открыт (ему на исток дают напряжение больше, чем на затвор). Если подать на вход 1, то наоборот. Тут уже сопротивление всегда огромное, при стабильном состоянии CMOS логика почти ничего не потребляет. Она потребляет энергию только при переключении. Именно поэтому, кстати, при разгоне тактовой частоты, расход энергии растёт, причём почти линейно. Теперь NOR.
    \begin{center}
        \begin{tikzpicture}
            \node[tground,rotate=45] (POW) {};
            \node[pmos,anchor=source] at (POW.north) (P1) {};
            \node[pmos,anchor=source] at (P1.drain) (P2) {};
            \draw (P2.drain) to[short,*-] ++(.5,0) node[ocirc] (out) {};
            \node[above] at (out) {v\textsubscript{out}};
            \node[nmos,anchor=drain] at (P2.drain) (N2) {};
            \draw (P2.drain) -- ++(-1.25,0) node[nmos,anchor=drain] (N1) {};
            \draw (N2.gate) to[short,-*] (P2.gate) -- ++(-1.75,0) node[ocirc] (in2) {};
            \node[above] at (in2) {v\textsubscript{in2}};
            \draw (N1.gate) |- (P1.gate);
            \draw (N1.gate |- P1.gate) to[short,*-] ++(-.5,0) node[ocirc] (in1) {};
            \node[above] at (in1) {v\textsubscript{in1}};
            \draw (N1.source) -- (N2.source);
            \draw ($(N1.source)!.5!(N2.source)$) to[short,*-] ++(0,-.5) node[tlground] {};
        \end{tikzpicture}
    \end{center}
    Если среди верхних есть единичка, то верхние транзисторы закрыты (хотя бы один из них), а нижние --- открыты. На выходе получается земля, то есть 0. Если оба входа --- 0, но наоборот, верхние открыты, а нижние --- закрыты, на выходе --- питание, то есть 1. Понятно, как аналогичным образом построить NAND.
    \begin{center}
        \begin{tikzpicture}
            \node[tlground,rotate=180] (POW) {};
            \node[nmos,anchor=drain] at (POW.north) (N1) {};
            \node[nmos,anchor=drain] at (N1.source) (N2) {};
            \draw (N2.source) to[short,*-] ++(.5,0) node[ocirc] (out) {};
            \node[above] at (out) {v\textsubscript{out}};
            \node[pmos,anchor=source] at (N2.source) (P2) {};
            \draw (N2.source) -- ++(-1.25,0) node[pmos,anchor=source] (P1) {};
            \draw (P2.gate) to[short,-*] (N2.gate) -- ++(-1.75,0) node[ocirc] (in2) {};
            \node[above] at (in2) {v\textsubscript{in2}};
            \draw (P1.gate) |- (N1.gate);
            \draw (P1.gate |- N1.gate) to[short,*-] ++(-.5,0) node[ocirc] (in1) {};
            \node[above] at (in1) {v\textsubscript{in1}};
            \draw (P1.drain) -- (P2.drain);
            %\draw ($(P1.drain)!.5!(P2.drain)$) to[short,*-] ++(0,-.5) node[tlground] {};
            \draw ($(P1.drain)!.5!(P2.drain)$) to[short,*-] ++(0,-.5) node[tground,rotate=-45] {};
        \end{tikzpicture}
    \end{center}
    И в этой логике нельзя построить <<И>> и <<ИЛИ>> проще, чем соединить нужную штуку с <<НЕ>>. И тут уже понятно, как оптимизировать CMOS. Также заметим, что мы можем построить NAND/NOR на три входа дешевле, чем соединением двух двухвходовых. Два двухвходовых имеют 8 транзисторов, а один трёхвходовый --- 6.
    \paragraph{\undercolorblack{orange}{Поговорим о дребезге контактов}.}
    Что это? В кнопке есть части из пружинящего металла. Если нажать кнопку, металл отскочет, потом вдавится обратно, снова отскочет и так много раз, пока не установится стабильное соединение. Результатом этого являются частые (но недолговременные) смены сигнала с 0 на 1 и обратно, до того, как установится 1. Бороться с ним можно аппаратно (то есть хитро и сложно), а можно программно, поставив задержку в восприятие кнопки. Но при устаревании время дребезжания увеличивается, что может дать множественные нажатия, если задержка будет недостаточной для достижения стабильности. Но оказывается, если есть схема с двумя выходами (когда кнопка передаёт сигнал на один из двух проводов), её можно очень легко исправить.
    Вот как было:
    \begin{center}
        \begin{tikzpicture}
            \node[spdt] (S) {};
            \node[left] at (S.in) {v\textsubscript{in}};
            \node[right] at (S.out 1) {v\textsubscript{out1}};
            \node[right] at (S.out 2) {v\textsubscript{out2}};
        \end{tikzpicture}
    \end{center}
    Вот как стало:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[spdt] (S) {};
            \draw (S.out 1) -- ++(1,0) node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\scriptstyle\mathrm{RS}$},scale=1.9,anchor=input 1] (RS) {};
            \node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\phantom{\scriptstyle\mathrm{RS}}$},scale=1.9,rotate=180] (RS') at (RS) {};
            \draw (S.out 2) -- (RS.input 2);
            \node[above left] at (RS.input 1) {$\scriptstyle R$};
            \node[below left] at (RS.input 2) {$\scriptstyle S$};
            \draw (RS'.input 1) -- ++(.5,0) node[below] {$\scriptstyle Q$};
            \draw (RS'.input 2) -- ++(.5,0) node[above] {$\scriptstyle \overline{Q}$};
            \draw ($(RS.input 1)+(-.5,0)$) to[short,*-] ++(0,-1) node (tmp1) {}  to[R,bipoles/length=20pt] ++(0,-1) node[coordinate] (GND1) {};
            \node[coordinate] at ($(RS.input 2)+(-1,0)$) (tmp2) {};
            \draw (tmp2) to[short,*-] (tmp2 |- tmp1) to[R,bipoles/length=20pt] ++(0,-1) node[coordinate] (GND2) {};
            \draw (GND1) -- (GND2);
            \draw ($(GND1)!.5!(GND2)$) -- ++(0,-.5) node[tlground] {};
        \end{tikzpicture}
    \end{center}
    Заметим, что это действительно работает. В том положении, что на рисунке $Q=0$, так как на вход подаётся Reset. Когда мы двигаем переключатель вниз, у нас на вход начинают передаваться два нуля, то есть значение сохраняется до начала дребезжания. При этом в течение всего дребезжания на вход подаётся то Set, то два нуля, то есть триггер стабильно выдаёт единицу. Такая конструкция, кстати, спасает от окисления проводов максимально эффективно, потому что первый удар кнопки достаточно сильный для того, чтобы пропустить сигнал, а следовательно передать Set триггеру.\\
    Но это не всё с такими кнопками. На вход кнопки может передаваться что-то, не являющееся тождественной единицей (колебания, например), и мы хотим на соответствующий выход кнопки просто передавать этот сигнал. А наш триггер будет выдавать на этот выход единицу. Это исправляется через транзистор.
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[tground,rotate=135] (POW) {};
            \draw (POW) -- ++(.5,0) node[spdt,anchor=in] (S) {};
            \draw (S.out 1) -- ++(1,0) node[and gate, draw, logic gate inputs=nn, and gate IEC symbol={$\scriptstyle\mathrm{RS}$},scale=1.9,anchor=input 1] (RS) {};
            \draw (S.out 2) -- (RS.input 2);
            \node[above left] at (RS.input 1) {$\scriptstyle R$};
            \node[below left] at (RS.input 2) {$\scriptstyle S$};
            \node[above right] at (RS.output) {$\scriptstyle Q$};
            \draw (RS.output) -- ++(.5,0) node[nmos,anchor=gate] (T) {};
            \draw ($(RS.input 1)+(-.5,0)$) to[short,*-] ++(0,-1) node (tmp1) {}  to[R,bipoles/length=20pt] ++(0,-1) node[coordinate] (GND1) {};
            \node[coordinate] at ($(RS.input 2)+(-1,0)$) (tmp2) {};
            \draw (tmp2) to[short,*-] (tmp2 |- tmp1) to[R,bipoles/length=20pt] ++(0,-1) node[coordinate] (GND2) {};
            \draw (GND1) -- (GND2);
            \draw ($(GND1)!.5!(GND2)$) -- ++(0,-.5) node[tlground] {};
            \draw (T.source) -- ++(.5,0) node[ocirc] (out) {};
            \node[above] at (out) {v\textsubscript{out}};
            \draw (T.drain) -- ++(0,.5) -- ++(-5,0) node[ocirc] (in) {};
            \node[above] at (in) {v\textsubscript{in}};
        \end{tikzpicture}
    \end{center}
    \section{Реальные модули памяти.}
    \paragraph{\undercolorblack{orange}{Устройство реальных модулей памяти}.}
    В нашем игрушечном модуле ячейками были D-триггеры. Это не самое удобное устройство, и не самое маленькое. Поэтому нужно проще. Ячейки памяти делятся на динамическую память и статическую память. Вот статическая:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[nmos,rotate=-90] (T1) {};
            \draw (T1.drain) to[short,*-] ++(.25,0) node[not gate,anchor=input,scale=.5] (Not1) {};
            \draw (Not1.output) to[short,-*] ++(.25,0) node[nmos,rotate=-90,anchor=source] (T2) {};
            \node[not gate,scale=.5] at ($(Not1)-(0,1)$) (Not2) {};
            \draw (Not2.output) -- (T2.source |- Not2.output) -- ++(0,.25) -- ($(T1.drain)-(0,.25)$) -- (T1.drain);
            \draw (Not2.input) -- (T1.drain |- Not2.input) -- ++(0,.25) -- ($(T2.source)-(0,.25)$) -- (T2.source);
            \draw (T1.source) to[short,*-] ++(0,1.5) node[above] {$Col$};
            \draw (T1.source) -- ++(0,-1.25);
            \draw (T2.drain) to[short,*-] ++(0,1.5) node[above] {$\overline{Col}$};
            \draw (T2.drain) -- ++(0,-1.25);
            \draw (T1.gate) -- (T2.gate);
            \draw (T1.gate) to[short,*-] ++(-1.25,0) node[left] {$Row$};
            \draw (T2.gate) to[short,*-] ++(1.25,0);
        \end{tikzpicture}
    \end{center}
    Это называется классической 6-транзисторной ячейкой памяти (ещё по 2 спрятаны в отрицаниях). На схеме у нас входы $S$ и $R$ объединены с $Q$ и $\overline Q$ соответственно ($Col$ и $\overline{Col}$). $Row$ --- это то, выбираем ли мы ячейку, или нет. Если на $Row$ ноль, но наши штуки просто ничего не делают. Если мы включили $Row$ и не трогаем $Col$ и $\overline{Col}$, то мы можем их читать, получая значение ячейки. Если же мы подаём данные на $Col$ или $\overline{Col}$, то получается запись. В игрушечной памяти наши ячейки были линейно расположены, в настоящей же имеется тенденция располагать всё в квадраты, где маленькие квадратики --- это то, что мы уже нарисовали.
    \begin{center}
        \begin{tikzpicture}
            \draw[step=.5,black] (0,0) grid (3,3);
            \foreach\i in {1,2,3,4,5,6}
            {
                \draw[thick,red] (3,\i/2-.25) -- (-.5,\i/2-.25) node[left] {$\scriptscriptstyle Row_{\i}$};
                \draw[thick,green] (\i/2-.33,0) -- (\i/2-.33,4) node[above] {$\scriptscriptstyle Col_{\i}$};
                \draw[thick,green] (\i/2-.165,0) -- (\i/2-.165,3.5) node[above] {$\scriptscriptstyle \overline{Col}_{\i}$};
            }
        \end{tikzpicture}
    \end{center}
    Внимание, вопрос, сколько у нас проводов для одной ячейки? 3? Нет, 5. Помимо $Row$, $Col$ и $\overline{Col}$ у отрицаний есть земля и питание. Они, кстати, общие для всех. И заметим, что у нас теперь количество проводов --- это не $O$ от количества ячеек памяти, а $O$ от его корня, что намного лучше. Это была статическая память --- довольно сложная в устройстве, но быстрая капец. Таковой являются кэш и регистры процессора.\\
    А динамическая память (которой является оперативная память и видеопамять) выглядит так:
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[nmos,rotate=-90] (T1) {};
            \draw (T1.drain) to[C,bipoles/length=20pt] ++(0,-1) node[tlground] {};
            \draw (T1.source) to[short,*-] ++(0,1.5) node[above] {$Col$};
            \draw (T1.source) -- ++(0,-1.25);
            \draw (T1.gate) to[short,*-] ++(-1.25,0) node[left] {$Row$};
            \draw (T1.gate) -- ++(1.25,0);
        \end{tikzpicture}
    \end{center}
    Конденсатор, кстати, --- это почти бесплатно, это чуть ли не просто 2 близко расположенных проводника. Располагаются ячейки динамической памяти также в матрицы, но тут всё намного проще. Тут в полтора раза меньше проводов и нет питания. В статической памяти состояние хранится в том, какие транзисторы открыты. В динамической --- заряд конденсатора. Итак, динамическая выигрывает в стоимости и размере. А в чём проигрывает? Во-первых в скорости (транзисторы переключаются быстрее, чем конденсатор заряжается или разряжается). Во-вторых, измерение заряда конденсатора (в силу его величины) разряжает конденсатор, а значит его надо заряжать заново. В-третьих, конденсаторы имеют ток утечки. Время, за которое конденсатор разряжается --- миллисекунды. Поэтому нужно периодически проходиться по ячейкам и перезаряжать конденсаторы. Это называется регенерацией динамической памяти. В первых моделях это делал программист. Это не даёт вам делать долгоработающие расчёты, память забудет, что вы там насчитали. Ещё это может делать контроллер памяти. Это устройство, которое стыкует модуль памяти с процессором. То есть тот, кто преобразует команду <<записать в ячейку номер 3>> в магию с памятью. Минусы --- контроллер памяти раньше жил в чипсете, а теперь в процессоре. Поэтому постоянно происходит передача данных (получить данные из памяти и записать обратно) на достаточно длинные расстояния. И третий, современный вариант, модуль памяти занимается этим сам. Он периодически перестаёт реагировать на сигналы и регенерируется сам. Но он не знает, с какой частотой он работает. И ему надо явно указывать, через сколько тактов это делать. И тут такая же шняга, как с разгоном процессора, но наоборот. Если увеличить интервал, то производительность вырастет, но появятся ошибки.\\
    Кстати, интересный факт. Есть статическая память из другого количества транзисторов. Даже есть больше, 8, где дополнительные транзисторы нужны для уменьшения энергопотребления.\\
    Давайте теперь поговорим о том, какие у памяти есть характеристики. Самое простое --- объём. Хочется сказать, что скорость доступа и скорость записи. Со скоростью доступа всё понятно, а вот чётко сформулировать, что такое скорость записи, сложно. Ещё про долговечность хочется говорить, но для больших классов памяти --- это бесконечность. Поэтому этот параметр используется только если есть явный износ. У флэш-памяти, например. Хотя, ещё есть МБТФ, но это вероятностная характеристика, а не что-то гарантированное. Вообще, с долговечностью в современном мире дела обстоят так, что если у вас написана долговечность, то всё, что ломается раньше --- гарантийный случай, не более того. Поэтому рассчитывать на долговечность компонентов не ст\'{о}ит. Если мы строим надёжную систему, обычно используется просто избыточность (много параллельно работающих компонентов, если сломался один --- система всё ещё работает, пока ты меняешь сломанную деталь). То же самое относится и к памяти в серьёзных системах, кстати. Правда, это скорее про внешние накопители, а не про оперативную память. Но память, вообще говоря, сама по себе умирает редко. Дефекты производства --- да, это норма, а в противном случае --- очень редко. Кроме проблем с блоком питания. Не покупайте дешёвые блоки питания. Но всё же, вернёмся к характеристикам памяти. Скорость доступа мы уже упомянули, а есть ещё скорость передачи данных. И не всегда корректно говорить термины <<скорость чтения/записи>>. В какой-нибудь флеш-памяти эти характеристики, да, отличаются. Но в болом количестве типов (оперативка, винчестеры) это одно и то же время, потому что эти процессы не так уж и отличаются. А вот про скорость доступа и передачи надо поговорить. Скорость доступа --- это время реакции на запрос. Прочитать файл, например. И вот время от дачи команды и до получения первой порции данных ответа --- это именно оно. Скорость передачи --- это время между получением одной и другой порции данных. И это разные характеристики. Первое --- это своего рода нахождение данных, взаимодействие разных устройств, а вторая --- это уже про передачу данных, когда всё настроено. И вот эти три (учитывая объём) характеристики в разных типах памяти со временем эволюционируют довольно одинаково. Объём эволюционирует очень быстро, скорость передачи --- чуть помедленнее, но тоже быстро, а скорость доступа --- не эволюционирует вообще. Ст\'{о}ит уточнить, что имеется ввиду эволюция внутри одного класса. Понятно, что если сравнивать винчестеры, магнитные накопители и SSD, то они будут сильно отличаться. Но эволюция памяти внутри одного класса почти везде именно такая. Что происходит с объёмом, мы все и так видим в магазинах. Со скоростью передачи сложнее, мы её сразу не видим. Но мы можем косвенно её увидеть, если мы попытаемся заметить, сколько времени требуется на чтение/запись всего диска. Если взять дискету, то там это время --- пара минут. С тех пор возросли и объём, и скорость, но на современном винчестере это время --- много часов. Это говорит о том, что скорость передачи медленнее эволюционирует, чем объём. Со скоростью доступа всё ещё грустнее. У современных винчестеров этот параметр может быть даже хуже, чем у винчестеров 10-летней давности, потому что сейчас к высокоскоростным (по скорости доступа) в основном относятся SSD. И винчестеры меньше стараются быть быстрыми. Их сильные стороны --- объём и стоимость. Поэтому современные винчестеры могут быть медленнее 10-летных просто из-за экономии. Если смотреть на оперативную память, то там скорость доступа возрастает в одном стандарте, а при переходе на новый она уменьшается. В DDR5 это можно легко заметить. За много лет скорость доступа если и улучшилась, то очень незначительно по сравнению со скоростью передачи. Почему новые поколения медленнее старых? Потому что нужно отладить новые технологии, пока они неотлаженные --- они медленные. Так, например, у Intel с их 10нм: к тому моменту, как они эти 10нм выпустили, как раз отладили 14нм, в связи с чем 14нм было эффективнее. И вообще, кстати, прогресс вычислительной техники связан в основном с прогрессом производства, а не с какими-нибудь гениальными идеями программистов, алгоритмами или чем-либо ещё. Нейронные сети были известны давно, но только сегодняшнее железо может их позволить. С алгоритмами сжатия --- то же самое. Новые алгоритмы, конечно, изобретаются, но это тоже в основном связано с тем, что можно использовать больше ресурсов. Раньше памяти было мало, входные данные были небольшими, в связи с чем адекватно (более того, быстрее) работали простые алгоритмы за квадрат. А это сейчас нам нужны за какие-нибудь логарифмы и прочее. Это вот всё про разные виды памяти. Объём в голове держать не надо, там понятно, копипастишь блок памяти, увеличиваешь объём. А на остальное надо обратить внимание.\\
    Итак, мы умеем в динамические и статические ячейки. Заметим, что возникает законное желание строить не квадрат, а куб, и попытки к этому есть, но сейчас вся логика двухмерная. В смысле, что на кристалле только один \textbf{логический} слой (не логических --- много). И сделать больше --- сложно. Только сейчас это началось с флеш-памятью (в 128 слоёв). Если сравнить это с плотностью элементов внутри кристалла, то это очень сильно меньше. То есть трёхмерка, скорее всего, развиваться будет, но не так хорошо, как хотелось бы. В каких-нибудь презентациях можно, конечно, увидеть \textit{невероятные технологии} (кладём кристалл на другой кристалл, например), но на них никто пока не умеет делать ничего особо высокопроизводительного. Самое крутое --- это AMD технология, когда они на вычислительные ядра сверху кладут кэш. Да и то это пока не поступило в продажу. Поступить должно в начале этого-конце следующего кода. И надо понимать, что проблема --- это отвод тепла. Кремний его проводит слабо, а греется всё очень хорошо. Это в принципе так работает CMOS. В итоге надо очень эффективно всё охлаждать, а кристаллы друг на друге этому не способствуют. Да и вообще сбор нескольких кристаллов вместе --- это сложно технически, да ещё и недёшево, ведь это новые шаги производства. Вообще про производство. Производство выч. техника специфически ст\'{о}ит. Разработка и запуск --- это дорого, а само производство --- не очень. Поэтому стоимость кристалла связана скорее с объёмом выпуска, нежели с чем-то ещё. Если выпустить миллиард кристаллов, то стоимость разработки можно равномерно распределить в стоимость этого миллиарда, и в каждом вклад получится небольшим. А если вы делаете равно один кристалл, он будет стоить как самолёт. Этот один кристалл надо разработать и отладить (а отладить --- это ещё важнее, чем в софте, в софте можно новую версию выпустить, а процессоры никак не исправить, можно только заставить компилятор генерировать код, не наступающий на баги процессора). Проблема в том, что каждый новый уровень заставляет вас применять всё более хитрые методы, причём экспоненциально более хитрые, экспоненциально более дорогие. И часть компаний просто забили на гонку изза дороговизны. Потом нужно понимать, что вообще не всем нужны новые технологии. Бытовая электроника комфортно живёт на старом, отлаженном, изученном и дешёвом железе. Вот, в мобилках это критично, один из главных бонусов --- это энергопотребление. Технике, которая всегда подключена в розетку, пофиг, вдвое больше или вдвое меньше она жрёт. А телефону --- нет. Поэтому не всем и нужно сражаться в технологической гонке. И из десятков компаний по производству микросхем остались TSMC и Samsung.\\
    Давайте отвлечёмся ещё сильнее и поговорим о законе Мура. Изначально он звучал как <<Каждые 2 года количество транзисторов, эффективно размещаемых на кристалле, удваивается>>. Эффективно в первую очередь экономически. И долгое время это значило, что и мощность удваивается каждый год. Но в те времена энергопотребление одного транзистора также уменьшалось вдвое каждый год, что позволяло просто взять это удвоенное количество транзисторов, разместить и не париться. Но со временем появились проблемы. Во-первых, транзисторы не дают простого линейного прироста в скорости вычислений. Во-вторых, повысилось энергопотребление, в связи с чем сейчас на кристалле можно гипотетически разместить намного больше транзисторов, чем охладить. Когда мы перейдём к процессорам и к их технологиям, станет понятно, что прогресс либо вообще качественный, либо последующий рост будет намного медленнее, чем за первые пару шагов.\\
    Вернёмся к памяти. Итак, у нас есть статическая и динамическая. Перейдём к устройству модулей памяти и прежде всего к оперативной памяти. Потому что кэш --- внутренняя часть, нет нужды точно определять, что там происходит, её можно строить как хочешь. А оперативную память производят другие люди, там надо точно всё специфицировать. Итак, у нас есть матрица. Как мы с ней общаемся? У нас есть интерфейсная схема, к которой подключаются столбцы матриц.
    \begin{center}
        \begin{tikzpicture}
            \draw[step=.5,black] (0,0) grid (2.5,2.5);
            \draw (0,1.25) -- ++(-0.5,0) node[tground,rotate=45] (Rows) {} -- ++(-0.5,0);
            \draw (1.25,2.5) -- ++(0,0.5) node[tground,rotate=45] (Cols) {} -- ++(0,0.5);
            \draw (0,3.5) rectangle (2.5,4);
            \draw (0,3.625) -- ++(-2,0) node[below right] {$R/W$};
            \draw (0,3.75) -- ++(-2.125,0) node[left] {$C$};
            \draw (0,3.875) -- ++(-1,0) node[tground,rotate=45,scale=.5] {} -- ++(-1,0) node[above right] {$D_i$};
        \end{tikzpicture}
    \end{center}
    Эта схема --- это, можно сказать, логика модуля памяти, в которую входят $C$, $R/W$ и подобные. Какое ещё принципиальное отличие нашего игрушечного модуля от реальных? Выходы и входы данных в нашей игрушке никогда одновременно не используются. В реальности и входы, и выходы данных --- это одни и то же провода. Насколько это имеет смысл экономить? А дело в том, что модуль многоразрядный. Он по 16 бит, например. И вот эти линии, отвечающие за информацию, действительно нужно экономить, ведь уменьшение их количества вдвое --- это хорошо. Помимо R/W, C и данных у нас есть адресные входы. Если у нас $2^{10}$ столбцов и строк, то нам нужно по 10 адресных входов на столбцы и на строки. Обычно номер строки --- это, как правило, старшие биты адреса, а номер столбца --- младшие.
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \draw[step=.5,black] (0,0) grid (2.5,2.5);
            \draw (0,1.25) -- ++(-0.5,0) node[tground,rotate=45] (Rows) {} -- ++(-0.5,0) node[and gate,draw,logic gate inputs=nnn,and gate IEC symbol={},anchor=output,scale=.75] (r) {};
            \node[above] at (Rows) {$Row_i$};
            \draw (r.input 2) -- ++(-.5,0) node[tground,rotate=45] (RA) {} -- ++(-0.5,0);
            \node[above left] at (RA) {$A_{10}$...$A_{19}$};
            \draw (1.25,2.5) -- ++(0,0.5) node[tground,rotate=45] (Cols) {} -- ++(0,0.5);
            \node[left] at (Cols) {$Col_i$};
            \draw (0,3.5) rectangle (2.5,4);
            \draw (0,3.625) -- ++(-2,0) node[below right] {$R/W$};
            \draw (0,3.75) -- ++(-2.125,0) node[left] {$C$};
            \draw (0,3.875) -- ++(-1,0) node[tground,rotate=45,scale=.5] {} -- ++(-1,0) node[above right] {$D_i$};
            \draw (0,3.5625) -- ++(-1,-1) node[and gate,draw,logic gate inputs=nnn,and gate IEC symbol={},anchor=output,scale=.75] (c) {};
            \draw (c.input 2) -- ++(-.5,0) node[tground,rotate=45] {} -- ++(-.5,0) node[above] {$A_0$...$A_9$};
        \end{tikzpicture}
    \end{center}
    Если это какой-нибудь кэш, то это так обычно и выглядит. Но если это внешний модуль памяти (оперативная память, например), то как правило выводят наружу только половину линий адреса. Их хватает либо на выбор строки, либо на выбор столбца. И то, что в данный момент означают эти линии, определяется командами. В один момент времени линии адреса переключаются с того, чтобы значить номер строки на то, чтобы значить номер столбца. На самом деле там сложнее, потому что вы не хотите делать разное количество входов у разных модулей, будет очень сложно их соединять, но так глубоко мы закапываться не будем. Внутри стандарта можно считать, что именно половина адресных входов.
    \paragraph{\undercolorblack{orange}{Row-hammer}.}
    Row-hammer --- это уязвимость оперативной памяти, которая заключается в следующем: если вы обращаетесь вокруг данного адреса, у вас сильно увеличивается скорость утекания заряда. И если у вас редко происходит регенерация, то подобными обращениями вы можете обнулить бит. Например, в Linux это даёт вам пообращаться к памяти вокруг структурки с правами доступа и обнулить их, а ноль в бите прав --- это наличие этого права.
    \paragraph{\undercolorblack{orange}{Сигналы}.}
    Сначала у нас есть синхронизация. Она выглядит понятно, как.
    \begin{center}
        \begin{tikzpicture}
            \foreach\i in {0,...,10}
            {
                \draw[very thick,darkgreen] (\i,3) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \node[darkgreen] at (-.25,3.25) {\bf C};
        \end{tikzpicture}
    \end{center}
    Потом у нас есть выводы команд, адресные входы и данные.
    \begin{center}
        \begin{tikzpicture}
            \foreach\i in {0,...,10}
            {
                \draw[very thick,darkgreen] (\i,3) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \node[darkgreen] at (-.25,3.25) {\bf C};
            \foreach\i in {0,2,9,10}
            {
                \draw[very thick,violet] (\i,2) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,violet] (1,2) -- (2,2);
            \draw[very thick,violet] (3,2) -- (9,2);
            \node[violet] at (-.5,2.25) {\bf CMD};
            \foreach\i in {0,2,10}
            {
                \draw[very thick,black] (\i,1) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,black] (1,1) -- (2,1);
            \draw[very thick,black] (3,1) -- (10,1);
            \node[black] at (-.75,1.25) {\bf ADDR};
            \draw[very thick,blue] (0,0) -- (4,0) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0) -- (11,0);
            \node[blue] at (-.75,.25) {\bf DATA};
        \end{tikzpicture}
    \end{center}
    И мы хотим рассмотреть, как происходит цикл чтения. В настоящем мире значение всех сигналов должно быть задано чуть раньше, чем синхронизация. Но мы удобства ради будем рисовать так. С чего начинается чтение? С команды открытия строки. Одновременно с ней на линию адреса передаётся адрес строки. Потом нужно некоторое время подождать, после чего можно подать следующую команду. Например, чтение. Одновременно с этой командой передаётся адрес столбца. И через некоторое время на линии данных появляется значение. Линий данных может быть несколько, если модуль данных не на несколько бит, а на несколько, например, байт. Причём модуль данных не сообщает, когда у него появятся данные. Это вы ему должны заранее сообщить все промежутки. Почему так? У нас тактовая частота --- это внешняя штука к модулю памяти. Модуль памяти не знаем, какая она. Более того, даже принципиального различия между памятью <<побыстрее>> и <<помедленнее>> может вообще не быть, то, насколько память расчитана --- не более, чем наклейка. Просто какая-то получилась побыстрее. И именно поэтому мы говорим модулю памяти, с какими промежутками работать. Эти промежутки называются таймингами.
    \begin{center}
        \begin{tikzpicture}
            \foreach\i in {0,...,10}
            {
                \draw[very thick,darkgreen] (\i,3) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \node[darkgreen] at (-.25,3.25) {\bf C};
            \foreach\i in {0,2,9,10}
            {
                \draw[very thick,violet] (\i,2) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,violet] (1,2) -- (2,2);
            \draw[very thick,violet] (3,2) -- (9,2);
            \node[violet] at (-.5,2.25) {\bf CMD};
            \foreach\i in {0,2,10}
            {
                \draw[very thick,black] (\i,1) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,black] (1,1) -- (2,1);
            \draw[very thick,black] (3,1) -- (10,1);
            \node[black] at (-.75,1.25) {\bf ADDR};
            \draw[very thick,blue] (0,0) -- (4,0) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0) -- (11,0);
            \node[blue] at (-.75,.25) {\bf DATA};
            
            \draw[red] (.5,2.5) -- ++(0,.5);
            \draw[red] (2.5,2.5) -- ++(0,.25);
            \draw[red] (4.5,.5) -- ++(0,2.25);
            \draw[red] (9.5,2.5) -- ++(0,.5);
            \draw[red] (10.5,2.5) -- ++(0,.5);
            \draw[red,<->] (.5,2.5+.125) -- (2.5,2.5+.125) node[midway,below,scale=.75] {tRCD};
            \draw[red,<->] (2.5,2.5+.125) -- (4.5,2.5+.125) node[midway,below,scale=.75] {CL};
            \draw[red,<->] (0.5,2.5+.375) -- (9.5,2.5+.375) node[midway,below,scale=.75] {tRAS};
            \draw[red,<->] (9.5,2.5+.375) -- (10.5,2.5+.375) node[midway,below,scale=.75] {tRP};
        \end{tikzpicture}
    \end{center}
    Их названия являются акронимами акронимов. tRCD, например, --- это RAS to CAS Delay. Что такое RAS и CAS? Это Row Access Strobe и Column Access Strobe --- сигнал выборки строки/столбца. То есть по человечески tRCD переводится как <<задержка между сигналами выборки строки и выборки столбца>>. Чем он по сути и является. CL --- CAS Latency --- задержка после выборки столбца, tRAS --- Active to Precharge Delay (вообще хз, каким образом это так расшифровывается) и tRP --- RAS Precharge --- ещё обсудим.\\
    И вот надо настроить эти характеристики, чтобы можно было общаться с модулем памяти. Модуль памяти знает, что ему нужна какое-то количество долей секунд на открытие строк, но как перевести их в такты --- не знает, потому что не знает, сколько длится такт. Если что-то захардкодить, на меньшей частоте модуль будет неэффективным. Итак, чтобы что-то прочесть, нужно сначала <<открыть строчку>>. Для динамической памяти это значит, что нужно перенести всю строчку в некий статический буфер, потому что, как мы говорили, ячейка одноразовая. И после этого чтение (когда передаётся адрес столбца) происходит в интерфейсной схеме. Через некоторое время после чтения, модуль памяти даст вам ответ. Когда мы прочли, что нам нужно сделать? Сначала нужно <<закрыть строку>>. Это запишет данные из того самого статического буфера обратно в матрицу. После этого можно снова открывать строку. Именно <<закрыть строку>> --- это и есть тот самый непонятный Precharge в расшифровках tRAS и tRP --- задержкой между открытием и закрытием строки и временем на закрытие строки соотвественно. Это была классическая картина обращения к динамической памяти. И со старинных времён так и было. Скорость работы процессора была меньше, чем у памяти, и всё было хорошо. Но со временем стало понятно, что процессор работает много быстрее. И вот сейчас процессор и память всё ещё работают с разными частотами. Но как-то ускорить память очень хочется. Отсюда возникли разные стандарты изменения этого. Первый такой стандарт, который мы рассмотрим, это FPM DRAM (DRAM --- это и есть динамическая память произвольного доступа). Заранее скажем, что мы рассмотрим только то, что привело к сегодняшнему положению дел, а на всякие мёртвые ответвления смотреть не будем. Что изменилось в FPM? Если вы хотите прочесть ячейки внутри одной строки, то вам не нужно закрывать строку, вместо этого вы спокойно подаёте команду чтения другого же столбца. Это привело к тому, что это существено улучшает скорость передачи. Какой-нибудь участок памяти теперь хранится в одной строке, и вместо того, чтобы ждать полный цикл много раз, мы ждём только CL много раз, что несравненно быстрее. Что произошло со скоростью доступа? Вообще говоря, она разная. Какая у нас скорость, если мы редко обращается с памятью? tRCD + CL. Но есть мы постоянно обращается (сейчас --- в разные строчки, раньше --- вообще куда угодно), то это tRAS + tRP, что сильно дольше. То есть у нас разные алгоритмы работают по-разному даже без закапывания в кэши и куда-то ещё. Следующее улучшение --- EDO DRAM. На самом деле раньше было не совсем так, как нарисовано. Нужно было держать адрес столбца на адресных линиях до конца чтения:
    \begin{center}
        \begin{tikzpicture}
            \foreach\i in {0,...,10}
            {
                \draw[very thick,darkgreen] (\i,3) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \node[darkgreen] at (-.25,3.25) {\bf C};
            \foreach\i in {0,2,9,10}
            {
                \draw[very thick,violet] (\i,2) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,violet] (1,2) -- (2,2);
            \draw[very thick,violet] (3,2) -- (9,2);
            \node[violet] at (-.5,2.25) {\bf CMD};
            \foreach\i in {0,10}
            {
                \draw[very thick,black] (\i,1) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0);
            }
            \draw[very thick,black] (2,1) -- ++(.25,0) -- ++(0,.5) -- ++(2.5,0) -- ++(0,-.5) -- ++(.25,0);
            \draw[very thick,black] (1,1) -- (2,1);
            \draw[very thick,black] (5,1) -- (10,1);
            \node[black] at (-.75,1.25) {\bf ADDR};
            \draw[very thick,blue] (0,0) -- (4,0) -- ++(.25,0) -- ++(0,.5) -- ++(.5,0) -- ++(0,-.5) -- ++(.25,0) -- (11,0);
            \node[blue] at (-.75,.25) {\bf DATA};
        \end{tikzpicture}
    \end{center}
    А в EDO разрешили делать не так, а как мы нарисовали изначально. Что это изменило? А то, что вы можете уже устанавливать номер следующего столбца, пока ждёте CL. Разумеется, не сразу, там тоже есть тайминги, причём разные между двумя записями, чтением и записью и двумя записями. Вообще таймингов у памяти вагон и \sout{маленькая тележка} ещё один вагон, но основные --- вот те 4, которые мы рассмотрели, обычно именно их везде и пишут. После EDO DRAM появился BEDO DRAM. Он стал уметь следующее: запрашивается одна ячейка памяти, а выдаётся ещё и три последующие. Причём только тогда, когда номер ячейки кончается на 2 нулевых бита. И что это улучшило? Скорость передачи данных. Для передачи кусочка подаётся в 4 раза меньше команд. Дальше была SDRAM --- синхронная память. Синхронизация была и раньше, но почему эта память так называется? Потому что синхронизация у модуля памяти и у контроллера памяти одинаковая. Ничего не понятно, но очень интересно. Как работает процессор? Он говорит: <<хочу ячейку памяти номер 3.>> Но модуль памяти работает вообще с другими терминами. У него есть номера строк, открытия, закрытия и прочая магия о которой процессору знать не надо и не положено. Связь между этими двумя уровнями (т.е. логикой и командами) осуществляется именно контроллером памяти. Он раньше стоял в чипсете (в микросхеме <<северный мост>>), а теперь переехал на кристалл процессора. И в SDRAM модуль памяти и контроллер памяти работают синхронно. К чему приводило то, что раньше они работали не так? А то, что контроллер не может точно выдержать тайминг. А значит ему придётся подождать с запасом. Хотя бы на один такт больше. А в синхронной памяти такого нет. Но это только одно крупное изменение. Второе крупное изменение --- то, что модуль памяти раньше было 32-битным, а теперь 64-битным. Это увеличило скорость передачи вдвое. Потому что мы передаём в два раза больше данных за то же время. И третье изменение. Раньше модули было однобанковыми, а теперь --- многобанковыми. Что это значит, мы ещё обсудим, сейчас не об этом. И с этого момента всё, что есть --- это SDRAM. Какой стандарт был дальше? DDR --- double data rate --- двойная скорость данных. Этот модуль памяти умеет передавать данные 2 раза за такт. У него есть две синхронизации, идущие в противофазе. Соответственно, передача данных переходит на фронте и на спаде. А откуда приходят эти данные? И на самом деле внутри модуля памяти никакая логика два раза за такт не работает. Внутренняя шина данных модуля памяти становится вдвое шире. То есть в ответ на запрос приходит 128 бит, из которых первые 64 передаются сразу, а вторые 64 задерживаются на половину такта. То есть только блок передачи работает дважды за такт, ничего другого. Дальше нужно вспомнить, когда это было. А было это во времена Pentium 4. Тогда скорость техники было принято характеризовать тактовой частотой. Pentium'ы так и назывались: Pentium 4 и частота. Тут масштаб проблем отдела маркетинга. Частота вообще не изменилась, но эффективность возросла вдвое. Поэтому маркетологи придумали \textit{эффективную частоту}. По факту они просто умножили частоту вдвое. И поэтому модуль памяти DDR на 200 МГц называется 400 МГц. И на самом деле в программах чаще встречается второе число. Ну, действительно, включает человек свой модуль (на котором большими цифрами написано 400 МГц) в компьютер, а ему программа пишет число вдвое меньше. Разумеется, он везде бегает и ругается. Заметим, что трюк с DDR был довольно унылым. Он увеличил только скорость передачи. Если бы мы по факту подняли частоту SDRAM вдвое, у нас бы вдвое увеличилась скорость доступа. Поэтому эффективная частота --- это ещё больший пиздёж. После DDR был, какая неожиданность, DDR2. Внешнюю тактовую частоту модуля памяти увеличили в 2 раза, а в его внутреннем устройстве вместо того, чтобы давать в ответ на запрос 128 бит, дают 256. Это опять ускоряет скорость передачи, но не влияет на скорость доступа. Кстати, все тайминги, выраженные в тактах, удваиваются. То есть если CL у DDR где-то 2, то у DDR2 типичное значение --- 4. Потом, какая неожиданность, DDR3. Внешняя частота в 4 раза больше, ответ на запрос --- 512 бит. Потом DDR4. Но там что-то другое произошло. Вообще в DDR3 и DDR2 происходило не только это. Например, там уменьшали напряжение питания. Тогда она жрёт меньше энергии. Но зачем? Да, сейчас модно покрывать память радиаторами, но единственное примение этого --- чтобы пользователь не смог посмотреть производителя микросхем. И народ-то, конечно, смекнул, какие производители лучше. А производители планок оперативной памяти хотят выпускать бренды, а не настоящие микросхемы. Для этого и радиаторы. И их можно пальцами трогать, они не греются нихрена. Вот к процессору пальцы вы не прислоните. А память практически не греется. Так на кой мы уменьшаем энергопотребление? Современные процессоры не всегда выделяют максимум мощности. Если вы в какой-то момент ничего не делаете (читаете, там, доку какую-нибудь), то ваш процессор тоже чиллит, уменьшая своё энергопотребление до чуть ли не нуля. А память работает постоянно, и ничего вы с этим не сделаете. Так вот, все стандарты кроме этой типовой идеи вводили разные улучшения. И DDR4 --- это набор мелких технических улучшений. Помимо ещё более сниженного энергопотребления там есть, например, тренировка памяти. Это когда контроллер и модуль памяти оценивают задержку по разным каналам связи и пытаются как-то её компенсировать, чтобы она была примерно одинаковая у всех линий данных. Но раньше это было только в момент включения, дальше система нагревается, характеристики меняются, задержки уходят в разные стороны во время работы. А в DDR4 память может перетренировывается во время работы, если контроллер понимает, что происходит какая-то фигня. В DDR5 там, видимо, снова будет удвоение. Как мы уже говорили, мы не рассматриваем разные мёртвые ответвления, например, Rambus (на котором работал Pentium 4), но у нас есть ещё GDDR. <<G>> значит графическая. В обычной DDR балансируют скорость передачи и доступа, потому что в разных алгоритмах используют разное. А в видеокартах скорость доступа почти не важна. Почему --- мы поговорим очень не скоро. И вот GDDR --- оптимизация скорости передачи в ущерб всему: скорости доступа, энергопотреблению и даже стоимости. Стандарт GDDR2 на основе DDR2 был не особо удачным и был никому не нужным. А вот GDDR3 (всё ещё на основе DDR2, но исправивший ошибки GDDR2) использовался весьма широко. С DDR3 та же история: GDDR4 оказался неудачным, а GDDR5 (тоже на DDR3) был хорош. А дальше GDDR и DDR пошли в разные стороны. Потом там был GDDR5x, потом GDDR6, затем --- GDDR6x. Возможно, туда и добавили что-то от DDR4, но хз-хз. Кстати, GDDR6x --- не стандарт. Это договорённость между NVIDIA и Micron о том, как клепать память. И кстати GDDR уже прям греется. И она находится под общим радиатором, потребляя много энергии, около 10\% всей энергии видеокарты. А сейчас проблемы с видеокартами (с процессорами тоже, так-то, но не суть) идут именно от энергии. И эти самые 10\% значат то, что вычислительный блок работает на 10\% медленнее, чем мог бы. Именно отсюда дополнительные разъёмы питания у видеокарт. Без доп. питания карта 16x может съесть 75 Вт по спецификации. 6-контактный разъём питания тоже на 75 Вт, а 8-контактный --- на 150 Вт. Причём из внешнего блока можно потребить немного больше, чем есть, а из материнской платы --- никак нельзя. Причём всё ещё зависит от того, среднее у вас потребление или пиковое. К тому же, если у вас пиковое потребление длится больше наносекунды, вам вообще бы надо с расчётом на него карточку проектировать. Поэтому в современных картах вообще 3 8-контактных разъёма. Это уже капец много. NVIDIA пыталась заменить эти три на один, но как-то нет. Но, видимо, в следующем поколении, всё-таки введут один кринжовый разъём на 600Вт. А давайте теперь поговорим об HBM. Суть этой памяти в том, чтобы модуль памяти располагался бы очень близко к процессору и имел бы много низкоскоростных проводов (в GDDR есть меньше проводов, но высокоскоростных, которые заставляют греться ещё и контроллер памяти). Так очень сильно уменьшится энергопотребление за счёт низкой частоты, не уменьшится скорость за счёт большого количества проводов, да ещё и увеличится за счёт большой параллельности. И разрядность шины у HBM измеряется в тысячах вместо 32 у GDDR. Почему важно, что оно располагается близко? Потому что проводов много. Они влияют друг на друга. Точнее, влияли бы, если бы не были так близко. Близко --- это на уровне кристалла. Обычно процессор с памятью соединены сокетом (или распаяны, но не суть). И точность этих операций --- не очень высокая. При большом желании, опыте и прямых руках можно руками спаять. А вот связать процессор и вот такой модуль памяти --- это сильно сложнее. Для этой связи нужен более специализированный завод, что даёт нам стоимость выше. В итоге HBM (учитывая то, что она не так уж и массово производится) --- это капец как дорого. Поэтому для простых геймеров никто такое не делает, только для data-центров.\\
    Вернёмся к таймингам. Производители обычно указывают либо 4 тайминга (в формате CL---tRCD---tRP---tRAS), либо только CL (например, CL9). При этом всё приводится в некоторой тактовой частоте. То есть просто сравнивать числа неверно, нужно найти частоту и посчитать всё. При этом скорость передачи (учитывая несколько ответов на один запрос) зависит в основном от тактовой частоты, а скорость доступа --- в основном от таймингов. Так как же выбрать себе память? С одной стороны, её родные настройки могут превышать стандарт DDR. И это можно пофиксить, изменив тайминги правильным образом. С другой стороны, всё на самом деле очень сложно, и есть пример памяти, которая по цифрам очень хорошо работает, но из-за того, что эти цифры сверх стандарта DDR, там возникают проблемы. Так что, не поэкспериментировав, точно решить практически невозможно. Причём эксперименты --- это ещё и изменение таймингов. И не только с целью ускорения, но и, возможно, с целью увеличения стабильности.\\
    Что ещё имеет смысл знать про память? Как она устанавливается. Например, так: несколько планок памяти <<последовательно>> сидят на шине.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw (cpu.east) -- ++(1.5,0) node[coordinate] (A) {} -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] {RAM};
            \draw (A) -- ++(1.5,0) -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] {RAM};
        \end{tikzpicture}
    \end{center}
    Но в современных системах чаще можно увидеть другую конструкцию:
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw ($(cpu.north east)!.33!(cpu.south east)$) -- ++(1.5,0) node[coordinate] (A) {} -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] (ramA1) {RAM};
            \draw (A) -- ++(1.5,0) -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] (ramA2) {RAM};
            \draw ($(cpu.north east)!.66!(cpu.south east)$) -- ++(1.5,0) node[coordinate] (B) {} -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] (ramB1) {RAM};
            \draw (B) -- ++(1.5,0) -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] (ramB2) {RAM};
            \node[above] at (ramA1.north) {A1};
            \node[above] at (ramA2.north) {A2};
            \node[below] at (ramB1.south) {B1};
            \node[below] at (ramB2.south) {B2};
        \end{tikzpicture}
    \end{center}
    Есть 4 слота под оперативную память, которые называются A1, A2, B1, B2. То есть мы можем модули памяти соединять не одним каналом, а несколькими (тут --- двумя). И они могут работать параллельно. И тут можно параллельно получать 128 бит за раз, а не 64. Именно поэтому если планок памяти 2, их нужно поставить правильно (в A1 и B1, например). А ещё чтобы модули памяти работали параллельно, модуль памяти хочет, чтобы они были похожи. Если воткнуть параллельно 4 и 8 Гб, то в лучшем случае во второй планке памяти только 4 Гб будут работать параллельно с первой, а вторые 4 --- нет. Именно поэтому планки продаются пачками. Итак, в нарисованном нами случае оптимально можно воткнуть либо 2, либо 4 планки. В каких-нибудь серверных процессорах может быть 3 или 4 канала, куда во-первых можно больше планок воткнуть, а во-вторых, добиться ещё б\'{о}льшей параллельности. К тому же, если процессоров, например, 2, то можно подключить ещё больше памяти (контроллеры памяти находятся в процессоре, а значит 2 процессора --- 2 контроллера). Так в серверах и делают.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu1) {CPU};
            \draw ($(cpu1.north east)!.33!(cpu1.south east)$) -- ++(1.5,0) node[coordinate] (A) {} -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] {RAM};
            \draw (A) -- ++(1.5,0) -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] {RAM};
            \draw ($(cpu1.north east)!.66!(cpu1.south east)$) -- ++(1.5,0) node[coordinate] (B) {} -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] {RAM};
            \draw (B) -- ++(1.5,0) -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] {RAM};
            \draw (cpu1.south) -- ++(0,-1.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=north] (cpu2) {CPU};
            \draw (cpu2.east) -- ++(1.5,0) node[coordinate] (C) {} -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] {RAM};
            \draw (C) -- ++(1.5,0) -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=north] {RAM};
        \end{tikzpicture}
    \end{center}
    Теперь вернёмся ещё чуть назад, к строению ячейки памяти. Классическая статическая ячейка --- это так называемая однопортовая ячейка. А есть ещё двух- и более- портовые. Как это выглядит?
    \begin{center}
        \begin{tikzpicture}[circuit logic IEC]
            \node[nmos,rotate=-90] (T1) {};
            \draw (T1.drain) to[short,*-] ++(.25,0) node[not gate,anchor=input,scale=.5] (Not1) {};
            \draw (Not1.output) to[short,-*] ++(.25,0) node[nmos,rotate=-90,anchor=source] (T2) {};
            \node[not gate,scale=.5] at ($(Not1)-(0,1)$) (Not2) {};
            \draw (Not2.output) -- (T2.source |- Not2.output) -- ++(0,.25) -- ($(T1.drain)-(0,.25)$) -- (T1.drain);
            \draw (Not2.input) -- (T1.drain |- Not2.input) -- ++(0,.25) -- ($(T2.source)-(0,.25)$) -- (T2.source);
            \draw (T1.source) to[short,*-] ++(0,1.5) node[coordinate] (Col) {} node[above left] {$Col_1$};
            \draw (T1.source) -- ++(0,-2.5) node[coordinate] (Col') {};
            \draw (T2.drain) to[short,*-] ++(0,1.5) node[above right] {$\overline{Col_1}$};
            \draw (T2.drain) -- ++(0,-2.5);
            \draw (T1.gate) -- (T2.gate);
            \draw (T1.gate) to[short,*-] ++(-1.25,0) node[coordinate] (Row) {} node[left] {$Row_1$};
            \draw (T2.gate) to[short,*-] ++(1.25,0) node[coordinate] (Row') {};
            
            \ctikzset{tripoles/nmos/height=.375}
            \ctikzset{tripoles/nmos/gate height=1.02667}
            \ctikzset{tripoles/nmos/base height=1.46667}
            \draw ($(T2.source)+(.25,0)$) to[short,*-] ++(0,-1) node[nmos,anchor=drain,rotate=90] (T4) {};
            \draw (T4.source) -- ++(.5,0) node[coordinate] (tmp) {} to[short,*-] (\currentnode |- Col);
            \draw (tmp) to[short,*-] (tmp |- Col') node[below left] {$\overline{Col_2}$};
            \draw ($(T1.drain)-(.25,0)$) to[short,*-] ++(0,-1) node[nmos,anchor=source,rotate=90] (T3) {};
            \draw (T3.drain) -- ++(-.5,0) node[coordinate] (tmp) {} to[short,*-] (\currentnode |- Col);
            \draw (tmp) to[short,*-] (tmp |- Col') node[below right] {$Col_2$};
            \draw (T3.gate) to[short,*-] (T3.gate -| Row) node[left] {$Row_2$};
            \draw (T4.gate) to[short,*-] (T4.gate -| Row');
            \draw (T3.gate) -- (T4.gate);
        \end{tikzpicture}
    \end{center}
    То есть дополнительно появляются 2 интерфейсных транзистора, дающих дополнительный канал подключения. А внутренний бит как был только один, так и остался, но у нас теперь есть 2 способа подключиться. Зачем? Точно не затем, чтобы одну ячейку читать и записывать, это гонка данных. А затем, чтобы работать с двумя разными строчками параллельно в одно и то же время. Это кажется приятным, потому что не нужно ждать открытия и закрытия строк, можно увеличить скорость ответа на несколько запросов. Но на самом деле это используется редко. Если в статической памяти изменение с 6 транзисторов до 8 выглядит не очень сильным изменением, то в динамической памяти количество элементов (не только транзисторов, но и проводов) удваивается, что удваивает стоимость, да ещё и упаковывать память плотно сложнее. Поэтому многопортовую память можно встретить редко. Ведь того же эффекта можно достичь проще. В SDRAM мы упоминали многобанковую память. Это кто? Это несколько матриц внутри модуля памяти.
    \begin{center}
        \begin{tikzpicture}
            \draw[step=.5,black,shift={(.625,.625)}] (0,0) grid (2.5,2.5);
            \draw[step=.5,draw=black,fill=white] (0,0) grid (2.5,2.5) rectangle (0,0);
            \draw (1.25,2.5) -- ++(0,.625) -- ++(0,0.5) node[tground,rotate=45] {} -- ++(0,0.5);
            \draw ($(1.25,2.5)+(.625,.625)$) -- ++(0,0.5) node[tground,rotate=45] {} -- ++(0,0.5);
            \draw (0,3.5+.625) rectangle (2.5+.625,4.625);
        \end{tikzpicture}
    \end{center}
    И каждая матрица подключена своим каналом к интерфейсу памяти. И если обращение идёт в разные матрицы, то их можно обрабатывать параллельно. Это, понятно, потенциально менее эффективно, но тут нет никакого усложнения ячеек. К тому же, можно взять 8 банков и получить довольно высокую вероятность того, что две (не 8) строк будут обрабатываться параллельно. Ещё можно встретить термин <<многоранговая память>>. Это кто? Это когда внутри одного модуля памяти электрически существует как бы два модуля.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw (cpu.east) -- ++(1.5,0) node[coordinate] (A) {} -- ++(0,.5) node[inner sep=0pt,draw,minimum width=2cm,minimum height=1cm,anchor=south] (R) {};
            \draw (A) -- ++(2,0) -- ++(0,.5) node[inner sep=0pt,draw,minimum width=1cm,minimum height=.5cm,anchor=south] {RAM};
            \draw (R.south) -- ++(0,.25) -- ++(.5,0) -- ++(0,.25) node[inner sep=0pt,draw,minimum width=.5cm,minimum height=.25cm,anchor=south] {\tiny RAM};
            \draw (R.south) -- ++(0,.25) -- ++(-.5,0) -- ++(0,.25) node[inner sep=0pt,draw,minimum width=.5cm,minimum height=.25cm,anchor=south] {\tiny RAM};
        \end{tikzpicture}
    \end{center}
    Насколько это хорошо? Ну, там можно держать открытыми разные строчки. Но чем больше там модулей, тем сложнее обрабатывать эту конструкцию. Многоранговая память может даже снизить скорость, если этой памяти много.\\
    Давайте поговорим о многопроцессорных системах. Между процессорами есть какой-то высокоскоростной канал связи. И любой процессор может обратиться к любой памяти, но к своей ему будет быстрее.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu0) {CPU0};
            \draw (cpu0.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
            \draw (cpu0.south) -- ++(0,-.75) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=north] (cpu1) {CPU1};
            \draw (cpu1.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
        \end{tikzpicture}
    \end{center}
    И это именно тем и хорошо, что, поставив рядом два компа, невозможно передать память одного другому (ну, понятно, через сеть возможно, но это не то). И два процессора могут обращаться друг к другу. Но тут у нас будет NUMA --- non-uniform memory access. У нас есть отдельно область памяти с быстрым доступом (та, которая напрямую к процессору подключена) и отдельно --- с чуть более медленным (то, которая у другого процессора). NUMA, кстати, разной может быть. Классический пример --- неполносвязная система из 4 процессоров.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu0) {CPU0};
            \draw (cpu0.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
            \draw (cpu0.south) -- ++(0,-.75) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=north] (cpu1) {CPU1};
            \draw (cpu1.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
            \draw (cpu1.west) -- ++(-.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=east] (cpu2) {CPU2};
            \draw (cpu2.west) -- ++(-.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=east] {RAM};
            \draw (cpu0.west) -- ++(-.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=east] (cpu3) {CPU3};
            \draw (cpu3.west) -- ++(-.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=east] {RAM};
            \draw (cpu3.south) -- (cpu2.north);
        \end{tikzpicture}
    \end{center}
    Тут процессор 0 очень быстро обращается к <<своей>> памяти, помедленнее --- к памяти процессоров 1 и 3 и капец медленно --- к памяти процессора 2. Код, который не думает о строении многопроцессорной системы, может в такой системе даже замедлиться по сравнению с однопроцессорной, ведь ускорение от нескольких процессоров не настолько большое, чем замедление, которое даёт обращение в далёкие участки памяти. Поэтому надо думать о том, чтобы в потоках память выделялась <<поближе>>. В AMD Threadripper 1 поколения, кстати, была похожая штука на ядрах. Но начиная с Ryzen AMD начали строить процессоры из нескольких кристаллов, а не из одного. Это дешевле, потому что процент выхода хороших кристаллов в одном большом кристалле намного ниже, чем в многих маленьких. Так что современные системы могут быть весьма сложно утроены. И вот последующие Threadripper'ы и Ryzen'ы устроены не так, как было нарисовано, а по-другому:
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1.5cm,minimum height=2cm] (i) {};
            \draw ($(i.east)!.5!(i.north east)$) -- ++(.5,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] {Core0};
            \draw ($(i.east)!.5!(i.south east)$) -- ++(.5,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] {Core1};
            \draw ($(i.west)!.5!(i.south west)$) -- ++(-.5,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=east] {Core2};
            \draw ($(i.west)!.5!(i.north west)$) -- ++(-.5,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=east] {Core3};
            \draw (i.south) -- ++(0,-.5) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=north] {MEM};
        \end{tikzpicture}
    \end{center}
    То есть вычислительные кристаллы подключаются к интерфейсному, и к нему же подключается память. И там uniform-memory access, обращение к памяти всегда одно и то же. И всякие тупые программы (игры, например) будут работать там не хуже, чем на классическом монолитном дизайне. Именно поэтому при переходе на Zen 3 наблюдается видимый рост скорости.
    \paragraph{\undercolorblack{orange}{Кэш-память}.}
    Кэш-память ответственна за то, что вы можете купить себе лучшую оперативку и не почувствовать разницу. Как мы уже упоминали, скорость процессоров растёт намного быстрее, чем скорость памяти. Особенно это верно про скорость доступа. И нет простого решения увеличить скорость доступа оперативной памяти, просто заставив её работать быстрее. Кэш-память --- это способ сделать скорость доступа не так заметно ухудшающей производительность. А ухудшает она очень сильно. Например, сложить 2 числа --- это 2 чтения (100 тактов\texttimes2) и одно сложение (1 такт). Этот 1 такт растворяется в 200. Кэш-память хранит какой-то фрагмент оперативки, причём хранит очень близко к процессору и работает очень быстро сама по себе. Она может быть устроена так (архитектура look aside):
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw (cpu.east) -- ++(.75,0) node[coordinate] (tmp) {} -- ++(0,-.75) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=north] {Cache};
            \draw (tmp) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=.75cm,minimum height=1.5cm,anchor=west] (ctr) {\rotatebox{75}{$\mathrm{mem\ ctr}$}};
            
            \draw (ctr.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
        \end{tikzpicture}
    \end{center}
    Когда берётся кусок оперативной памяти, кэш сохраняет себе копию и при повторном обращении возвращает её вместо долгого обращения в оперативную память. Но есть другая (look through), эффективная в основном на чтение:
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw (cpu.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=.75cm,minimum height=1.25cm,anchor=west] (cache) {\rotatebox{90}{Cache}};
            \draw (cache.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=.75cm,minimum height=1.5cm,anchor=west] (ctr) {\rotatebox{75}{$\mathrm{mem\ ctr}$}};
            \draw (ctr.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
        \end{tikzpicture}
    \end{center}
    Тут не посылается сигнал одновременно в кэш-память и оперативную память, а значит, если в кэше что-то нашлось, не надо прерывать работу оперативной памяти. Вообще, если мы редко попадаем в кэш, look aside работает быстрее, потому что контроллер памяти сразу видит команду и сразу начинает обращение к памяти. Но в look through, если почти на все запросы отвечает кэш, можно сделать канал до кэша очень быстрым, а до памяти --- как получится. И тогда, если у нас на большинство запросов отвечает кэш, то всё хорошо. Look aside имеет одинаковые каналы на памяти и на кэше, да и кэш можно взять и выключить, если где-то возникают ошибки. Но look through быстрее, если у вас мало промахов по кэшу. Разумеется, кэш выгоден не всегда, а только если алгоритм обладает \textit{свойством пространственной локальности}. Это когда мы в соседние моменты времени обращаемся в одно и то же место. Например, если мы что-то считаем в массиве (например, сумму, произведение, что-то ещё или всё это одновременно), то мы часто обращается к локальным переменным, которые и можно запихнуть в кэш. А если мы считаем что-то на деревьях, то у вас всегда, кроме обращения к корню, происходят промахи, поэтому кэш вам чуть ли не мешает. Но в среднем процент промахов --- процентов 10, а то и меньше. Но это --- работа с кэшем в режиме чтения, а что с записью? Тут тоже есть 2 подхода: write through (все команды на запись чего-то в кэш также идут в оперативную память)
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw[->] (cpu.east) -- ++(.75,0) node[coordinate] (tmp) {} -- ++(0,-1) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] {RAM};
            \draw[->] (tmp) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] {Cache};
        \end{tikzpicture}
    \end{center}
    ...и write back (когда мы пишем что-то в кэш, он когда-нибудь потом переносит данные в оперативную память):
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1cm,minimum height=1cm] (cpu) {CPU};
            \draw (cpu.east) -- ++(.75,0) node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] (cache) {Cache};
            \draw[dashed,->] (cache.east) -- ++(.75,0) node[coordinate] (ram) {};
            \node at (ram) [inner sep=0pt,draw,minimum width=1cm,minimum height=1cm,anchor=west] {RAM};
        \end{tikzpicture}
    \end{center}
    Кто из них лучше? Опять зависит от того, по какому критерию сравниваем. Первый подход проще и дешевле. Все данные памяти скопированы в кэш. Мы можем любой участок кэша выкинуть, и всё будет хорошо. Система проще устроена. Во втором подходе нужно думать, копия оперативки лежит в кэше или что-то новое. И пере тем, как выкинуть что-то из кэша, нужно думать. А думать --- это медленно. Когда кто-то вычисляющий постоянно пишет в память, то все запросы встают в очередь, и эта очередь замедляет работу памяти, которая медленно обрабатывает все эти запросы. И если команд записи очень много, то очередь может забиться и придётся ждать её освобождения. Поэтому современные высокопроизводительные кэши --- это write back. Теперь давайте рассмотрим, как именно копирует кэш. Если бы он копировал всё побайтово, то рядом с каждым участком памяти хранился бы адрес. И рядом с полезными 8 битами хранится 32- (а то и больше) битный адрес. И только 1/5 кэша полезная. Это треш. И вот на самом деле кэш хранит по большим кускам памяти. Эти куски --- кэш линии. Их типичный размер --- 64 байта (на x86, например, именно так). И копировать меньше кэш не умеет. Что происходит, если у нас происходит перекрытие кэш линий? Происходит трэш. Чтобы такого не происходило, мы говорим, что адрес начала кэш-линии кратен 64. Дополнительный бонус этого в том, что адрес начала может не содержать младшие биты, так как там нули. И служебной информации у нас на 6 бит меньше. Как вообще выглядит кэш-подсистема в современных процессорах. Пусть у нас есть 4 ядра процессора.
    \begin{center}
        \begin{tikzpicture}
            \node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm] at (0,0) (core) {Core0};
            \node[inner sep=0pt,draw,minimum width=.625cm,minimum height=.75cm,anchor=west] at ($(core.west)-(0,1.5)$) (L1I) {\footnotesize L1I};
            \node[inner sep=0pt,draw,minimum width=.625cm,minimum height=.75cm,anchor=east] at ($(core.east)-(0,1.5)$) (L1D) {\footnotesize L1D};
            \draw[->] (L1I) -- (L1I |- core.south);
            \draw[<->] (L1D) -- (L1D |- core.south);
            \node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] at ($(L1I.west)-(0,1.5)$) (L2) {L2};
            \draw[<->] (L2) -- (L2 |- L1D.south);
            \node[inner sep=0pt,draw,minimum width=6.5cm,minimum height=.75cm,anchor=west] at ($(L2.west)-(0,1.5)$) (L3) {L3};
            \draw[<->] (L2) -- (L2 |- L3.north);
            \foreach\i in {1,...,3}
            {
                \node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm] at (\i*1.75,0) (core) {Core\i};
                \node[inner sep=0pt,draw,minimum width=.625cm,minimum height=.75cm,anchor=west] at ($(core.west)-(0,1.5)$) (L1I) {};
                \node[inner sep=0pt,draw,minimum width=.625cm,minimum height=.75cm,anchor=east] at ($(core.east)-(0,1.5)$) (L1D) {};
                \draw (L1I) -- (L1I |- core.south);
                \draw (L1D) -- (L1D |- core.south);
                \node[inner sep=0pt,draw,minimum width=1.25cm,minimum height=.75cm,anchor=west] at ($(L1I.west)-(0,1.5)$) (L2) {};
                \draw (L2) -- (L2 |- L1D.south);
                \draw (L2) -- (L2 |- L3.north);
            }
            \node[inner sep=0pt,draw,minimum width=1.75cm,minimum height=.5cm] at ($(L3)-(0,1.5)$) (ctr) {mem ctr};
            \node at ($(ctr)-(0,1.75)$) (ram) {RAM};
            \draw (L3) -- (ctr) -- ($(ram.north)+(0,.125)!.5!(0,0)$);
            \draw[blue,very thick] ($(ram)!.5!(ctr)+(-4,.25)$) -- ($(ram)!.5!(ctr)+(4,.25)$);
            \draw[decorate, decoration=snake] ($(ram.north west)+(-.5,.125)$) -- ($(ram.north east)+(.5,.125)$);
        \end{tikzpicture}
    \end{center}
    Синее --- это граница кристалла процессора. И у нас есть несколько уровней кэша. Почему? Очень быстрая память --- это очень дорого. Первый уровень кэша --- это очень быстро, но объём памяти маленький. Второй уровень менее быстрый, но побольше. Третий --- ещё медленнее, но ещё больше. Причём первый уровень имеет отдельный фрагмент для команд и отдельный --- для данных. Потом ещё обсудим, почему. В L2 и L3 стандартная фон-Неймановская архитектура, когда и то, и другое хранится вместе. Объём каждого L1 --- порядка 32 кБ. Не важно, оба куска вместе или по отдельности, отличие в 2 раза, а 32 кБ это --- точность до порядка. Для L2 --- 256 кБ, но может быть и 1 МБ. Объём L3 в такой системе --- 8 МБ, но вообще он масштабируется в зависимости от количества ядер. А ещё мы уже упоминали про то, что AMD недавно начали класть кэш сверху на процессоры, что дало им возможность делать L3 размера чуть ли не 128 МБ. Скорость доступа L1 --- 4 такта. Скорость L2 --- 16 тактов. Скорость L3 --- 60 тактов. То есть в L3 она уже не сильно лучше оперативной памяти была бы, если бы у L3 не было профита с многоканальностью и тем, что через него можно обмениваться данными между потоками. Ещё мы поговорим, как решать проблему с тем, если нужные нам данные находятся в соседнем кэше от того, с которым мы сейчас работаем. Кстати, ещё L3 называют LLC (last level cache). В двухядерных системах LLC может быть L2, и там именно L2 общий для двух ядер. В некоторых системах ещё есть L4, но он очень специфический. Но на самом деле в нарисованной ранее схеме есть ложь. На деле у каждого ядра свой L3, а эти самые L3 соединены кольцевой шиной, которая и соединяется с контроллером памяти. При том блок L1---L2---L3 у каждого ядра --- это прямо копипаста одной и той же структуры на кристалле. Кстати, эта кольцевая шина соединяет разные блоки процессора, а не только L3. Например, если есть интегрированная видеокарта, то она подключена к ней же. И кэш L4, если он есть, тоже подключён не по иерархии, а сбоку, на отдельном кристалле, через отдельный контроллер. У него нет своего адресного пространства, он сам в автоматическом режиме что-то копирует. Так нахрен он нужен? Например, если хочется поставить более-менее нормальную интегрированную видеокарту. Обычного DDR просто для неё не хватает. И этот L4 именно для этого и нужен, чтобы кэшировать данные, часто используемые встроенной видеокартой. С точки зрения вычислительных ядер L4 вообще никак ничего не ускоряет. Кстати, ещё есть проблема с тем, что кольцевой шины не хватает, если ядер 16. Тогда делают либо несколько кольцевых шин, либо вообще другую топологию с сеткой.\\
    Итак, мы имеем размер кэш-линии 64 Б, размер L1 --- 32кБ, то есть в L1 есть 512 линий. Как понять, что там где хранится? В каждой линии помимо 64 байта данных есть теги адреса. Чтобы проверить, если в кэше данные, нам нужно посмотреть все 512 линий, не говоря уже о том, чтобы данные как-то читать. И в L2 и L3 всё только хуже. Что-то с этим надо делать. Итак, у нас есть 32 бита адреса. Младшие 6 бит, как мы знаем, можно игнорировать, пока ищем кэш-линию. После этого мы берём следущие 9 бит, как номер кэш-линии. Тут мы получим ассоциативность-1, когда позиция в кэше считается, а не ищется. И нам нужно только сравнить адрес кэш-линии с тем, что мы имеем. А имеем мы прямую адресацию. Плюс этого --- скорость. Минус этого --- мы не можем сохранить в кэше две переменные, у которых эти самые 9 бит адреса совпадают. Поэтому между ассоциативностью-1 (тем, что му уже обсудили) и ассоциативностью-$\infty$ (где мы просто ищем данные в кэше последовательно) берут что-то среднее. Например, ассоциативность-4 --- когда у нас кэш-линии группируются блоками по 4, из адреса берутся 7 бит, а не 9, чтобы искать блок, а из 4 линий блока мы честно ищем нужную (если она есть). Тогда мы всегда можем сохранить в кэше 4 переменные, как бы плохо они не были расположены. Какие реальные ассоциативности используются? Например, в L1 и L2 --- 8, а L3 -- 16. Ассоциативность, кстати, не обязана увеличиваться, возможна ситуация 8/4/16. В L3 ассоциативность может быть вообще не степенью двойки, если у нас размер L3 --- не степень двойки.
    \subparagraph{\undercolorblack{orange}{Когерентность}.}
    В связи с кэшем могут быть проблемы. Представим систему с двумя вычислителями (два ядра или ядро и видеокарта, имеющая доступ к оперативной памяти). Уже тут могут быть проблемы. Пусть у нас где-то есть переменная \mintinline{cpp}{a}, изначально равная \mintinline{cpp}{0}. Первый исполнитель делает следующее:
    \begin{minted}{cpp}
        while (a == 0)
            ;
        a = 2
    \end{minted}
    А второй --- такое:
    \begin{minted}{cpp}
        a = 1
        while (a == 1)
            ;
    \end{minted}
    Оба кода могут выполняться бесконечно долго. Если первый исполнитель начал работать чуть раньше, он берёт \mintinline{cpp}{a}, оно \mintinline{cpp}{0}, сохраняется в кэше, читая свою кэшированную копию \mintinline{cpp}{a}. У второго в кэше сохраняется присвоенное значение \mintinline{cpp}{1}, которое потом и читается. И у нас бесконечно долго \mintinline{cpp}{a} одновременно и \mintinline{cpp}{1}, и \mintinline{cpp}{0}. Эта проблема --- проблема когерентности кэшей. То есть данные про одну область памяти во всех кэшах должны быть синхронизированы (или расходятся, но на незначительный промежуток времени). Это проблема решается двумя способами. Программно и аппаратно. Как выглядит программное решение? У кэша есть команды, которые можно вызвать. Одна из них звучит так: <<Я скоро буду работать с \textit{вот этими} данными, можешь их закэшировать, если хочешь.>> Вторая --- так: <<Сбросить данную кэш-линию.>> То есть если там были новые данные, кинуть их в память, иначе просто освободить линию. И программное решение --- обильный полив своего кода второй командой. Эту команду надо ставить после записи и перед чтением общих данных. Чем такое программное решение плохо? Программисты имеют сильно увеличенное количество работы. Помимо к своим проблемам параллельного программирования добавляются ещё проблемы с технической реализацией правильно спроектированного алгоритма. Поэтому вы не хотите этим заниматься, если можно. Чем плохо аппаратное решение? Теперь вы исполняете роль разработчика железа. Теперь проблемы у вас, а вы тоже не хотите этим заниматься. К тому же железка получится сложнее, дороже с более плохим энергопотреблением. На самом деле есть объективный плюс аппаратного решения: программное решение пессимистичное. Надо сбрасывать кэш всегда, когда \textbf{возможно} обращение памяти из другого исполнителя. Даже если второй исполнитель был выкинут с процессора и стоит. Вы не знаете, нужно ли кому-то, стобы вы сбрасывали кэш, или не нужно, вы всегда должны это делать. Аппаратное решение обычно сбрасывает кэши только тогда, когда надо. Поэтому производительнее получается. Именно так надо отвечать разработчикам железа.\\
    Теперь протоколы аппаратной когерентности. То есть то, как система сама может договориться, чтобы во всех кэшах были актуальные данные. Мы рассмотрим группу протоколов, базой которых является MSI. Они называются по набору состояний, в которых может находиться линия. В MSI --- три состояния: <<modified>>, <<shared>> и <<invalid>>. <<invalid>> --- в данном месте данной линии ничего не закэшировано. <<shared>> --- хранится копия оперативной памяти. <<modified>> --- что-то, что мы (из-за write back) не записали ещё в оперативную память. Тогда нарисуем диаграммку.\\
    Что произойдёт, если процессор хочет прочитать данные ({\color{red}PR}), которые мы ещё не кэшировали? Мы переходим из invalid в shared и отправляет по шине запрос на чтение ({\color{darkgreen}BR}). Что, если нас просят записать что-то ({\color{red}PW}), что мы не кэшировали? Ну, мы переходим из invalid в modified. Но тут есть проблема: размер кэш-линии, как мы знаем, 64 байта. А как часто процессору нужно записать в память именно столько? Почти никогда. Это значит, что команды записи почти всегда пишут меньшую область. Поэтому прежде чем записать данные, нужно сначала прочитать эту кэш-линию, после чего в тот её кусок, где вы что-то изменили, записать, что надо. Поэтому {\color{red}PW} тоже должно бы посылать {\color{darkgreen}BR}. Но тут специфично. Ваша линия может быть в нескольких кэшах в состоянии shared, оно поэтому так и называется. А вот находиться в нескольких кэшах в состоянии modified --- нет. Более того, если где-то линия modified, во всех остальных местах она должна быть invalid. Поэтому это {\color{darkgreen}BR} --- это не совсем {\color{darkgreen}BR}, это {\color{darkgreen}BRfO} (Read for Ownership --- прочитай, чтобы завладеть данными). Что будет, если мы читаем из shared? Ничего. Если мы делаем что-то (процессорное) с modified, то у нас ничего не происходит. Что будет, если мы пишем в shared? Мы должны перейти в modified. И послать окружающим, что они должны выкинуть имеющуюся у них копию. Это {\color{darkgreen}BU} --- bus upgrade. Теперь про то, как реагировать на команды других кэшей. Если у нас invalid, нас ничего не колеблет. Если у нас shared, и нам приходит {\color{blue}BR}, нас тоже не волнует. Кроме того, что можно ответить данными, а можно этого не делать. Если мы этого не сделаем, это сделает контроллер памяти. Что происходит в shared, если кто-то делает {\color{blue}BU}? Мы переходим в invalid. В ответ на {\color{blue}BRfO} мы делаем то же самое, но опционально можем ответить данными. Что, если кто-то читает то, что у нас modified? Мы отвечаем данными, записываем данные в оперативную память и переходим в shared (ответ данными и запись их в оперативную память называется {\color{darkgreen}DataW}). Что происходит, когда мы в modified видим {\color{blue}BU}? Ошибка происходит, мы не должны никогда видеть {\color{blue}BU}, потому что у нас никогда не должно быть одновременно modified (у нас) и shared (у того, кто делает {\color{darkgreen}BU}). Что, если мы видим {\color{blue}BRfO}, когда у нас modified? Мы переходим в invalid и записываем данные в оперативную память.
    \begin{center}
        \begin{tikzpicture}[node distance=50mm, state/.style={draw,circle}, req/.style={midway,sloped,above}, rep/.style={midway,sloped,below,darkgreen}]
            \node[state] (I) {I};
            \node[state, below of=I] (M) {M};
            \node[state, left of=M] (S) {S};
            \draw[->] (I) -- node[req,red] {\small PR} node[rep] {\small BR} (S);
            \draw[->] (I) -- node[req,red] {\small PW} node[rep] {\small BRfO} (M);
            \draw[->] (I) to[out=70,in=110,looseness=15] node[req,blue] {\small B*} (I);
            \draw[->] (M) to[out=-35,in=-75,looseness=15] node[req,red] {\small P*} (M);
            \draw[->] (S) to[out=-180,in=-140,looseness=15] node[req,red] {\small PR} (S);
            \draw[->] (S) to[out=110,in=150,looseness=15] node[req,blue] {\small BR} node[rep] {\small (Data)} (S);
            \draw[->] (S) -- node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->] (S) to[out=80,in=-170,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small (Data)} (I);
            \draw[->] (S) to[out=20,in=-110,looseness=1] node[req,blue] {\small BU} (I);
            \draw[->] (M) to[out=-135,in=-45,looseness=.75] node[req,blue] {\small BR} node[rep] {\small DataW} (S);
            \draw[->] (M) to[out=45,in=-45,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small DataW} (I);
        \end{tikzpicture}
    \end{center}
    Это самый простой протокол когерентности, который работает, но на практике имеет узкое место в производительности. Это {\color{red}PW}\textrightarrow{\color{darkgreen}BU}. Большинство данных, которые у вас shared, они shared только в одном кэше, у вас не очень много переменных синхронизации. А когда мы хотим их записать, надо всех об этом оповещать, что почти всегда бесполезно. Однако это забивает шину. Поэтому есть протокол MESI. Тут добавляется состояние <<exclusive>>. Это уникальная копия оперативной памяти. Как мы можем придти в это состояние? Из invalid по {\color{red}PR}, но только если на наш {\color{darkgreen}BR} ответила память. Если же на {\color{darkgreen}BR} отвечает другой кэш, мы переходим в shared, а не exclusive. Тогда в shared по переходу {\color{blue}BR} обязательно, а не желательно отправлять данные. Понятно, что в exclusive по {\color{red}PR} мы делаем ничего, а по {\color{red}PW} мы просто переходим в modified без каких-либо запросов по шине. По {\color{blue}BR} мы их обязательно оправляем и переходим в shared. {\color{blue}BU} к нам придти не может, а по {\color{blue}BRfO} мы делаем то же самое, что и из shared (то есть переходим в invalid и, возможно, {\color{darkgreen}}). Что мы на самом деле не учли? А то, что данную кэш-линию могут выселить из кэша, если не хватает места для другой. Поэтому из любого состояния есть пунктирные переходы в invalid (кроме, понятно, самого invalid). С exclusive и shared мы просто переходим, а при переходе из modified ещё нужно записать данные. Вот теперь это вполне реально используемый протокол. Это протокол имеет другую проблему. Когда кто-то запрашивает данные из shared? Все ответят данными. Одними и теми же.
    \begin{center}
        \begin{tikzpicture}[node distance=50mm, state/.style={draw,circle}, req/.style={midway,sloped,above}, rep/.style={midway,sloped,below,darkgreen}]
            \clip (-8,-8) rectangle (2,2);
            \node[state] (I) {I};
            \node[state, below of=I] (M) {M};
            \node[state, left of=M] (S) {S};
            \node[state, left of=I] (E) {E};
            \draw[->] (I) -- node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Cahce} (S);
            \draw[->] (I) -- node[req,red] {\small PW} node[rep] {\small BRfO} (M);
            \draw[->] (I) to[out=70,in=110,looseness=15] node[req,blue] {\small B*} (I);
            \draw[->] (M) to[out=-35,in=-75,looseness=15] node[req,red] {\small P*} (M);
            \draw[->] (S) to[out=-180,in=-140,looseness=15] node[req,red] {\small PR} (S);
            \draw[->] (S) to[out=110,in=150,looseness=15] node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->] (E) to[out=120,in=80,looseness=15] node[req,red] {\small PR} (E);
            \draw[->] (S) -- node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->] (S) to[out=80,in=-170,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (S) to[out=20,in=-110,looseness=1] node[req,blue] {\small BU} (I);
            \draw[->] (M) to[out=-135,in=-45,looseness=.75] node[req,blue] {\small BR} node[rep] {\small DataW} (S);
            \draw[->] (M) to[out=45,in=-45,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small DataW} (I);
            \draw[->] (I) to[out=135,in=45,looseness=.75] node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Memory} (E);
            \draw[->] (E) -- node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (E) -- node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->] (E) to[out=-160,in=-110,looseness=2.5] node[req,red] {\small PW} (M);
            \draw[->,dashed] (M) to[out=20,in=-20,looseness=1.15] node[rep] {\small DataW} (I);
            \draw[->,dashed] (S) to[out=10,in=-100,looseness=1.25] (I);
            \draw[->,dashed] (E) to[out=-30,in=-150,looseness=.75] (I);
        \end{tikzpicture}
    \end{center}
    Поэтому следующая модификация добавляет состояние forwarded (MESIF). Оно является вариацией на тему shared. Теперь мы оказываемся в нём, а не в shared, если нам на при {\color{red}PR} на {\color{darkgreen}BR} отвечает кэш. Из этого состояния {\color{red}PR} делает ничего, {\color{red}PW} --- переход в modified и отправка {\color{darkgreen}BU}. А вот по {\color{blue}BR} мы переходим в shared и возвращаем данные, а shared эти данные возвращать перестаёт. По {\color{blue}BU} мы делаем то же, что и всегда (все в invalid!), по {\color{blue}BRfO} --- тоже в invalid и возвращаем данные. Состояние forwarded передаётся как эстафетная палочка между разными кэшами. То есть среди shared один кэш назначается forwarded, и только он возвращает данные. Тут в forwarded есть заморочка с тем, что происходит, если его выселяют. Если нас выселяют, то у нас среди shared не остаётся ни одного forwarded, а значит все сидят, молчат и на запросы {\color{blue}BR} не отвечают. А значит если кто-то захочет из invalid прочитать данные, он должен бы перейти в forwarded, а перейдёт в exclusive, что очень плохо. Так что это надо как-то решать. Неизвестно, как. Возможно, если ты shared, спокойно сидишь и пьёшь чай, но около тебя на {\color{blue}BR} отвечает память, то ты как-то это исправляешь. Возможно, при выселении forwarded посылается какая-нибудь хитрая команда, означающая <<возьмите forwarded кто-нибудь>>, но с ней тоже непонятно, как жить, у нас все shared перейдут в forwarded, что будет значить, что у нас опять MESI, а не MESIF.
    \begin{center}
        \begin{tikzpicture}[node distance=50mm, state/.style={draw,circle}, req/.style={midway,sloped,above}, rep/.style={midway,sloped,below,darkgreen}]
            \clip (-8,-8) rectangle (6,2);
            \node[state] (I) {I};
            \node[state, below of=I] (M) {M};
            \node[state, left of=M] (S) {S};
            \node[state, left of=I] (E) {E};
            \node[state, right of=I] (F) {F};
            \draw[->] (I) to[out=30,in=150,looseness=.875] node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Cahce} (F);
            \draw[->] (I) -- node[req,red] {\small PW} node[rep] {\small BRfO} (M);
            \draw[->] (I) to[out=70,in=110,looseness=15] node[req,blue] {\small B*} (I);
            \draw[->] (M) to[out=-35,in=-75,looseness=15] node[req,red] {\small P*} (M);
            \draw[->] (S) to[out=-180,in=-140,looseness=15] node[req,red] {\small PR} (S);
            \draw[->] (S) to[out=110,in=150,looseness=15] node[req,blue] {\small BR} (S);
            \draw[->] (E) to[out=120,in=80,looseness=15] node[req,red] {\small PR} (E);
            \draw[->] (F) to[out=80,in=40,looseness=15] node[req,red] {\small PR} (F);
            \draw[->] (S) -- node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->] (S) to[out=80,in=-170,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (S) to[out=20,in=-110,looseness=1] node[req,blue] {\small BU} (I);
            \draw[->] (M) to[out=-135,in=-45,looseness=.75] node[req,blue] {\small BR} node[rep] {\small DataW} (S);
            \draw[->] (M) to[out=45,in=-45,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small DataW} (I);
            \draw[->] (I) to[out=135,in=45,looseness=.75] node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Memory} (E);
            \draw[->] (E) -- node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (E) -- node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->] (E) to[out=-160,in=-110,looseness=2.5] node[req,red] {\small PW} (M);
            \draw[->] (F) -- node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (F) to[out=-150,in=-30,looseness=.875] node[req,blue] {\small BU} (I);
            \draw[->] (F) to[out=-90,in=0,looseness=1] node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->] (F) to[out=-65,in=-80,looseness=1.25] node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->,dashed] (M) to[out=20,in=-20,looseness=1.15] node[rep] {\small DataW} (I);
            \draw[->,dashed] (S) to[out=10,in=-100,looseness=1.25] (I);
            \draw[->,dashed] (E) to[out=-30,in=-150,looseness=.75] (I);
            \draw[->,dashed] (F) to[out=130,in=50,looseness=1.25] node[rep] {\small ???} (I);
        \end{tikzpicture}
    \end{center}
    Есть другое расширение MESI: MOESI. Тут добавляется owner --- вариация на тему modified. Оно возникает из modified, когда кто-то хочет почитать. При этом в ответ мы отправляем {\color{darkgreen}Data} (не {\color{darkgreen}DataW}). У owner такая же реакция на {\color{red}PR} и {\color{blue}BRfO}, как и у modified, однако ответом на второй, вообще говоря, может служить {\color{darkgreen}Data}, а не {\color{darkgreen}DataW}, если хочется. Кстати, ответом modified на {\color{blue}BRfO} тоже может являться {\color{darkgreen}Data}. В {\color{red}PW} мы переходим обратно в modified по {\color{darkgreen}BU}. А вот пунктирная линия из owner обязана отправлять {\color{darkgreen}DataW}.
    \begin{center}
        \begin{tikzpicture}[node distance=50mm, state/.style={draw,circle}, req/.style={midway,sloped,above}, rep/.style={midway,sloped,below,darkgreen}]
            \clip (-8,-8) rectangle (6.5,2);
            \node[state] (I) {I};
            \node[state, below of=I] (M) {M};
            \node[state, left of=M] (S) {S};
            \node[state, left of=I] (E) {E};
            \node[state, right of=M] (O) {O};
            \draw[->] (I) -- node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Cahce} (S);
            \draw[->] (I) -- node[req,red] {\small PW} node[rep] {\small BRfO} (M);
            \draw[->] (I) to[out=70,in=110,looseness=15] node[req,blue] {\small B*} (I);
            \draw[->] (M) to[out=-20,in=-60,looseness=15] node[req,red] {\small P*} (M);
            \draw[->] (S) to[out=-180,in=-140,looseness=15] node[req,red] {\small PR} (S);
            \draw[->] (S) to[out=110,in=150,looseness=15] node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->] (E) to[out=120,in=80,looseness=15] node[req,red] {\small PR} (E);
            \draw[->] (O) to[out=-15,in=-55,looseness=15] node[req,red] {\small PR} (O);
            \draw[->] (O) to[in=15,out=55,looseness=15] node[req,blue] {\small BR} node[rep] {\small Data} (O);
            \draw[->] (S) -- node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->] (S) to[out=80,in=-170,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (S) to[out=20,in=-110,looseness=1] node[req,blue] {\small BU} (I);
            \draw[->] (M) -- node[req,blue] {\small BR} node[rep] {\small Data} (O);
            \draw[->] (M) to[out=45,in=-45,looseness=.75] node[req,blue] {\small BRfO} node[rep] {\small Data/DataW} (I);
            \draw[->] (O) to[out=135,in=0,looseness=.5] node[req,blue] {\small BRfO} node[rep] {\small Data/DataW} (I);
            \draw[->] (I) to[out=135,in=45,looseness=.75] node[req,red] {\small PR} node[rep] {\small BR\color{violet}\textleftarrow Memory} (E);
            \draw[->] (E) -- node[req,blue] {\small BRfO} node[rep] {\small Data} (I);
            \draw[->] (E) -- node[req,blue] {\small BR} node[rep] {\small Data} (S);
            \draw[->] (E) to[out=-160,in=-110,looseness=2.5] node[req,red] {\small PW} (M);
            \draw[->] (O) to[out=-90,in=-90,looseness=1.5] node[req,red] {\small PW} node[rep] {\small BU} (M);
            \draw[->,dashed] (M) to[out=20,in=-20,looseness=1.15] node[rep] {\small DataW} (I);
            \draw[->,dashed] (S) to[out=10,in=-100,looseness=1.25] (I);
            \draw[->,dashed] (E) to[out=-30,in=-150,looseness=.75] (I);
            \draw[->,dashed] (O) to[out=90,in=45,looseness=.75] node[rep] {\small DataW} (I);
        \end{tikzpicture}
    \end{center}
    Кстати, возможен протокол MOESIF, почему нет. Насколько всё это связано с реальностью? В старых Intel был MESIF, а в старых AMD --- MOESI. Что происходит в новых, неизвестно.\\
    Кроме протоколов, основанных на MSI, есть Dragon, основанный на Firefly. Разница в том, что в MSI при записи данных мы выкидываем всех остальных, а там мы сообщаем всем вокруг то, что пишем. В итоге состояние invalid чуть ли не отсутствует, потому что в его нет переходов. Но это что-то по уровню настолько же плохое, как write through.
    \section{Устройство вычислительной части.}
    Сначала поговорим о принципах фон Неймана. Сейчас они кажутся нам очевидными, но во-первых в тот момент, когда они формулировались, они таковыми не были (многое пытались сделать по-разному), а во-вторых, они очевидны нам именно потому, что они оказали большое влияние на современнее системы.\\
    Эти принципы можно формулировать по-разному, но первый принцип всегда один --- двоичные данные. То есть не надо использовать десятичную систему. А как мы уже упоминали, арифмометры использовали именно её. Этот принцип больше именно не о том, что не надо использовать троичную, а о том, что не нужно десятичную. И почти все принципы о том, что делать не надо, а не только о том, что надо.\\
    Второе --- программное управление. Следует строить универсальную вычислительную систему, которая будет у себя где-то в памяти хранить алгоритмы. В первых компах всё определялось конфигурацией, надо было пересобирать схемы, чтобы посчитать другую формулу. Вот не надо так, специализированное железо --- это не хорошо. Хороший пример (неправильного) аппаратного управления --- скажем, вычисление квадратного корня схемой. А можно сделать схему с универсальными сложением, вычитанием, проверками и прочим, на котором уже писать вычисление корня. Но тут уже менее всё однозначно, чем с двоичной системой. Но аппаратное управление тоже используется в некоторых дополнительных блоках. Например, из-за энергетической эффективности. Блоки декодирования видео можно встретить в телефонах, чтобы не декодировать это на процессоре, потребляя энергию и выжирая аккум за 10 минут. А эти специальные блоки так не делают, поэтому можно без перерыва смотреть видео 2 часа. Но они имеют проблему --- они для конкретного кодека и даже конкретной частоты кадров. Но энергоэффективность перевешивает. С точки зрения процессора это может быть либо внешнее устройство, либо кусок самого процессора, у которого добавляются команды из алгоритма блока. Ладно, хорошо, а чем хорошее программное управление? Возможностью программировать? Неа. Если ты покупаешь роутер, то никто не рассчитывает, что ты сделаешь из него кофеварку. Возможность добавлять фичи --- тоже нет, покупай лучше новое устройство. А вот если у тебя есть баги, то неприятно, их нудно фиксить, особенно если они критические. Причём багов обычно очень много, особенно в наше время. В первых Pentium'ах была ошибка с делением. Intel'овцы решили сделать хороший алгоритм деления (раньше было в столбик, а тут решили покруче). Но этот алгоритм использовал табличку. Которая в схему залилась не полностью, поэтому в её конце были нули вместо правильных поправок. И Intel отзывали эти процессоры, бесплатно меняя их на новые. А если баг, понятно, программный, то можно выпустить обновление прошивки. Проблема в том, чтобы пользователь узнал, захотел и смог бы поставить это обновление. А может там исправили что-то не про вас, или что-то исправили, а другое --- сломали. А современное ПО --- это лучше выпустить на день раньше, чем всё оттестировать. Мораль: не обновляйтесь вечером пятницы. А ещё сейчас производители не позволяют прошить на более младшую версию, потому что там закрываются баги по DRM, а разрешать пользователям откатываться на более уязвимую версию вы не хотите. В PlayStation была дырка в одной из версий прошивки, которую потом пофиксили. Но может быть и более благородная причина: можно придумать более оптимальный путь хранения чего-нибудь, и конвертировать старый формат в новый вам придётся, а обратно --- ну нахер. Вернёмся к плюсам программного управления. Как видно, баги --- это да, но не главное. А главное --- разработка кристаллов намного дольше и очень намного дороже, чем разработка программ. Сам кристалл будет, возможно, и подешевле, а разработка --- нет. То есть если вы продаёте вашу систему каждому китайцу, вы победите по стоимости, а если производство не массовое, в 100 или 1000 устройств, то основной стоимостью будет именно разработка. Как уже было сказано, разработка по лидирующему тех. процессу --- о-о-очень долго и дорого. А если тех. процесс у вас старенький, то намного дешевле, но встаёт вопрос, а не будет ли универсальный процессор с новым тех. процессом эффективнее. Да, если вам нужен блок, который работает в температурах от -100 до 100 градусов три года без подзарядки --- то ответ очевиден, нужных вам универсальных процессоров просто нет. Иначе --- подумайте.\\
    Следующий принцип связан с памятью. Принцип адресности. У нас есть оперативная память, она выглядит как ячейки, каждая из которых имеет фиксированы (т.е. неизменный) уникальный адрес, и есть быстрый доступ ко всей памяти. А как иначе? Можно без адресов. А это как? Как в машине Тьюринга. Там есть только команды <<сдвинуться влево>> или <<сдвинуться вправо>>, и никаких адресов. На машине Тьюринга именно это и неудобно, что там очень неприятная работа с памятью, по неё перемешаться надо. Понять принцип адресности можно очень легко, попытавшись написать A+B problem на этой самой машине. А как если адреса не фиксированы? Стек, в котором адреса --- <<вершина>>, <<вершина+1>>, <<вершина+2>> и так далее. И с этим также сложно работать. И вот этот принцип как раз и определил, как выглядят нынешние программы.\\
    Следующее --- однородность памяти. В одной и той же памяти хранятся и программы, и данные. Обратный вариант --- Гарвардовская архитектура, которая отличается от фон Неймановской только этим принципом. Данные и команды в ней --- это разные адресные пространства (отдельные штуки работают с памятью команд, а другие --- с памятью данных) или просто разные диапазоны. Хорошо, а чем что из этого хорошо? Раздельные команды и данные --- два устройства, вдвое больше проводов и так далее, Гарвардская архитектура сложнее. Но у раздельного хранения есть один очень хороший плюс. В фон Неймановской архитектуре можно заставить интерпретировать данные как команды, если в программе есть дырка. В Гарвардской такое, понятно, невозможно. Но ещё Гарвардская архитектура значительно быстрее. Почему --- пока непонятно, но в следующей теме мы поймём, почему. Причём Гарвардская настолько быстрее, что кэш L1 (как уже было сказано) --- Гарвардский. Так чем же фон Неймановская архитектура хороша, кроме простоты и дешевизны? Например, невозможна ситуация, когда вся память команд кончилась, а в памяти данных ещё до жопы места. В фон Неймановской память у тебя либо есть, либо её нет. Ещё однородная память может динамически генерировать код. Чем это плохо, мы уже говорили. Слышали ли вы что-нибудь о сжатии исполняемых файлов? Если вы запакуете его в какой-нибудь zip, получится очень слабенькое сжатие. Но вы можете как-нибудь хорошо запаковать код своим алгоритмом, а в начале приписать маленький распаковщик, который развернём всё прямо в памяти. Если у вас медленный носитель данных, это будет даже быстрее. Более широко встречающийся пример --- генерация кода в <<не совсем компилируемых>> языках программирования. Кандидат номер один на это --- JavaScript. Если вы хотите, чтобы он не тормозил безбожно, вы хотите его компилировать. И вот JS параллельно интерпретируется и параллельно компилируется в некоторый много более простой байт код, который уже потом компилируется в команды процессора, если всё равно долго. И всё это in-place. Кандидаты номер 2 и 3 на динамическую генерацию кода --- Java и .Net. Потому что их байт-код лучше бы компилировать в native код и быстрее исполнять. И если Java обычно никуда не компилируется, кроме памяти, то .Net уже может сохранять куда-то то, что скомпилировал. Хотя, новые версии Android тоже, скорее всего, куда-то тоже сохраняет скомпилированные штуки.\\
    Последний принцип --- последовательное выполнение: выполнение следующей команды начинается после предыдущей. Ничего не понятно, что в следующем разделе станет лучше.
    \paragraph{\undercolorblack{orange}{Лирическое отступление про устройство компьютеров}.}
    Давно всё выглядело так. Процессор разговаривает с северным мостом, в который втыкаются высокоскоростные устройства. И к нему подключён южный мост с низкоскоростными устройствами. Потом контроллер памяти переехал в процессор, и в сокете 1366 конфигурация была другой.
    % Перерисовать схему с CPU--RAM
    А потом всё стало PCI-E. Высокоскоростные устройства --- PCI-E в процессор, а всё остальное --- в южный мост. Южный мост тоже подключён вариацией на тему PCI-E с процессором. SSD, кстати, можно подключать в разные места. Почему? Intel экономят на PCI-E, 16 на разъём x16 и ещё 4 на SSD под M2. При этом эти PCI-E могут быть разных поколений. Например, в новых Intel PCI-E5 --- это только напрямую из процессора, остальные 4 или даже 3. Интегрируемая видеокарта тут в процессоре.\\
    Кто такой BIOS? Это штука, которая содержит программу запуска, инициализирует ресурсы, базово проверяет, что всё есть и работает и инициализирует внешние устройства.
    \paragraph{\undercolorblack{orange}{Устройство процессора}.}
    С точки зрения того, что делает процессор, очевидно, что он делает что-то в машинном коде. Машинный код --- это мега неудобно, поэтому используют ассемблер. Ассемблер --- это простой перевод байт-кода в что-то более человекочитаемое. Вместо магического числа, отвечающего за сложение чисел, пишут команду ADD. Ассемблера, кстати, как единого языка, не существует. Сколько есть различных наборов команд у процессоров --- столько есть и ассемблеров. Заглянем в прошлое. В 70-х годах IBM производила линейку компьютеров. Почему линейку? А давайте подумаем, кто использовал компы в то время? Во-первых, военные, во-вторых, банки, в-третьих, университеты (зачем? явно нужен народ, который обучен, как компы использовать, к тому же университеты участвовали в разработке этих самых компов). Требования к компьютерам у этих троих разные. Военным хочется отказоустойчивость (если ядерная война, мы можем запустить ответную ракету, то есть нужна устойчивость к радиации; и не только на войне, но и в космосе), банкам хочется просто повыше надёжность (на ошибках можно много денег потерять), а университетам не нужно ни то, не другое. Поэтому в линейке компьютеров всё разное. Теперь подумаем, кто должен вам поставить все базовые программы (компиляторы, ОС, редакторы)? Производитель, иначе комп --- это груда металла. Поэтому когда IBM выпустили новую линейку, они почувствовали, что очень больно поддерживать новое обеспечение под каждый отдельный компьютер (разные системы же, а значит разные команды). Поэтому они изобрели гениальную идею --- ISA --- архитектуру набора команд. Они выпустили новую линейку компов, которые по-прежнему были разные, но обладали одинаковыми командами. А значит программы там были одинаковые. Почему это удобно пользователю, очевидно. Если сломался компьютер, не нужно пытаться купить один-в-один тот же самый комп, каким был сломанный. Или если вы банк, и хотите открыть новый филиал, в котором уже имеющееся ПО работает. А почему это удобно разработчику железа? Вы выпустили новую линейку компов. Приходите в банк и рекламируете свой продукт. Разумеется, купят тот, в котором ничего переписывать не надо. Первая ISA называлась System/360. И настолько это хорошо прижилось, что IBM до сих пор выпускает процессоры, совместимые с System/360. Понятно, что в ISA можно добавлять новые команды, поэтому <<процессоры, совместимые с System/360>> --- это не есть именно System/360, новая система называется System/Z. И её покупают, например, те же банки и военные. Не верите --- посмотрите зарплаты программистов на COBOL. Так вот, x86 --- это тоже ISA. Когда есть программа, написанная под ISA, она будет работать <<баг в баг>> на чём угодно, что реализует этот ISA. До курьёзов доходило. В x86 есть аппаратное вычисление синуса --- FSIN. И в нём есть проблема. Чему равен синус чего-то близкого к 0? Этому числу. А синус какого-то $x$, близкого к $\pi$? $\pi-x$. Но тут есть catastrophic calculation. У нас есть 24 бита точности, которые кодируют что-то близкое к $\pi$. И когда вы вычтете его из $\pi$, у вас очень много старших битов обнуляется, а значит сильно теряется точность. Нужно иметь очень точную константу $\pi$. И у Intel там была константа с большой точностью, но недостаточной, поэтому это вычисление синуса на аргументах около $\pi$ сильно врало. Потом AMD сделали в своём процессоре нормальную константу, а пользователи начали плакать, потому что ответ на выходе не тот. AMD пытались кому-то что-то объяснить, а потом забили и сделали точно ту же константу. То есть ISA --- это повторение <<до тупого>>. Поэтому в новых версиях ISA остаются старые команды, которые никакие компиляторы не используют, но старые программы же могут что-то с ними делать. Ещё примерами ISA являются RISC-V (вообще, это семейство ISA), Power, который когда-то был на Mac, ARM (это тоже семейство ISA)... Причём ISA --- это не только набор команд, но ещё и то, как конкретно работает ADD, например. Это арифметика с насыщением, модулярная, ошибка или что ещё. Деление на ноль как обрабатывать? Какие есть способы общения с внешними устройствами? Всё вот это вот определяется ISA. И совместимость на уровне ISA --- практически стопроцентная. Так прочему же старые игрушки не работают на новых системах? А потому что программа хочет что-то ещё от ОС и внешних устройств. А чтобы запустить старую ОС на новом компе, нужны дрова для вашей новой видеокарты. То есть совместимость процессоров --- всегда очень хорошая, а ошибки возникают из ОС или внешних устройств. В плане совместимости, хорошо себя показывает Linux, в котором все дрова open-source, что позволяет при большом желании переписать дрова туда, куда хочется.\\
    Рассмотрим ISA по <<виду устройства команд>>.
    \subparagraph{\undercolorblack{orange}{Стековая архитектура}.}
    \begin{center}
        \begin{tikzpicture}
            \draw (0,2) -- ++(1,0) -- ++(.5,-1) -- ++(1,0) -- ++(.5,1) -- ++(1,0) -- ++(-1,-2) -- ++(-2,0) -- cycle;
            \node[scale=1.5] at (2,.5) {ALU};
            \foreach\i in {0,...,7}
            {
                \draw (0,\i/2+3) rectangle ++(4,.5);
                \node at (2,3.25+\i/2) {st\i};
            }
            \draw[->] (.5,3) -- ++(0,-1);
            \draw[->] (4,3.75) -- ++(.25,0) -- ++(0,-1.25) -| (3.75,2);
            \draw[->] (2,0) -- ++(0,-.5) -| ++(-2.5,3) -- (0,3);
            
            \draw[step=1cm] (-1,-5) grid (5,-2);
            \node at (-.5,-2.5) {RAM};
            \node[scale=1.25] at (1.5,-2.5) {a};
            \node[scale=1.25] at (4.5,-2.5) {z};
            \node[scale=1.25] at (-.5,-3.5) {d};
            \node[scale=1.25] at (2.5,-3.5) {c};
            \node[scale=1.25] at (.5,-4.5) {b};
            \draw[<->] (-.5,-2) to[in=-180,out=90,distance=2cm] node[midway,sloped,below] {push/pop} (0,3.25);
        \end{tikzpicture}
    \end{center}
    ALU --- арифметическо-логическое устройство, то есть что-то считающее. Оно может оперировать только внутренними ячейками процессора. Тут они --- стек на массиве. В командах арифметики (данной архитектуры) вообще нет операндов, операнды берутся со стека и результат пишется туда же. Обмен данными с памятью происходит через push/pop. У каждой по 1 аргументу, в случае push --- откуда брать значение, в случае pop --- куда его пихать. Если хочется посчитать \mintinline{c}{z = a + b * c}, то всё произойдёт так:
    \begin{enumerate}
        \item push [a]
        \item push [b]
        \item push [c]
        \item MUL
        \item ADD
        \item pop [z]
    \end{enumerate}
    То есть происходит просто польская запись, которая потом выполняется. Единственное, о чём нужно думать --- чтобы размер стека не закончился. А что всё же произойдёт? Часть команд x86 с плавающей точкой, использующих стек, новое значение стирает самое старое, но при этом возникает NaN. Мы так в нашей модели делать не будем. push и pop <<крутят стек>>, то есть push перемещает седьмой элемент на нулевое место, а потом его затирает. А pop --- наоборот.\\
    Ещё стоит сказать, что <<[a]>> --- это не какие-то буквы, это то, что будет в жизни заменено адресом памяти. Почему неудобно писать на машинном коде? Не потому, что нельзя запомнить, какое число соответствует ADD, а какое --- MUL. А проблема именно в этих адресах, если вы создаёте новую строку программы, у вас адреса могут съехать, и вам придётся их исправлять. И главное достоинство ASM --- все эти цифры автоматически пересчитываются, ведь вы можете присвоить адресу памяти имя.\\
    А ещё почему используются квадратные скобки, а не <<push a>>? Потому что квадратные скобки --- обращение к памяти. Ведь вы можете push'ить на стек константы, а не значения адресов.\\
    Что ещё? Как SUB и DIV снимают команды со стека? Как специфицируем, так и будет. Например, первый аргумент лежит на стеке раньше. (Вот то, что мы сейчас специфицируем --- это по сути и есть ISA.)\\
    Мы обычно хотим, чтобы программа работала побыстрее. И у разных команд есть разная стоимость. Напрмиер, так:
    Сложение, вычитание, push константы, pop без аргументов (просто выкидывает значение и никуда его не пишет) и push значения, которое уже есть где-то на стеке (push st0, например), --- 1 такт, умножение --- 4 такта, pop и push с адресом --- 10 тактов, деление --- 20 тактов. В жизни, кстати, 1 и 4 такта --- это близко к реальности, деление, как уже было рассказано, обычно занимает не фиксированное количество тактов (поэтому в старых книгах по оптимизации советуют уменьшать количество делений). А вот с pop и push --- вообще абстрактные оценки, их стоимость которых зависит оттого, в какой кэш мы попадаем и попадаем ли. И там может быть пара тактов, а может быть 200. Поэтому это самое условное значение.\\
    Так что про оптимизацию. Вот как, например, умножить число на вершине стека на 4. Так?
    \begin{enumerate}
        \item push 4
        \item MUL
    \end{enumerate}
    А вот нет, тут 5 тактов, а можно за 4:
    \begin{enumerate}
        \item push st0
        \item ADD
        \item push st0
        \item ADD
    \end{enumerate}
    Кстати. Несложно заметить, что в командах почему-то push и pop пишутся нижним регистром, а ADD, SUB и прочие --- верхним. Так вот это не важно, команды ASM обычно регистронезависимы. В отличие от меток (таких, как [a]).\\
    Пусть вам нужно оптимизировать \mintinline{c}{z=(4*a*b-c)/(8*a*c+3*b*d)}. Вы что-то подумали, сделали так:
    \begin{center}
        \begin{tabular}{|r|l|c|c|c|c|c|c|c|c|}
            \hline
            & & st0 & st1 & st2 & st3 & st4 & st5 & st6 & st7\\
            \hline
            10 & push [b] & b & . & . & . & . & . & . & .\\
            1 & push st0 & b & b & . & . & . & . & . & .\\
            1 & push st0 & b & b & b & . & . & . & . & .\\
            1 & push st0 & b & b & b & b & . & . & . & .\\
            1 & ADD & 2b & b & b & . & . & . & . & b\\
            1 & ADD & 3b & b & . & . & . & . & b & 2b\\
            10 & push [d] & d & 3b & b & . & . & . & . & b\\
            4 & MUL & 3bd & b & . & . & . & . & b & d\\
            1 & push 8 & 8 & 3bd & b & . & . & . & . & b\\
            10 & push [a] & a & 8 & 3bd & b & . & . & . & .\\
            1 & push st0 & a & a & 8 & 3bd & b & . & . & .\\
            1 & pop & a & 8 & 3bd & b & . & . & . & a\\
            4 & MUL & 8a & 3bd & b & . & . & . & a & a\\
            10 & push [c] & c & 8a & 3bd & b & . & . & . & a\\
            4 & MUL & 8ac & 3bd & b & . & . & . & a & c\\
            1 & ADD & x & b & . & . & . & a & c & 8ac\\% let x be 8ac+3bd
            1 & push st6 & c & x & b & . & . & . & a & c\\
            1 & push st6 & a & c & x & b & . & . & . & a\\
            1 & push st3 & b & a & c & x & b & . & . & .\\
            4 & MUL & ab & c & x & b & . & . & . & b\\
            1 & push st0 & ab & ab & c & x & b & . & . & .\\
            1 & ADD & 2ab & c & x & b & . & . & . & ab\\
            1 & push st0 & 2ab & 2ab & c & x & b & . & . & .\\
            1 & ADD & 4ab & c & x & b & . & . & . & 2ab\\
            1 & SUB & y & x & b & . & . & . & 2ab & 4ab\\% let y be 4ab-c
            20 & DIV & y/x & b & . & . & . & 2ab & 4ab & y\\
            10 & pop [z] & b & . & . & . & 2ab & 4ab & y & y/x\\
            \hline
        \end{tabular}\\
        (В этой таблице краткости ради x --- это 8ac+3bd, а y --- это 4ab-c.)
    \end{center}
    И работает это за 103 такта. А потом ваш товарищ говорит вам, что можно же оптимально посчитать 8a как сумму 4a и 4a, посчитав их ранее, и вас нужно всё переписывать. Не надо оптимизировать всё заранее, иначе ваш алгоритм станет неоптимизируемым (асимптотически), а вот такие оптимизации --- это уже последнее пристанище.\\
    Ещё есть pragma и assume. Если вы великий маг, вы можете не переходя в ASM, сражаться с оптимизатором. Например, если у вас есть цикл \mintinline{c}{for}, и вы знаете, что условие в начале цикла точно будет выполнено (а компилятор не знает), то вы можете заставить его так считать при помощи assume. А касательно \mintinline{c}{#pragma} --- если, например, \mintinline{c}{#pragma pack}. дело в том, что не все железки могут, например, обращаться к \mintinline{c}{int}, если его адрес не кратен \mintinline{c}{sizeof(int)}. Поэтому в структурах компилятор пытается всё выравнивать. И если у вас есть
    \begin{minted}{c}
        struct
     {
            short x;
            int y;
        };
    \end{minted}
    То там 2 байта \mintinline{c}{x}, два байта дырки и 4 байта \mintinline{c}{y}. И вот x86 вообще пофиг, по естественным границам обращаться или нет (если нет границы кэш-линии). А если граница кэш-линии есть, то чуть-чуть подольше, но ненамного. А ещё лучше бы не использовать \mintinline{c}{#pragma pack}, если можно, а просто переставлять элементы структуры. Но иногда вы читаете заголовок файла, в котором в конкретном порядке идут данные, вот тогда придётся делать \mintinline{c}{#pragma}.
    \subparagraph{\undercolorblack{orange}{Аккумуляторная архитектура}.}
    У нас есть только одна внутренняя ячейка с которой взаимодействуют командами LD (load) и ST (store), а арифметика работает с этим значением и значением из памяти. \mintinline{c}{z = a + b * c}, работает так:
    \begin{enumerate}
        \item LD [b]
        \item MUL [c]
        \item ADD [a]
        \item ST [z]
    \end{enumerate}
    \subparagraph{\undercolorblack{orange}{Регисторово-регистровая архитектура}.}
    \begin{center}
        \begin{tikzpicture}
            \draw (0,2) -- ++(1,0) -- ++(.5,-1) -- ++(1,0) -- ++(.5,1) -- ++(1,0) -- ++(-1,-2) -- ++(-2,0) -- cycle;
            \node[scale=1.5] at (2,.5) {ALU};
            \foreach\i in {0,...,7}
            {
                \draw (0,\i/2+3) rectangle ++(4,.5);
                \node at (2,3.25+\i/2) {R\i};
            }
            \draw[->] (.5,3) -- ++(0,-1);
            \draw[->] (4,6.75) -- ++(.25,0) -- ++(0,-4.25) -| (3.75,2);
            \draw[->] (2,0) -- ++(0,-.5) -| ++(-2.5,4.75) -- ++(.5,0);
            
            \draw[step=1cm] (-1,-5) grid (5,-2);
            \node at (-.5,-2.5) {RAM};
            \node[scale=1.25] at (1.5,-2.5) {a};
            \node[scale=1.25] at (4.5,-2.5) {z};
            \node[scale=1.25] at (-.5,-3.5) {d};
            \node[scale=1.25] at (2.5,-3.5) {c};
            \node[scale=1.25] at (.5,-4.5) {b};
            \draw[<->] (-.5,-2) to[in=-180,out=90,distance=2cm] node[midway,sloped,below] {ST/LD} (0,4.75);
        \end{tikzpicture}
    \end{center}
    У нас в процессоре есть набор регистров (например, названные R0, R1, ..., R7), с которыми можно совершать арифметические действия и записывать ответ в произвольные регистры вместо конкретного одного. Reg-Reg бывает двух подвидов, 2 и 3. В 3 у нас MUL R1,R1,R2 --- значит R1 = R1 * R2. А в Reg-Reg 2 MUL пишется как MUL R1,R2 и обозначает это R1 *= R2. То есть в 2 аргумент пишется в первый регистр, а в 3 --- куда хочется. \mintinline{c}{z = a + b * c}, пишется, например, так:
    \begin{enumerate}
        \item LD R0,[a]
        \item LD R1,[b]
        \item LD R2,[c]
        \item MUL R1,R1,R2
        \item ADD R0,R0,R1
        \item ST [z],R0
    \end{enumerate}
    Ещё в Reg-Reg есть MOV, который копирует значение второго аргумента в первый. Большая проблема в том, чтобы запихать все переменные в регистры. Промежуточные значения могут быстро всё забить. К тому же регистры могу быть заняты служебной информацией. Поэтому раньше компиляторам было очень туго с распределением переменных по регистрам. Настолько туго, что в стандарте C/C++ было ключевое слово resigter, и что надо было использовать минимум переменных. Но это всё в прошлом, компиляторы совершили скачок, так что теперь лучше не использовать одну переменную везде. Так, для каждого цикла сейчас лучше создавать новую переменную, а не использовать одну на все циклы.
    \subparagraph{\undercolorblack{orange}{Регистрово-памятная архитектура}.}
    \begin{center}
        \begin{tikzpicture}
            \draw (0,2) -- ++(1,0) -- ++(.5,-1) -- ++(1,0) -- ++(.5,1) -- ++(1,0) -- ++(-1,-2) -- ++(-2,0) -- cycle;
            \node[scale=1.5] at (2,.5) {ALU};
            \foreach\i in {0,...,7}
            {
                \draw (0,\i/2+3) rectangle ++(4,.5);
                \node at (2,3.25+\i/2) {R\i};
            }
            \draw[->] (.5,3) -- ++(0,-1);
            \draw[->] (4,6.75) -- ++(.25,0) -- ++(0,-4.25) -| (3.75,2);
            \draw[->] (2,0) -- ++(0,-.5) -| ++(-2.25,4.75) -- ++(.25,0);
            
            \draw[step=1cm] (-1,-5) grid (5,-2);
            \node at (-.5,-2.5) {RAM};
            \node[scale=1.25] at (1.5,-2.5) {a};
            \node[scale=1.25] at (4.5,-2.5) {z};
            \node[scale=1.25] at (-.5,-3.5) {d};
            \node[scale=1.25] at (2.5,-3.5) {c};
            \node[scale=1.25] at (.5,-4.5) {b};
            \draw[<->] (-.5,-2) to[in=-180,out=90,distance=2cm] node[midway,sloped,below] {MOV} (0,4.75);
            
            \draw[dashed] (.5,2.5) -- ++(-1,0) -- (-.5,-2);
            \draw[dashed] (4.25,2.5) -| ++(.25,-4.5);
        \end{tikzpicture}
    \end{center}
    Тут происходит почти то же самое, что и в Reg-Reg, но в арифметике одним из операндов может быть память. И теперь LD и ST не нужны, потому что можно применить MOV к памяти. Тут (особенно в Reg-Mem 2) можно написать такой ужас как MUL [x],R0. И тут нетривиально оценивать сложность, потому что явно то, что было написано, работает дольше, чем MUL R1,R0. Поэтому, например, говорят, что все операции работают за базовую стоимость + 9 за каждое обращение к переменной.
    \subparagraph{\undercolorblack{orange}{Отношение всего это к реальности}.}
    Стек --- это сопроцессор FPU. Аккумулятор --- микроконтроллеры, не больше. Reg-Reg --- ARM, MIPS, RISC-V, Reg-Mem --- x86, System/360. Ещё, кстати, есть Mem-Mem архитектура, она понятно, как работает, но используется редко, потому что зачем.
    \subparagraph{\undercolorblack{orange}{Кодирование команд}.}
    Можно сделать постоянную длину или переменную. Посмотрим на пример переменной:
    Первый бит --- то, кто это (Reg-Reg (0), Reg-Const (1), Reg-Mem (2) или Mem-Reg (3)). Потом --- код операции, где мы тупо перенумеровали наши MOV (0), ADD (1), SUB (2), MUL (3) и DIV (4). Дальше для первых трёх типов идёт DST (куда писать), и там идёт индекс регистра, а для четвёртого --- SRC (откуда читать). Дальше идёт зависимость от конкретного типа. Если это Reg-Reg, то там 3 бита, откуда читать и 5 нулей. Если это Reg-Const, то там 32-битная константа. А в Reg-Mem и Mem-Reg там адрес переменной (тоже 32 бита). То есть у нас команды либо 2 байта (для Reg-Reg), либо 5 (для всего остального). Как кодируется, например, ADD R2,[0x1234]? Тип команды --- Reg-Mem (01), команда --- ADD (001), регистр --- R2 (010). То есть первый байт --- 0x8A. А с 0x1234 есть проблема. Мы пишем его как 0x00,0x00,0x12,0x34 или как 0x34,0x12,0x00,0x00? Возможны оба варианта, первый называют big-endian, второй --- little-endian. x86 --- little, Power раньше были big, теперь возможны оба варианта, ARM --- тоже возможны оба, RISC-V --- тоже оба. Но в последнее время тенденция к LE. Почему? А вы возьмите и кастаните 32-битное число к 16-битному. В LE вы просто берёте тот же адрес и интерпретируете как хотите. А в BE надо ещё съехать на 2 байта. В сетевых технологиях, кстати, обычно BE. Поэтому на x86 придётся заниматься перестановкой адресов. Даже есть специальная функция для этого. Поэтому хорошо, когда формат построен на байтах, а не на значениях. Так, UTF-8 --- это просто набор байтов. А вот в UTF-16 уже один \mintinline{c}{short}, а не два \mintinline{c}{char}'а. Поэтому UTF-16 есть две штуки, UTF-16-LE и UTF-16-BE.
    \subparagraph{\undercolorblack{orange}{CISC/RISC}.}
    С выпуском каждого нового процессора нередко было модно добавлять новые команды. Например, раньше не было аппаратного умножение, а теперь есть. И так было довольно долго, и в какой-то момент народ посмотрел и понял, что всё херня. В чём заключается идея RISC? В том, чтобы убрать с кристалла то, что редко используется. А оставшееся место отводится под то, чтобы часто используемое было быстрее. После этого всё, что не RISC стали называть CISC. Причём для CISC характерна переменная длина команд. Так, x86 имеет от 1 до 15 байт. Потому что взяли и сказали, всё меньше 15, теоретически можно было бы и команду в 1КБ. RISC предлагает фиксированную или почти фиксированную длину. Представителем являются ARM'ы или MIPS. В MIPS --- всегда 4 байта. В ARM есть разные режимы, есть на 2 байта, есть --- на 4. Для RISC характерна простая адресация. В квадратных скобках можно указать в лучшем случае сумма регистра и константы. А в CISC можно взять адрес вида Reg+Reg*i+const, где i --- 1, 2, 4 или 8. Это удобно (напрмиер, итерируясь по двух\mintinline{c}{int}овому массиву), в первый регистр пишем адрес массива, во второй --- итерационную переменную, а в const --- тот из двух \mintinline{c}{int}'ов, который нам нужен. Причём это сложение и умножение бесплатно. Но RISC --- это быстро. Так как же тогда x86 --- CISC, если везде RISC? А дело в том, что внешний набор команд --- CISC, а внутренний --- RISC. И внутри находится декодер. Причём он может и 1-в-1, и 1-в-много и даже иногда много-в-1. Так, проверка значения и переход (внешние команды) конвертируются в одну внутреннюю. Таким образом, RISC и CISC --- это скорее набор идей, а не чётко строго формальное. В связи с чем вполне корректны формулировки вида <<данная ISA --- больше RISC, чем CISC>>.
    \paragraph{\undercolorblack{orange}{Реализация всего этого в компьютере}.}
    Мы сейчас рассматриваем, как именно эти команды выполняются, с какой скоростью это происходит и об особенностях выполнения. Поскольку это не связано с результатом, ISA не говорит, и это называется микроархитектурой. То есть ISA --- как вы программируете, а микроархитектура --- как оно внутри работает.
    \subparagraph{\undercolorblack{orange}{Конвейерная архитектура}.}
    Команда может исполняться от начала и до конца как единое целое (собираем на логических элементах то, что нам хочется и записываем результат, куда надо). Это мы рассматривать не будет, это можно легко найти. Но если так выполнять команду, будут проблемы. Если блок работает как единое целое, будут беды с синхронизацией (конструкция-то большая, она не должна разваливаться по таймингам). Технически это нетривиально. Второе --- большой монструозный блок в каждый момент времени не работает целиком. Пока команда считывается из памяти, всё остальное стоит. Пока команда вычисляется, блок считывания из памяти ничего не делает. И это плохо, что б\'{о}льшая часть железа простаивает. И первая идея --- конвейерная архитектура. Мы рассмотрим её на примере реального конвейера --- MIPS. MIPS --- это не только ISA, но и микроархитектура, как этот ISA выполнять.
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw] (IF) {IF};
            \node[rectangle,draw,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (EX) {EX};
            \node[rectangle,draw,right=of EX] (MEM) {MEM};
            \node[rectangle,draw,right=of MEM] (WB) {WB};
            \node[rectangle,draw,above=of IF] (PC) {PC};
            \node[rectangle,draw] at (PC.center -| ID.center) (Regs) {Regs};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (EX);
            \draw[->] (EX) -- (MEM);
            \draw[->] (MEM) -- (WB);
            \draw[->] (Regs) -- (ID);
            \draw[->] (WB.north) |- (Regs.east);
            \draw[->] (PC) -- (IF) node[midway,coordinate] (tmp) {};
            \draw[->] (tmp) -- ($(\currentnode)!.5!(\currentnode -| Regs)$) node[midway,scale=.85,above] {+4} |- (PC.east);
            \node[rectangle,draw,below=of $(ID.south)!.5!(EX.south)$,scale=2,anchor=north] (RAM) {RAM};
            \draw[->] (RAM.north west) -- (IF.south east);
            \draw[<->] (RAM.north east) -- (MEM.south west);
        \end{tikzpicture}
    \end{center}
    Выполнение команды на MIPS состоит из 5 стадий: IF (instruction fetch), ID (instruction decoding), EX (execution), MEM (memory) и WB (write back).
    IF читает внутренний специальный регистр (его называют program counter, instruction pointer и много как ещё), который хранит адрес следующей исполняющей команды. И процессор оттуда берёт 4 байта команды (а они всегда по 4 на MIPS) и посылает запрос на её выполнение. После этого процессор прибавляет 4 байта к адресу команды (то есть переходит к следующей). ID --- это не только разбор того, что это за команда, какие там константы, но и вычисление операндов команды. Например, если написано ADD R1 R2 R3, то читается R2 и R3. Потом команда отправляется на выполнение, где понятно, что происходит. Дальше происходит обращение к памяти, где тоже всё ясно, а потом результат пишется в регистр.\\
    Какие тут особенности? Каждая команда последовательно проходит все стадии, движется равномерно вперёд и не использует ничего, что было на предыдущей стадии. Это значит, что когда первая команда переходит в ID, вы можете запустить вторую команду на стадию IF. Ещё из особенностей. Не очень приятно, что всё проходит через MEM. Поскольку MIPS --- Reg-Reg, команда ADD никогда не обращается к оперативной памяти. Но она всё равно проходит MEM. То есть мы несущественно, но всё же замедляем арифметику. Но несмотря на это, выполнение группы команд в любом случае быстрее, чем если бы конвейера не было. Ну, например, ADD могла бы выполняться, скажем, 4 такта, а выполняется за 5. Но возьмём 1000 команд. Если выполнять их целиком, будет 4000 тактов. А если конвейерно, 1004 такта. И именно на улучшение скорости выполнения направлен конвейер. И это не страшно, что одиночные команды замедляются, этого вы просто не чувствуете. А вот медленно работающие циклы --- вполне чувствуете. Ещё конвейер даёт нам то, что стадии почти никак не связаны друг с другом, кроме того, что на выходе мы передаём значение, а на входе --- читаем. То есть на самом деле между каждой парой стадий хранится небольшой регистр.
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw] (IF) {IF};
            \node[rectangle,draw,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (EX) {EX};
            \node[rectangle,draw,right=of EX] (MEM) {MEM};
            \node[rectangle,draw,right=of MEM] (WB) {WB};
            \node[rectangle,draw,above=of IF] (PC) {PC};
            \node[rectangle,draw] at (PC.center -| ID.center) (Regs) {Regs};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (EX);
            \draw[->] (EX) -- (MEM);
            \draw[->] (MEM) -- (WB);
            \draw[->] (Regs) -- (ID);
            \draw[->] (WB.north) |- (Regs.east);
            \draw[->] (PC) -- (IF) node[midway,coordinate] (tmp) {};
            \draw[->] (tmp) -- ($(\currentnode)!.5!(\currentnode -| Regs)$) node[midway,scale=.85,above] {+4} |- (PC.east);
            \node[rectangle,draw,below=of $(ID.south)!.5!(EX.south)$,scale=2,anchor=north] (RAM) {RAM};
            \draw[->] (RAM.north west) -- (IF.south east);
            \draw[<->] (RAM.north east) -- (MEM.south west);
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt,very thick,blue] at ($(IF.east)!.5!(ID.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt,very thick,blue] at ($(ID.east)!.5!(EX.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt,very thick,blue] at ($(EX.east)!.5!(MEM.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt,very thick,blue] at ($(MEM.east)!.5!(WB.west)$) {};
        \end{tikzpicture}
    \end{center}
    То есть у нас существенно упрощается синхронизация, мы синхронизируем каждую стадию отдельно. И вот это уменьшение синхронизируемого блока приводит к тому, что мы можем поднять тактовую частоту. И вот они, два преимущества конвейера --- высокая тактовая частота и отсутствие простаивающего железа.\\
    Кстати, поскольку умножение и деление работают долго, на самом деле они вместо EX направляются на специальное своё вычисление и работают параллельно, если могут.\\
    А почему MEM идёт после EX? А потому что MIPS может образаться не только по тому адресу, что записан, скажем, в R2, но и к нему +const, и эта самая константа прибавляется на этапе EX.\\
    Какие у этого есть проблемы? Ну, например, пусть у нас вот такая последовательность команд:
    \begin{enumerate}[1.]
        \item ADD R1,R2,R3
        \item SUB R1,R1,R4
    \end{enumerate}
    Сложение у нас совершенно чиллово движется по конвейеру, а за ним движется вычитание. Проблема в том, что вычитание посчитает не то. На стадии декодирования в вычитании будет ошибка, так как там будут считаться R1 и R4. А в R1 будет старое значение, потому что ADD ещё не успела записать новое. Это называется hazard. И этих hazard'ов есть 3 класса. Мы сейчас встретили data hazard. А ещё есть control и struct hazard. Data hazard делятся на 3 подтипа: RaW, WaW и WaR (read after write, write after write и write after read).
    \begin{center}
        \begin{tikzpicture}
            \node (h) {Hazard};
            \node[below=of h] (c) {Control};
            \node[left=of c] (d) {Data};
            \node[right=of c] (s) {Struct};
            \draw[->] (h) -- (d);
            \draw[->] (h) -- (c);
            \draw[->] (h) -- (s);
            \node[below=of d] (d2) {WaW};
            \node[left=of d2] (d1) {RaW};
            \node[right=of d2] (d3) {WaR};
            \draw[->] (d) -- (d1);
            \draw[->] (d) -- (d2);
            \draw[->] (d) -- (d3);
        \end{tikzpicture}
    \end{center}
    У нас тут, несложно заметить, RaW. Проблема в том, что мы тут нарушаем принцип последовательного выполнения фон Неймана. Согласно этому принципу, вторая команда выполняется, когда первая уже полностью закончила. Как можно эту проблему решать? Самый простой способ --- оставить команду SUB на ID. Поэтому придумали команду, которая делает ничего, и именно её исполняет EX в этот момент (такую команду называют NOP). И это счастье мы выпускаем на конвейер до тех пор, пока ADD не досчитается. То есть состояния конвейера выглядят так:
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            IF & ID & EX & MEM & WB\\
            \hline
            ADD & & & & \\
            SUB & ADD & & & \\
            & SUB & ADD & & \\
            & SUB & NOP & ADD & \\
            & SUB & NOP & NOP & ADD\\
            & SUB & NOP & NOP & NOP\\
            & & SUB & NOP & NOP\\
            \hline
        \end{tabular}
    \end{center}
    Но всё не так плохо: WB пишет всё в регистры в первой половине такта, а ID читает во второй. Поэтому проще:
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            IF & ID & EX & MEM & WB\\
            \hline
            ADD & & & & \\
            SUB & ADD & & & \\
            & SUB & ADD & & \\
            & SUB & NOP & ADD & \\
            & SUB & NOP & NOP & ADD\\
            & & SUB & NOP & NOP\\
            \hline
        \end{tabular}
    \end{center}
    Ещё нужно решить проблему не только вперёд, но и назад, потому что нужно уведомить IF, что новые команды читать не надо. А точнее, ID блокирует увеличение указателя команд на 4, и IF читает ту же самую следующую команду.
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw] (IF) {IF};
            \node[rectangle,draw,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (EX) {EX};
            \node[rectangle,draw,right=of EX] (MEM) {MEM};
            \node[rectangle,draw,right=of MEM] (WB) {WB};
            \node[rectangle,draw,above=of IF] (PC) {PC};
            \node[rectangle,draw] at (PC.center -| ID.center) (Regs) {Regs};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (EX);
            \draw[->] (EX) -- (MEM);
            \draw[->] (MEM) -- (WB);
            \draw[->] (Regs) -- (ID);
            \draw[->] (WB.north) |- (Regs.east);
            \draw[->] (PC) -- (IF) node[midway,coordinate] (tmp) {};
            \draw[->] (tmp) -- ($(\currentnode)!.5!(\currentnode -| Regs)$) node[coordinate] (tmp) {} node[midway,scale=.85,above] {+4} |- (PC.east);
            \draw[->,very thick,blue] ($(ID.north west)!.4!(ID.north)$) |- ($(tmp)!.25!(tmp |- PC.east)$);
            \node[rectangle,draw,below=of $(ID.south)!.5!(EX.south)$,scale=2,anchor=north] (RAM) {RAM};
            \draw[->] (RAM.north west) -- (IF.south east);
            \draw[<->] (RAM.north east) -- (MEM.south west);
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] at ($(IF.east)!.5!(ID.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] at ($(ID.east)!.5!(EX.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (E-M) at ($(EX.east)!.5!(MEM.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (M-W) at ($(MEM.east)!.5!(WB.west)$) {};
        \end{tikzpicture}
    \end{center}
    На 2 такта мы стали работать медленнее. Особенно печально, что полезного мы ничего не сделали, а энергия потрачена. Поэтому чем больше таких дырок, тем ниже энергоэффективность. Поэтому есть способы лучше. Насколько наша проблема логическая? Она скорее техническая, потому что результат сложения уже есть (ADD уже прошла стадию EX), когда вычитание могло бы выполнится. Но результат находится не там, он находится в промежуточном регистре между EX и MEM, а его ждут в R1. Так сделаем так (цепь forwarding'а):
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw] (IF) {IF};
            \node[rectangle,draw,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (EX) {EX};
            \node[rectangle,draw,right=of EX] (MEM) {MEM};
            \node[rectangle,draw,right=of MEM] (WB) {WB};
            \node[rectangle,draw,above=of IF] (PC) {PC};
            \node[rectangle,draw] at (PC.center -| ID.center) (Regs) {Regs};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (EX);
            \draw[->] (EX) -- (MEM);
            \draw[->] (MEM) -- (WB);
            \draw[->] (Regs) -- (ID);
            \draw[->] (WB.north) |- (Regs.east);
            \draw[->] (PC) -- (IF) node[midway,coordinate] (tmp) {};
            \draw[->] (tmp) -- ($(\currentnode)!.5!(\currentnode -| Regs)$) node[coordinate] (tmp) {} node[midway,scale=.85,above] {+4} |- (PC.east);
            \draw[->] ($(ID.north west)!.4!(ID.north)$) |- ($(tmp)!.25!(tmp |- PC.east)$);
            \node[rectangle,draw,below=of $(ID.south)!.5!(EX.south)$,scale=2,anchor=north] (RAM) {RAM};
            \draw[->] (RAM.north west) -- (IF.south east);
            \draw[<->] (RAM.north east) -- (MEM.south west);
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] at ($(IF.east)!.5!(ID.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (I-E) at ($(ID.east)!.5!(EX.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (E-M) at ($(EX.east)!.5!(MEM.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (M-W) at ($(MEM.east)!.5!(WB.west)$) {};
            \draw[->,very thick,blue] (E-M) -- ($(\currentnode)!.33!(\currentnode |- RAM.north)$) -- (\currentnode -| {$(EX.west)!.33!(I-E.east)$}) |- ($(EX.west)!.75!(EX.south west)$);
        \end{tikzpicture}
    \end{center}
    И тут декодирование понимает, что R1 она прочесть не может, поэтому в EX отправляется второй аргумент, а первый нужно взять с цепи. Это полностью позволяет нам выкинуть NOP. Но что есть между ADD и SUB что-то есть. Тогда результат сложения будет уже не в EX--MEM, а в MEM--WB. Но тут всё тупо, добавляем вторую цепь:
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw] (IF) {IF};
            \node[rectangle,draw,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (EX) {EX};
            \node[rectangle,draw,right=of EX] (MEM) {MEM};
            \node[rectangle,draw,right=of MEM] (WB) {WB};
            \node[rectangle,draw,above=of IF] (PC) {PC};
            \node[rectangle,draw] at (PC.center -| ID.center) (Regs) {Regs};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (EX);
            \draw[->] (EX) -- (MEM);
            \draw[->] (MEM) -- (WB);
            \draw[->] (Regs) -- (ID);
            \draw[->] (WB.north) |- (Regs.east);
            \draw[->] (PC) -- (IF) node[midway,coordinate] (tmp) {};
            \draw[->] (tmp) -- ($(\currentnode)!.5!(\currentnode -| Regs)$) node[coordinate] (tmp) {} node[midway,scale=.85,above] {+4} |- (PC.east);
            \draw[->] ($(ID.north west)!.4!(ID.north)$) |- ($(tmp)!.25!(tmp |- PC.east)$);
            \node[rectangle,draw,below=of $(ID.south)!.5!(EX.south)$,scale=2,anchor=north] (RAM) {RAM};
            \draw[->] (RAM.north west) -- (IF.south east);
            \draw[<->] (RAM.north east) -- (MEM.south west);
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] at ($(IF.east)!.5!(ID.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (I-E) at ($(ID.east)!.5!(EX.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (E-M) at ($(EX.east)!.5!(MEM.west)$) {};
            \node[draw,minimum height=14pt,minimum width=4pt,dashed,inner sep=0pt] (M-W) at ($(MEM.east)!.5!(WB.west)$) {};
            \draw[->] (E-M) -- ($(\currentnode)!.33!(\currentnode |- RAM.north)$) -- (\currentnode -| {$(EX.west)!.33!(I-E.east)$}) |- ($(EX.west)!.75!(EX.south west)$);
            \draw[->,very thick,blue] (M-W) -- ($(\currentnode)!.5!(\currentnode |- RAM.north)$) -- (\currentnode -| {$(EX.west)!.5!(I-E.east)$}) |- ($(EX.west)!.375!(EX.south west)$);
        \end{tikzpicture}
    \end{center}
    Где мы храним то, надо ли нам читать с цепей и с какой из? Ну, в ID и храним, в какие регистры мы должны будем записать.\\
    Но тут есть проблема:
    \begin{enumerate}[1.]
        \item LD R1,[...]
        \item SUB R1,R1,R4
    \end{enumerate}
    Тут мы на этапе EX не будем знать R1, только на этапе MEM. Кажется, что придётся пихать NOP. Но на самом деле есть ещё третий вариант: документация. Вы официально объявляете, что LD записывает своё значение \textbf{через один такт} после её написания. Ведь на самом деле почти всегда у вас есть команда, которую можно выполнить между LD и SUB, которую вы и можете сделать вместо NOP. А если совсем нечего, ну, то вставьте этот NOP руками, и ничего не изменится.\\
    Давайте вспомним Гарвардскую архитектуру и то, почему она быстрее. Нам хочется иметь два канала до памяти (для 1 и 4 стадии), потому что у нас может случится два запроса в память за 1 такт. Как это будет работать, если у нас только 1 канал? Кому-то придётся подождать. А именно победит MEM, а ждёт IF. В IF возникает мусор, и это struct hazard (не хватает железа). Самый простой способ его решить --- добавить железа (собственно, второй канал, как у нас и нарисовано). Другой --- ID помнит, что к нему приходило обращение к памяти, в котором был мусор, а значит декодирование превращается в NOP, а +4 не прибавляется. Понятно, что документацией это не решается.\\
    Остался control hazard. Это кто? У нас возникает команда перехода (JMP в x86, и мы так её и будем называть, хотя в MIPS она называется по другому, и вообще там есть несколько команд переходов, мы сейчас не об этом). Это \mintinline{c}{goto}. Ещё есть, кстати, условный переход (\mintinline{c}{goto} если что-то). Так, вот:
    \begin{enumerate}[1.]
        \item AND ...
        \item JMP L1
        \item SUB ...
        \item XOR ...
        \item ...
        \item L1: ADD ...
    \end{enumerate}
    Так вот, когда JMP переходит на ID, конвейер просто продолжает читать дальше (SUB, XOR и так далее), пока JMP не выполнится в EX.
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            IF & ID & EX & MEM & WB\\
            \hline
            JMP &  &  &  & \\
            SUB & JMP &  &  & \\
            XOR & SUB & JMP &  & \\
            ADD & XOR & SUB & JMP & \\
            \hline
        \end{tabular}
    \end{center}
    На конвейер зашли две лишние команды. Чтобы это чуть-чуть пофиксить, мы выполняем переходы в ID вместо EX. У нас они всё равно только пишут в program counter, так фиг ли не делать это в ID, который тоже этим славен. Это решение оставляет нам только одну левую команду, с которой мы уже ничего не сделаем. Только превращаем её в NOP (без приостановки конвейера). С одной стороны, работает. С другой стороны, печально. Потому что команда перехода --- это, обычно, цикл. И если тело цикла маленькое, б\'{о}льшую часть времени мы будем делать ничего. Как это решить? Конечно же, документацией! То есть JMP выполняется через одну команду после. То есть предлагается заменить первый вариант на второй
    \begin{multicols}{2}
        \begin{enumerate}[1.]
            \item \textbf{AND ...}
            \item \textbf{JMP L1}
            \item SUB ...
            \item XOR ...
            \item ...
            \item L1: ADD ...
        \end{enumerate}
        \columnbreak
        \begin{enumerate}[1.]
            \item \textbf{JMP L1}
            \item \textbf{AND ...}
            \item SUB ...
            \item XOR ...
            \item ...
            \item L1: ADD ...
        \end{enumerate}
    \end{multicols}
    Это самая команда после JMP называется delay slot. А если у нас нечего выполнять до JMP (например, если мы там вычисляем этот самый адрес перехода), то только тогда NOP.\\
    То, что мы рассмотрели (MIPS) --- типичная CISC архитектура. MIPS, кстати, довольно жива (в роутерах она есть, например). Заметим, что вытаскивание всего в документацию --- это плохо. Не потому, что программисты будут страдать (вы разработчики железа, вам похрен). А потому что в новой версии, где вы что-то поменяете, вам всё равно нужно выполнять эти delay slot'ы и прочее, даже если внутреннее устройство в этом не меняется.
    \subparagraph{\undercolorblack{orange}{Размышление про скорость}.}
    Что делать, если хочется поднять скорость? Ну, увеличиваем количество стадий, уменьшая их сложность. И это, как мы уже обсуждали, позволяет нам поднять тактовую частоту. Можно ли так делать бесконечно? Вместе с увеличение количества стадий усиливаются hazard'ы. И их решение не бесплатно (дополнительное железо, дополнительные NOP'ы, документация). И с какого-то момента стоимость решения hazard'ов будет больше, чем профит от увеличения количества стадий. С другой стороны зависимость скорости от таковой частоты --- не вполне линейная. Потому что нам нужно увеличивать напряжение питания, а при его повышении там возникает квадратичная зависимость, а не линейная. То есть за небольшой прирост производительности придётся много платить энергоэффективностью. Например, скорость лучше на 10\%, а эффективность хуже вдвое. И есть некоторое количество стадий, дольше которого дробить не выгодно. И это количество зависит от того, на что рассчитан процессор. Если энергоэффективные и высокопроизводительные. Высокопроизводительные --- это, например, десктопные компы. А есть мобильники, у которых есть аккум. А прогресс в аккумуляторах --- полное дерьмо. Потому если вы начнёте активно считать и выключитесь через 2 минуты, будет не хорошо. Поэтому там оптимизируют производительность на потреблённую энергию. И там эффективность около 2ГГц. В высокопроизводительных --- 4.5ГГц максимум. И они отличаются также конвейером, в высокопроизводительных он длиннее. Поэтому энергоэффективные процессоры хрен разгонишь, их конвейер может это не вывезти. В своё время был Pentium 4, спроектированный на достижение максимальных тактовых частот. И у него был конвейер в 30+ стадий. Они легко брали 4ГГц и планировали брать 5. И, возможно, даже брали, но жрали столько энергии, что просто жопа. И при этом Atlon 64, лежащие рядом, которые имели частоту чуть ли не вдвое ниже, работали быстрее, ведь в Pentium 4 была такая большая система обработки hazard'ов, что там очень часто выполнялись NOP'ы. И если оптимизировать под Pentium код, то он да, будет работать быстро. Но тут нужно очень специфически оптимизировать ассемблер, чем, в общем-то, никто не занимался.\\
    Хорошо, а как быстрее, чем конвейер? Когда не хватает стоимости конвейера, можно поставить 2 конвейера. Но это ещё нужно уметь. Если поставить два конвейера рядом, каждый из них по отдельности быстрее работать не будет. Надо как-то организовать их так, чтобы они быстрее решали одну задачу (не несколько, для нескольких используется многоядерность).
    \subparagraph{\undercolorblack{orange}{VLIW}.}
    Very long instruction word.
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw,minimum height=35pt] (IF) {IF};
            \node[rectangle,draw,minimum height=35pt,right=of IF] (ID) {ID};
            \draw[->] (IF) -- (ID);
            \node[rectangle,draw,right=of {$(ID.east)!.5!(ID.north east)$}] (EX1) {EX};
            \node[rectangle,draw,right=of {$(ID.east)!.5!(ID.south east)$}] (EX2) {EX};
            \foreach\i in {1,2}
            {
                \node[rectangle,draw,right=of EX\i] (MEM) {MEM};
                \node[rectangle,draw,right=of MEM] (WB) {WB};
                \draw[->] (ID.east |- EX\i) -- (EX\i);
                \draw[->] (EX\i) -- (MEM);
                \draw[->] (MEM) -- (WB);
            }
        \end{tikzpicture}
    \end{center}
    Одна машинная команда содержит 2 или более действий, которые декодируются на разные конвейеры и выполняются параллельно. Прирост скорость очевиден. Исходно кажется, что это дорогое удовольствие (действительно, мы копипастим одно и то же 2 раза). Но на самом деле, конвейеры не обязаны уметь выполнять все команды. Например, второй конвейер может не уметь в сложение и деление, но умеет во всё остальное. И тогда второй конвейер довольно лёгкий. Понятно, что множество команд деления не ускорится, но параллельно с ними можно будет выполнять какие-нибудь чилловые штуки. Что ещё можно сказать про VLIW? Например, следующее: если у нас есть последовательность совершенно зависимых действий, тогда второй поток будет выполнять NOP'ы. Кстати. Кто вообще распределяет команды по потокам? Компилятор. Поэтому компиляторы на VLIW выглядят очень страшно и работают совершенно нетривиально.
    \subparagraph{\undercolorblack{orange}{Superscalar}.}
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw,minimum height=35pt] (IF) {IF};
            \node[rectangle,draw,minimum height=35pt,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (sch) {\rotatebox{90}{scheduler}};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (sch);
            \node[rectangle,draw,right=of {$(sch.east)!.5!(sch.north east)$}] (EX1) {EX};
            \node[rectangle,draw,right=of {$(sch.east)!.5!(sch.south east)$}] (EX2) {EX};
            \foreach\i in {1,2}
            {
                \node[rectangle,draw,right=of EX\i] (MEM) {MEM};
                \node[rectangle,draw,right=of MEM] (WB) {WB};
                \draw[->] (sch.east |- EX\i) -- (EX\i);
                \draw[->] (EX\i) -- (MEM);
                \draw[->] (MEM) -- (WB);
            }
        \end{tikzpicture}
    \end{center}
    Тут добавляется специальный блок --- планировщик. Если в VLIW команды пишутся пачками изначально, то тут команды обычные, но планировщик смотрит на то, что к нему пришло и смотрит на то, куда он может очередную команду отправить. IF и ID обычно работают быстрее, что и даёт выигрыш. Но ещё планировщик может распределять микрооперации по конвейерам. Мы уже упоминали,, что x86 --- это снаружи CISC, а внутри RISC. И там ID только тем и занимается, что преобразует CISC в RISC. А всеми сторонними делами занимается именно планировщик. И вот из команды CISC может получиться несколько микроопераций RISC, которые планировщик уже и распределяет. А знаете, что ещё можно?
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw,minimum height=35pt] (IF) {IF};
            \node[rectangle,draw,minimum height=35pt,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (sch) {\rotatebox{90}{scheduler}};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (sch);
            \node[rectangle,draw,right=of $(sch.east)!.75!(sch.north east)$] (EX1) {EX};
            \node[rectangle,draw,right=of sch.east] (EX2) {EX};
            \node[rectangle,draw] (MEM) at ({$(sch.east)!.75!(sch.south east)$} -| EX2.south) {MEM};
            \foreach\i in {EX1,EX2,MEM}
            {
                \node[rectangle,draw,right=of {\i.center -| EX1.east}] (WB) {WB};
                \draw[->] (sch.east |- \i) -- (\i);
                \draw[->] (\i) -- (WB);
            }
        \end{tikzpicture}
    \end{center}
    Выделить обращение к памяти в отдельный конвейер, чтобы не гонять через неё арифметику. А ещё на Superscalar write back может быть дорогим (ещё обсудим, почему), в связи с чем схема может выглядеть вообще так:
    \begin{center}
        \begin{tikzpicture}
            \node[rectangle,draw,minimum height=35pt] (IF) {IF};
            \node[rectangle,draw,minimum height=35pt,right=of IF] (ID) {ID};
            \node[rectangle,draw,right=of ID] (sch) {\rotatebox{90}{scheduler}};
            \draw[->] (IF) -- (ID);
            \draw[->] (ID) -- (sch);
            \node[rectangle,draw,right=of $(sch.east)!.75!(sch.north east)$] (EX1) {EX};
            \node[rectangle,draw,right=of sch.east] (EX2) {EX};
            \node[rectangle,draw] (MEM) at ({$(sch.east)!.75!(sch.south east)$} -| EX2.south) {MEM};
            \node[rectangle,draw,right=of $(EX1.east)!.25!(EX2.east)$] (WB1) {WB};
            \node[rectangle,draw,right=of $(EX2.east)!.75!(EX2.east |- MEM.center)$] (WB2) {WB};
            \foreach\i in {EX1,EX2,MEM}
            {
                \draw[->] (sch.east |- \i) -- (\i);
                \draw[->] (\i) -- (WB1);
                \draw[->] (\i) -- (WB2);
            }
        \end{tikzpicture}
    \end{center}
    Понятно, что тогда запускаться в каждый момент может не больше двух команд. И это решает планировщик. Он вообще всё решает, за исключением того, что вы не хотите всё пихать в документацию. Вот вот VLIW у вас микроархитектура тесно связана с ISA, потому что старый код от добавления нового конвейера, например, вообще никак не ускорится, если не сломается в принципе. И нужно либо при любом изменении всё перекомпилировать, либо вообще переписывать, если там ASM. В Superscalar же, при новом конвейере/добавлении блока в конвейер/ещё чего угодно нужно изменить только планировщик. Поэтому и не надо выносить ничего в доку. Всё ещё не верно, что от компилятора Superscalar не зависит. Если компилятор вдруг решил скомпилировать все команды как последовательность, Superscalar не возьмёт вам производительность из воздуха.\\
    В чём плюсы и минусы всего этого? VLIW, например, проще реализовать в железе. А ещё компилятор может посмотреть на вашу программу полностью, подумать, ещё часик посмотреть и сгенерировать что-то мегаоптимизированное. А планировщик думает в реальном времени и зная только чуть-чуть данных. А в чём плюсы Superscalar (кроме уже упомянутой стабильной ISA). Далеко не всегда можно найти 3 независимых действия. И VLIW это или Superscalar, не важно. Но когда вы не можете загрузить на VLIW, вы явно пишете NOP. А в Superscalar это делает планировщик. Это приводит, что в Superscalar программки содержат больше полезных команд, а значит их проще разместить в кэше, чтобы всё быстро работало. Поэтому VLIW требует меньше места из-за отсутствия планировщика, но больше места на кэш (его нужно тупо больше). Ещё плюс VLIW в том, что планировщик жрёт энергию, но ничего полезного не делает. Но динамическое планирование --- это хорошо. Почему? В зависимости от входных данных, программа может обращаться к памяти по-разному. И попадать в кэш по-разному. Что делает Superscalar, если видит, что команда не попадает в кэш? Он понимает, что в ближайшие сотню \sout{лет} тактов ничему, зависящему от этой команды, ничего не светит. В VLIW такое просто невозможно, максимум --- вы можете посчитать в среднем вы попадете в кэш или нет. А ещё что сложно в Superscalar, то сложно и в компиляторе, следовательно не заметно, чтобы компиляторы что-то сильно лучше делали.
    \subparagraph{\undercolorblack{orange}{Отношение к реальности}.}
    Разумеется, все современные высокоскоростные процессоры --- Superscalar. А где VLIW? Например, Intel Itanium. Intel решили выкинуть x86 и придумать что-то на новом, перспективном VLIW'е. Но там были и технические проблемы, и много чего ещё, всё загнулось, Itanium окрестили Itanic и не так давно он умер официально. И вот сколько времени прошло, на уравне компилятора Intel так и не справились изобрести компилятор, который всё бы хорошо распределял. Руками распределить получается, а компилятором --- нет. Другой, более хороший пример, --- видеокарты AMD от HD2000 до HD6000. В чём мем видеокарт? Их легко параллелить. У каждой точки на экране есть RGB и, возможно, ещё и A. И очень странно, если они все друг от друга зависит. И исходно у AMD был там VLIW шириной 5, в HD6000 --- VLIW 4, а потом от него вообще отказались. Так в чём были плюсы VLIW? Да потому что там 4/5 независимых действий очень легко искать. Ещё потому, что всегда программы видеокарты пишутся не чём-то высокоуровневом, карточка сама всё компилирует. Следовательно, нет необходимости в поддержке ISA. так почему же от этого отказались? Потому что задачи на видеокартах стали сложнее, где уже компилятору становилось не очень, он пихал NOP'ы, AMD подрезали ширину до 4, но всё равно это не сильно помогло. Третий пример VLIW --- скрепный Эльбрус. Теперь понятно, почему у него великая пиковая мощность, что везде за цифры и т.д. Разумеется, если вы напишете код руками на ASM, то вы можете всё достичь. Но код обыкновенный один хрен на треть мощности будет работать.
    \subparagraph{\undercolorblack{orange}{Интеллектуальность Superscalar}.}
    Самый простой --- InO/InO (in order/in order). Первую команду --- на первый конвейер, если вторая от неё зависит --- грустно, а если нет, но на второй конвейер. Жадно, короче. К тому же, команды заканчивают выполняться одновременно. Если у нас сначала DIV, а потом ADD, то ADD висит на WB и ждёт выполнения DIV.
    Казалось бы, а зачем? Действительно, поэтому есть InO/OoO (in order/out of order).
    \begin{enumerate}[1.]
        \item DIV R1,R2,R3
        \item ADD R4,R2,R3
        \item SUB R4,R4,R5
    \end{enumerate}
    Тут пока выполняется DIV, мы справимся выполнить и ADD, и SUB. Ну, а зачем тогда всё-таки InO/InO.
    \begin{enumerate}[1.]
        \item DIV R1,R2,R3
        \item ADD R1,R2,R4
    \end{enumerate}
    Должно в регистр записаться сначала DIV, а потом --- ADD, а будет наоборот. Это конфликт WaW data hazard. Тут всё выглядит как бред, но что-то может быть после DIV и до ADD, да и вообще это не отменяет, что должно корректно работать. То есть тут уже становится понятно, почему WB --- это не простое записывание в память.\\
    Ещё есть совсем OoO (out of order), который способен запускать всё непонятно в каком порядке. Но посмотрим на такое:
    \begin{enumerate}[1.]
        \item DIV R1,R2,R3
        \item ADD R4,R1,R5
        \item SUB R5,R6,R7
    \end{enumerate}
    Тут ADD зависит от DIV, но мы же можем посчитать SUB, так? Ну, вроде как да, но после DIV выполнится ADD, а в R5, от которого он зависит, уже будет что-то новое. Это WaR data hazard, как несложно заметить.\\
    Что обо всём этом можно сказать? InO/InO --- вообще простая штука. Не самая эффективная, но простая. И памяти ей не надо много. А вот в OoO там блок из сотен команд памяти, в котором планировщик ищет что-то. Но всё же, как решать чисто технические (нам не хватает регистров, мы их переиспользуем) WaW и WaR конфликты? Аппаратное переименование регистров. Есть регистры, которые нам положены на уровне ISA (R0, R1, ...). И ещё есть аппаратные регистры (H0, H1, ...). И есть соотношение, какому аппаратному регистру что соответствует. И решение нашего конфликта состоит в том, чтобы в команде ADD регистру R5 соответствовало, например, H5, а после ADD --- H9. К чему это приводит? У тому, что мы дальше считаем команды, но то, что программно названо R5 --- это H9 и правильно работает. Когда же досчитается DIV, ADD будет под R5 иметь ввиду H5, а не H9, что нам и нужно.\\
    Что нужно из всего этого понять? То, что фон-Неймановская архитектура вообще не выполняется во имя увеличенной скорости работы. Но всё выполняется как попало, лишь бы работало. И это всё нужно как-то поддерживать. И кажется, что это просто, всего лишь hazard'ы порешать и хорошо. Так вот нет. Пусть вы делите на ноль. Тогда зачастую посылается прерывание. <<Прерывание>> --- это что-то, что вам нужно обработать (ОС знает, как, или вы сами знаете) и вернуться туда, где прервали. И не всегда после прерывания нужно умереть, это может быть прерывание от винчестера, что он закончил передавать данные. А значит процессор должен как-то привести состояние к чему-то в последовательном выполнении (то есть что-то быстро довыполнить, что-то откатить и вообще имитировать тот факт, что вы дошли до какой-то команды в программе). То есть ситуация ещё сложнее, чем hazard'ы.\\
    Во-вторых, представим себе условные переходы. Это кто? Это переход, который не всегда выполняется. И это не только \mintinline{c}{if}, но и циклы. Так что встречаете вы их постоянно. И понятно, что их обработка --- очень сложная по скорости вещь. Вам нужно выполнять либо то, что после перехода, либо команды, в ситуации, когда перехода не произошло. И прерываться на то, чтобы досчитать переход, --- это отвратительно, потому что это пустые конвейеры и простаивание процессора. А если у вас циклы с небольшими телами, то на это тратилось бы огромная количество времени (и энергии). Поэтому в современных процессорах есть система предсказания переходов. Это штука, которая, собственно, предсказывает, куда мы пойдём после перехода до самого его выполнения. И это мощная штука, потому что при правильно предсказанном переходе у вас будет обычное <<последовательное>> выполнение, а при неправильно --- нужно \sout{накатить} откатить состояние на то, что было. Как предсказывать? Можно считать условные переходы к более позднему адресу мы считаем не происходящими, а переходы к раннему --- происходящими. Эта штука неплохо выполняет циклы, потому что она в любом случае идёт в тело цикла, а в тела циклов вы идёте много чаще, чем выходите из них. Понятно, что с \mintinline{c}{if}'ами это работает \sout{плохо} никак. Поэтому есть классический двухбитовый предсказатель (двухбитовый --- потому что 4 возможных состояния):
    \begin{center}
        \begin{tikzpicture}
            \node[draw,circle] (3) {3};
            \node[draw,circle,below of=3] (2) {2};
            \node[draw,circle,below of=2] (1) {1};
            \node[draw,circle,below of=1] (0) {0};
            
            \draw[->] (3) to[out=60,in=120,looseness=8] node[midway,above] {\small$+$} (3);
            \draw[->] (3) to[out=-135,in=135] node[midway,left] {\small$-$} (2);
            \draw[->] (2) to[out=-135,in=135] node[midway,left] {\small$-$} (1);
            \draw[->] (1) to[out=-135,in=135] node[midway,left] {\small$-$} (0);
            \draw[->] (0) to[out=-120,in=-60,looseness=8] node[midway,below] {\small$-$} (0);
            \draw[->] (0) to[out=45,in=-45] node[midway,right] {\small$+$} (1);
            \draw[->] (1) to[out=45,in=-45] node[midway,right] {\small$+$} (2);
            \draw[->] (2) to[out=45,in=-45] node[midway,right] {\small$+$} (3);
        \end{tikzpicture}
    \end{center}
    Если он находится в состоянии 0 или 1, то считается, что переход не происходит, а в 2 и 3 --- происходит. А потом мы смотрим, произошёл ли переход на самом деле, и переходим по стрелке <<$+$>>, если да, а по стрелке <<$-$>>, если нет. То есть если переход обычно происходит вы будете жить в состояниях 2 и 3. Этих предсказателей можно поставить несколько и каждый из них работает в духе кэша, то есть каждому предсказателю соответствует условный переход в определённом месте программы. Или (в отличие от кэша) несколько переходов, тогда один предсказатель будет пытаться работать с ними одновременно. У таких предсказателей есть проблема: если вы стартуете в состоянии 1, а переход чередуется (начиная с происхождения), то вы в 100\% будете ошибаться (вы предскажете отсутствие перехода, он произойдёт, вы предскажете его происхождение, а он не произойдёт, и так до конца). Можно это пофиксить, сделав массив предсказателей и помнить <<поведение в зависимости от некоторой истории>>. Так, например, в нашем случае (если поставить двух предсказателей) всё будет работать идеально, потому что помня, что было два перехода назад, мы совершенно точно и однозначно видим, что будет.
    Из этого всего стоит осознать высокую (и нестабильную) стоимость \mintinline{c}{if} и циклов. Чем легче ваш условный переход предсказывается, тем дешевле ваши переходы. Рассмотрим вот такой пример:
    \begin{minted}{c}
        for (size_t i = 0; i < N; i++)
            if (x[i] > 0)
                s += x[i];
    \end{minted}
    То есть мы используем только некоторые элементы массива, и используем довольно легко. Если проверить время работы на отсортированных данных и на случайно расположенных данных, то выяснится, что второе будет сильно медленнее. И это понятно, почему, на отсортированных данных вы предсказываете отсутствие перехода, а потом предсказатель быстро учится, что теперь всегда переход случается. А случайные данные один хер предскажешь, вы будете очищать конвейер, заново читать команды и т.д. И именно поэтому есть идеи избавляться от \mintinline{c}{if}'ов. Например, как посчитать модуль целого числа без таковых? Ну, например, так:
    \begin{minted}{c}
        unsigned abs(int x)
        {
            unsigned mask = x >> 31; // Yep, arithmetical shift.
            return (x ^ mask) - mask;
        }
    \end{minted}
    Заметим, что нельзя сделать \mintinline{c}{mask = x >> 32}, потому что в x86 учитываются только столько знаков, сколько нужно. Дескать, зачем сдвигать число на 32 бита, давайте эти 32 брать по модулю. А в других системах может быть и то же самое, что и 31 бит (по стандарту undefined behaviour).\\
    Итого для подсчёта модуля нужно 4 команды (с учётом копирования значения).
    \begin{enumerate}
        \item MOV ebx,eax
        \item SAR ebx,31
        \item XOR eax,ebx
        \item SUB eax,abx
    \end{enumerate}
    Причём первая команда почти бесплатна (никогда не скажу тебе из-за чего, ты, фашистская свинья), так что команд по жизни 3. И в качестве альтернативы мы имеем
    \begin{enumerate}
        \item TEST eax,eax
        \item INS L1
        \item NEG eav
    \end{enumerate}
    То есть проверка на то, что число меньше нуля, и если меньше --- меняем знак. И по факту первая пара на современных процессорах --- одна команда. То есть тут либо одна, либо 2 команды. То есть меньше, чем 3, но дешевле это будет только если это правильно предскажется. Так, x86 на правильно предсказанный не произошедший переход действий не тратит вообще. На правильно предсказанный происходящий тратится чуть-чуть времени, а на любой неправильно предсказанный --- много. Поэтому в зависимости от процессора быстрее может работать и первый вариант, а может и второй.\\
    То есть теперь мы знаем две дорогие операции в процессоре --- неправильно предсказанный \mintinline{c}{if} и промах по кэшу при обращении в память. Поэтому дерево поиска, например, очень плохой константой обладает.
    \paragraph{\undercolorblack{orange}{Многопроцессорные системы}.}
    Хорошо, мы сделали хороший Superscalar (длинный конвейер и много), повысили частоту до максимума, сделали самый умный планировщик и самый умный предсказатель. Что дальше? Как мы ускоряли выполнение, когда было немного конвейеров? Добавили ещё. Так давайте поставим две штуки того, что было раньше. Но теперь это два процессора. Но там проблемы другого рода. Всё, что мы делали раньше --- это абсолютно незаметно для программиста, никак код от всего этого не меняется. С двумя процессорами не прокатит. Ещё вернёмся к этому. Где многопроцессорные системы традиционно использовались? В серверах, где запускалось несколько копий одного обработчика запросов, чтобы обрабатывать всё быстрее в 4 раза. Понятно, что мы можем упереться в скорость работы не процессора, а ещё чего, но мы сейчас забьём на это, без учёта этого такая параллельность (когда копии программы) --- рабочее решение. Но вот 4 копии игрушки запускать, чтобы быстрее игралось, --- это бред. Поэтому для пользовательских компов многопроцессорность не была так уж популярна, ведь пользовательские программы не так легко параллелятся. Два процессора --- всё же было неплохо (см. дальше для причин), а больше уже не нужно. Почему два процессора --- норм? А давайте посмотрим на то, как работает ОС. Никто вам не мешает запустить на одном ядре несколько программ. И как же? У ОС есть очередь процессов, из которой планировщик берёт команды и выполняет. Но до всего этого система настраивает системный таймер (штука, которая генерирует прерывания раз в N миллисекунд), и когда системный таймер генерирует прерывание, процессор прерывает ваш код, переходит в обработчик прерываний, который уже настроен операционной системой так, чтобы переключаться к следующей программе. И вот каждая программка выполняется небольшими кусочками времени. А вот если у нас есть несколько исполнителей, то ОС может отправить несколько процессов на выполнение одновременно. И вот пользователь обычно выполняет одну задачу, и у него максимум чуть-чуть мусора на фоне висит, в связи с чем 2 процессора чуть-чуть ускорят выполнение. А больше процессоров вообще не будут давать выигрыша. И так оно было довольно долго. Но вот мы утыкаемся в энергию: повышение тактовой частоты стало слишком дорогим. Поэтому с горя и стали искать новые способы ускорения, и нашли один --- много процессоров. Но только много процессоров --- это незачем, если можно разместить эти процессоры на одном кристалле, и получить, \textit{барабанная дробь}, ядра. Раньше <<процессор>> --- это исключительно вычислительная штука, но потом к процессору стали пихать интегрированные видеокарты, кэши, контроллеры памяти и прочее. И вот много таких полных блоков --- многопроцессорность, а просто много вычислителей --- многоядерность. То есть раньше эти термины были по сути одним и тем же, а теперь --- нет. Понятно, что многоядерность эффективнее в плане вычисления, например когерентность кэшей проще осуществлять на одном кристалле, но вот например, к двум процессорам можно подключить больше планок памяти. И вот в плане вычисления вы хотите многоядерность (высокоскоростная шина для дружбы двух процессоров --- это дорого). В итоге, понятно, стали появляться многоядерные компы. Понятно, что прямого прироста производительности в обыкновенном софте не будет. Но не всё так плохо, потому что со стороны ОС происходит такое же уточнение, как мы в железе выделение термина <<ядро>> из термина <<процессор>>. Точно также операционная система из термина <<процесс>> выделила термин <<thread>>. То есть теперь мы можем иметь несколько независимых исполнений внутри одного процесса. Чем это опять же отличается от нескольких процессов? У thread'ов общая память, например. Классический пример thread'овой системы --- считать циклы (если можно) не последовательно, а один thread считает чётные итерации, а другой --- нечётные. Другой пример --- отдельный thread по GUI, чтобы пользователь мог тыкать кнопочки, пока ваша программа считается и тормозит. И теперь ОС планирует исполнение не процессами, а thread'ами. И из thread'ов ОС выбирает тот, который выполнять. В чём проблема с thread'ами? В том, что вы сами должны всё параллелить, синхронизировать, если надо и прочее. Никак ОС не сможет ускорить ваш 1 thread на двух ядрах. Соответственно, если у вас 8 ядер, вы должны создать как минимум 8 thread'ов (причём реальных, вычислительных, а не так, как под GUI, который просто ждёт пользователя), чтобы всё задействовать. Почему вы не хотите не только мало, но и много <<тяжёлых>> thread'ов? Потому что они будут делить кэш на двоих, например. В чём самая главная проблема всего этого? В том, что всё это делает программист. Попытки сделать так, чтобы компилятор делал всё, работали слабенько. Например, параллелить циклы можно тогда и только тогда, когда тело независимо и только, если цикл тяжёлый (если он лёгкий, вы на создание thread'ов будете тратиться больше, чем получите выигрыша от многоядерности, а создание thread'а --- это дорогая операция). Более того, когда вы --- основной thread, побочные thread'ы могут закончиться существенно позже , чем вы (антивирус решил в одном из ядер посканировать вашу программу на вирусы, например), и вам придётся их ждать. Обычная программа ничего не может с этим сделать, а не обычная может сказать операционной системе, что она хочет выжрать все ядра, повиснуть и заставить ваш комп перестать отвечать на внешние воздействия. \textit{Очень удобно.}\\
    Давайте посмотрим на небольшой пример программы с несколькими thread'ами. У вас есть два исполнителя, которые оба делают \mintinline{c}{x++}. Вне зависимости от ISA и того, в сколько команд это раскладывается, это три действия: <<прочесть>>, <<увеличить>>, <<записать>>. И если два ваших thread'а читают одновременно, оба складывают, после чего пишут, в результате переменная увеличится на 1, а надо --- на 2. То есть посреди действия одного thread'а выполняется кусочек другого. Это называется race condition. Более того, может быть ещё ужаснее, когда после чтения в первом thread'е к нему приходит Windows Update, второй выполняется как должен, а первый просыпается через 1000 лет и записывает очень-очень старое значение, увеличенное на 1. Ещё вы иногда можете при одновременной записи получить в результате часть битов записанных из первого thread'а, а часть --- из второго. А в каких-то системах когда вы пишете одновременно, вам вообще не гарантируют, что будут что-то адекватное. И вот всё это вам нужно решать. Конкретно наш случай решается довольно легко несколькими способами. Один из них --- атомарные операции, то есть такие операции, которые гарантируют, что вот это вот увеличение на 1 --- это единая операция. Но это во-первых требует аппаратную поддержку, во-вторых, какое-нибудь атомарное умножение --- это то, что нельзя встретить, а атомарная пара действий не может существовать в принципе, а в-третьих атомарное увеличение на 1 намного дороже обычного. Поэтому щедро посыпать ваш код \mintinline{c}{std::atomic}'ами вы явно не хотите. Решение 2 --- критические секции. Вы обёртываете ваш код в специальные конструкции, которые гарантируют, что во внутренности этой конструкции одновременно может зайти только один thread. Но это, понятно, ещё дороже атомарных операций, хоть и не имеет ограничений на сами типы операций. И третий способ --- просто сделать несколько копий переменной, а потом (уже в одном thread'е) склеить ваши результаты. Это быстро (на вычислении), но так адаптируются вообще не все программы, да и склеивать вы должны всё в одном thread'. Есть более сложные варианты всего этого, но это в курсе параллельного программирования. А пока что как это писать? В C и Fortran есть такое расширение как OpenMP. Вы просто перед циклом вы пишете \mintinline{c}{#pragma omp parallel for}, и компилятор (если умеет в расширение) сам всё распараллелит по количеству ядер, которые у вас есть (или вы можете это количество явно указать). Более того, у этого есть опции. Вы можете исполнять это так, что первое ядро --- первая половина, а вторая --- вторую, а можете разделить всё на чётные и нечётные итерации. И это можно явно указать. Теперь давайте поговорим о логический ядрах. Кто это? В Superscalar есть ситуация, когда вы хрен найдёте то, что одновременно выполнять. Поэтому придумали технологию Simultaneous multithreading (и её реализацию для x86 --- hypertreading). Это умение одного ядра прикинуться двумя ядрами для операционной системы. Как сделать так, чтобы это работало (не быстро, а просто работало)? Сделать так, чтобы в каждом из этих псевдо-ядер были свои регистры. То есть вам нужно удвоить количество хотя бы логических регистров. И ещё нужно научить планировщик конвейера понимать, что к нему приходят команды разных thread'ов (что разные команды ADD R1,R2,R3 относятся к разным thread'ам, а следовательно R1, R2 и R3 --- это разные пары регистры в двух командах). Хорошо, а какой смысл этого всего? А то, что все конвейеры загружены сильнее и не простаивают. Если в одном thread'е все команды зависимы, то работал только один конвейер. А теперь любом случае хотя бы 2 будут заняты. Понятно, что тут будет ускорение, если конвейеры недозагружены и если количество thread'ов больше, чем количество физических ядер. Однако у всех операционных систем есть проблема в том, чтобы определять, <<а эти логические ядра --- они где какие?>> Так, в новых Intel есть 8 сильных ядер и 8 слабых. И первые умеют в hypertreading, а вторые --- нет. То есть для ОС они видны как 24 ядра. И если система будет запускать что-то на сильных ядрах, то будет хорошо, а если на слабых --- то нет. И ничего, кроме Windows 11 пока не может определять, а на каком из этих 24 запускаться-то. Тем не менее технология hyperthreading, она есть во всех процессорах, но в некоторых местах аппаратно отключена, потому что вы недостаточно заплатили производителю. У Intel есть два вида ядер: сильные и энергоэффективные, а всё остальное разделение --- это пережигание перемычек кристалла и прочие способы отключения функциональности. Кстати, ещё ио производителях и обмане. Например, вот i5 и i7 чем отличаются? Да абсолютно хрен его знает, ничего не понятно. Это <<примерно>> поколение, но вот поколение --- это когда процессор выпущен, а не микроархитектура. Мобильные устройства AMD на одно поколение на самом деле отстают, но по цифрам --- хз. С мегапикселями в телефонах то же самое, оптика должна быть хорошая, потому что пропускная способность оптики ограничена. И если взять телефон с не очень большим количеством мегапикселей, но хорошей оптикой, то изображение чаще всего будет лучше. Но вернёмся к многоядерности. Куча всяких ядер --- это, как мы говорили, с горя, потому что если бы могли вместо этого увеличить скорость каждого конкретного ядра, мы бы это и сделали. Ведь далеко не все алгоритмы могут использовать все ядра. Какая-нибудь игра может использовать только 3 тяжёлых потока, и тогда её пофиг, сколько у вас ядер: 4, 8 или 16. Не всегда можно масштабировать количество потоков. А ещё всё та же синхронизация, на неё тоже есть потери. Как у нас было, что длинные конвейеры имеют много проблем, так и тут эффективность многоядерности падает с увеличением количества ядер.
    \paragraph{\undercolorblack{orange}{Видеокарты}.}
    Это по сути тот же процессор, но с другой идеей. В процессоре решающее влияние на скорость оказывает скорость одного ядра. В видеокартах же стоит просто до задницы очень мелких ядер, и скорость зависит именно от их количества, а не от скорости одного ядра. ЧТо исходно была видеокарта? Контроллер, переводивший информацию из видеопамяти в сигналы для монитора. Видеопамять --- это кусок оперативки, отведённый под вот это, под видеокарту. Отличались карты тем, насколько качественные там картинки. А сейчас везде одинаковые цифровые интерфейсы, поэтому сейчас по качеству разницы нет. И раньше карты вычислительно ничего не делали, но всё изменилось с ростом популярности оконных интерфейсов (времена Windows 3). Особенность в том, что кто-то должен рисовать окошечки. Кто? Процессор. И когда вы просто таскаете окно по экрану, надо перерисовывать. Это несложно, но много обращений к памяти. Чтобы нарисовать фон, нужно пробежаться по прямоугольному кусочку (необязательно цельному), заполнить его цветом фона, а потом там что-то нарисовать. А процессор вообще юолее важными вещами занят. Так появились 2D-акселераторы --- первые видеокарты, которые, например, быстро могут заполнить прямоугольник константой. И теперь процессор может делом заниматься, а не долго обращаться к памяти. Ещё имеет смысл отделить видеопамять от оперативки, чтобы поместить её ближе к этой самой видеокартой. И теперь окна больше не тормозят. Чтобы проверить, как оно тормозило, можно убить драйвер видеокарты, поставить что-то стандартное и увидеть всё своими глазами. И долгое время видеокарты только это и умели, что 2D ускорение. Но время шло, и захотелось использовать 3D графику. Раньше были разные платы, которые могли делать это аппаратно. Аналогично аппаратными декодировщикам видео, которые позволяли смотреть 30 кадров в реальном времени (процессоры такое не успевали). Эта карточки (voodoo-карточки, например), кстати, не умели рисовать 2D, только 3D. Поэтому вам нужно подключать её после стандартной видеокарты, и если вы рисуете 2D, то она только чуть портит изображение, а иначе полностью заменяет выход видеокарты, в связи с чем у вас 3D только в полном экране, никакого сочетания 2D и 3D вместе. И эти voodoo-карточки были очень неплохи, что позволяло обычным пользователям жить с 3D графикой. Что касается API, то там был OpenGL, которым не очень пользовались игрушки, потому что медленно. Одна из наиболее знаковых игрушек игрушек, которая им начала пользоваться --- Quake. Вообще первый Quake --- это одна из первых игрушек, которая честно генерировала 3D, те же DOOM на самом деле не имеют вертикали вообще. И вот у voodoo-карточек есть родное их API --- Glide. И народ склепал транслятор OpenGL в Glide, что позволило запустить Quake на этих картах так, чтобы оно просто летало. Потом были voodoo 2 и вуду 3, потом SLI (вы можете купить две карточку voodoo, поставить вместе, специально соединить и они работали вместе: первая рисует чётные строки, вторая --- нечётные). И компания, которая это сделала (3DFX) --- пример того, как диктатор на рынке может разориться. Он, собственно, разорился, и его купила NVIDIA. С точки зрения API тоже интересно, так, Microsoft программно поддержали OpenGL 1.2. А потом внутри Microsoft появилась вторая группа, которая захотела сделать свой аналог, которая и победила, создав DirectX. Точнее, Direct3D. Сам по себе DirectX --- это средство того, чтобы не так было убого жить в Windows. Так, все игрушки отправлялись напрямую в DOS и жили там, потому что из Windows было медленно. И тогда и появился интерфейс DirectX про более прямой доступ к железу не через уродский API. И DirectX --- это и есть набор разных кусочков про это. DirectInput, например, про прямую работу с устройствами ввода, DirectSound --- со звуковыми картами, DirectDraw --- с видеокартами в контексте двухмерной рисовки, а Direct3D --- понятно, кто. Кто-то из этих штук благополучно умер, например, DirectDraw: он помечен как deprecated, и даже окна сейчас пишутся в 3D, а не 2D. И в итоге DirectX и выиграл, Microsoft убедила разработчиков игр писать под DirectX, в связи с чем появилась куча игр чисто под Windows. DirectX постоянно рос, туда добавлялась куча цирка (вы сразу в библиотеке задаёте две текстуры, четыре текстуры, чуть больше источников света, туман), который потом было очень сложно поддерживать. Писать кучу блоков подо всё это --- плохое решение. Поэтому предложили разработчикам самим писать то, что хочется. А что нужно менять? Только некоторые стадии конвейера вывода. Так, на этапе растеризации менять просто нечего. Исходно было только 2 программируемых места --- vertex/fragment в OpenGL или vertex/pixel в DirectX. Эти места называют шейдерами, и туда вы можете написать какой-нибудь не очень большой код, чтобы (в вершинном шейдере) изменить позицию трёхмерных точек или (во фрагментном шейдере) изменить цвета. Исходно можно было писать очень маленькие программки (не больше 128 команд, никаких циклов и т.д.) Изначально были разные блоки на вершинные и фрагментные шейдеры. И стало резко непонятно, насколько больше и каких ставить. Разные игрушки делают разное. Поэтому в следующем поколении сделали унифицированные шейдеры, то есть вычислители, которые могут делать оба типа вычислений. Со временем стало и больше команд, и сами команды более разные. В итоге мы пришли к тому, что в видеокартах есть универсальные вычислители, которые обладают очень высокой пиковой мощностью. И связано это с тем, что в процессоре есть куча несчитающих штук (жирные кэши, планировщики и прочий кал), а в видеокартах есть просто до задницы тупых вычисляющих штук и именно ими забит кристалл. А всё потому, что алгоритмы легко параллелятся. Нужно делать что-то с картинкой (совершая что-то одинаковое с каждой точкой, причём без взаимодействия). Причём это совершаемое действие должно быть простым, без засилия ветвлений и прочего. Если засунуть туда алгоритмы на деревьях, один хер это быстро заработает. А если делать что-то несложное, то мощность достигнет тех высоких цифр, которые значатся в максимуме. И ровно на такого рода вычисления и расчитаны видеокарты. После этого стало хотеться считать что-то алгоритмически похожее, но неграфическое. Звук, например, считается похоже. Так появился GPGPU -- General purpose GPU. Этим занимались ещё давно, но через костыли (вы рисовали прямоугольник из двух треугольников, на фрагментном шейдере считать нужный вам алгоритм, а потом вытаскивать из видеопамяти результат). Тут вам всё равно нужно настраивать графический конвейер, который нахер вам не нужно. И уже поэтому GPGPU. Так появились разные API для этого. Первое из них --- CUDA. Он и сейчас нормально живёт, потому что NVIDIA вложила в это кучу денег, помогла всем кому только не написать нужную программу на CUDA, и теперь библиотеки работают только на ней. А её реализовывать может только сама NVIDIA, поэтому чтобы использовать pandas быстро, вам нужна видеокарта именно от NVIDIA. Но всё это не понравилось Apple, которая хотела также, но не смогла, поэтому она спонсировала создание открытого интерфейса --- OpenCL. Он в некотором смысле круче, потому что он умеет не только в видеокарты, но и в FPGA, и в процессоре. То есть один и тот же код можно запустить где угодно. Только не гарантируется, что будет быстро, поэтому под существенно разные устройства вам всё равно придётся писать код чуть по-разному. Ещё есть compute шейдера в OpenGL и DirectX, которые, как говорят, не сильно хуже CUDA и OpenCL, но это наглая ложь. Что ещё нужно сказать? То, что OpenGL и DirectX --- штуки довольно древние, а видеокарты обновляются, поэтому драйвера обязаны транслировать те древние абстракции, которые были 1000 лет назад в то, что работает сейчас. А уж костыли NVIDIA в дрова вставлять умеет. Например, в 3dmark был тест --- <<дерево с листиками>>. А листики --- это смерть. Поэтому NVIDIA поставила специальный \mintinline{c}{if} на то, что это шейдер именно этого 3dmark'а, и если да, то запускать другой шейдер. Так что все дрова настолько читерные, что написав дрова по стандарту, большинство игр не заработают, потому что уже имеющиеся дрова написаны не по стандарту. NVIDIA имеет больше знаний о костылях, поэтому AMD всегда проигрывали. Их это достали, и они изобрели Mantle --- API, которое AMD предложили, чтобы реформировать происходящее, чтобы костыли из драйверов переехали в сами игры. Идея была хороша. Не то, чтобы Mantle кто-то использовал, но это был толчок для индустрии, в связи с чем появился Vilkan API и DirectX 12. DirectX 12, кстати, намного ближе к Vulkan, чем к DirectX 11. Apple склепали своё --- Metal. И вот Vulkan --- это почти то же самое, что и Mantle (даже до того, что в Mantle была функция \mintinline{text}{gr_} и название, а в Vulkan --- \mintinline{text}{vk_} и та же самая функция).\\
    Хорошо, а теперь разберёмся с ядрами. Когда пишут <<3000 CUDA-ядер>>, что это значит? Это не 3000 ядер, это 3000 конвейеров. В видеокарте есть именно что CUDA-ядра (то есть какие-то недоядра), которые умеют только считать. Они не знают, что они считают, они только считают. А блок, который решает hazard'ы, выбирает команды на выполнение и прочее, он один на кучу ядер. У вас один такой процессор способен сразу исполнить 64 thread'а, но каждый будет исполнять одну и ту же команду. Это не только рост эффективности (меньше кристалла на control-flow и больше на вычисления), но и совершенно другая стоимость условного перехода. Тут нет предсказателей вообще (это дополнительный не считающий блок, он нахер не нужен; исходно на видеокарте совсем не было кэшей, а теперь есть кэши, но немножко для другого). А тут если все 64 thread'а работают одинаково (либо все входят, либо все --- нет), то всё легко. А если хотя бы один thread делает не то, что остальные, то теперь все thread'ы обязаны посчитать и \mintinline{c}{if}, и \mintinline{c}{else}. Сначала те, кто выполняют \mintinline{c}{if}, выполняют его, а остальные --- делают NOP, а потом --- наоборот. Поэтому тут стоимость условных переходов --- это дёшево, если он одинаковый везде, а иначе --- дорого. Warp или wave-front --- это вот этот блок, который содержит thread'ы, живущие одинаково. В NVIDIA это 32 thread'а, в старых AMD --- тоже 32, потом --- 64, а сейчас это вообще переключаемо в процессе выполнения. В Intel (интегрированные карты) размер этого блока бывает 8, 16 и 32, и это определяется компилятором. И логично назвать ядрами --- вот эти независимые warp'ы.\\
    Ещё стоит остановиться на доступе к памяти. На процессоре долгий доступ решается кэшем. На видеокарте его либо нет, либо его незначительное количество. А как тогда? На одно ядро (то есть на один warp) запихивается не 64 thread'а, а существенно (в 10 раз, например, больше). И этот вычислитель берёт 64 thread'а, выполняет команды до тех пор, пока нет доступа к памяти. А вместо того, чтобы ждать, он откладывает эти thread'ы и переключается на следующую пачку в 64 thread'а. И так продолжается пока мы не вернёмся к первой. И если в других thread'ах было достаточно много вычислений, то к этому моменту уже всё возьмётся из памяти. Называется это <<скрытие латентности памяти>>. И именно поэтому картам не критично время доступа, а критично время передачи. В итоге то, с какой скоростью отвечает вам память не важно до тех пор, пока она успевает обрабатывать все ваши запросы.\\
    Отступление про DLSS. Сейчас что модно? Нейронные сетки. Один из самых распространённых алгоритмов обучения --- перемножение матриц. Где популярны нейронные сети? В Data-центрах, где из непонятных наборов информации пытаются взять закономерность. И под Data-центры всё это и оптимизировано. Поэтому NVIDIA добавила отдельные блоки под это в видеокарты. Но разумеется делать две линейки карт (с блоком и без) --- это невыгодно. Потому геймерам этот впарили как DLSS (нейросеть для upscaling'а). Всё то же самое было бы полностью работоспособно на обычной видеокарте и не сильно медленнее.
    \paragraph{\undercolorblack{orange}{Предсказание адреса перехода}.}
    Представим процессор. С виртуальными функциями. Это функция, адрес которой известен в процессе выполнения. То есть идёт вызов не к метке, а к значению регистра. И этот адрес тоже хочется предсказать. Нередко такие переходы ведут себя однозначно. Практически всегда происходит переход на одну и ту же функцию.  Если вы предсказываете это хорошо, то вы молодец. Тут, кстати, даже компиляторы пытаются сделать девиртуализацию, сказав, что скорее всего будет что-то конкретное. Но предсказание этого имеют проблему. Например, уязвимость вида Spectre и вида Meltdown. Про что это? Про то, что процессоры имеют разграничение доступа (ОС отгораживает себя от пользовательского кода). Это разумно, ведь если вы сделаете что-то глупое, вам не хочется, чтобы вся система накрылась. Обычно это реализовано так, что код ОС --- привилегированный (ему можно всё), а ваш код --- не привилегированный (вам что-то нельзя). Как это связано с, например, Meltdown? Мы можем написать что-то такое:
    \begin{enumerate}
        \item MOV eax,[...]
        \item MOV ebx,[ecx+eax]
    \end{enumerate}
    eax, ebx и ecx --- регистры. И в первой команде пусть мы обращается туда, куда может обращаться только ОС (то есть нам это нельзя). Что будет? В процессе выполнения этой команды мы понимаем, что эта команда должна упасть, мы должны перейти на обработчик. Но перед каждой командой проверять, что вы можете обратиться туда, куда хотите --- плохо и медленно, поэтому проверка прав работает параллельно. Но это параллельность может разойтись, и мы выполняем следующую команду до того, как вы проверим корректность. Итого мы сделаем второе вычисление, потом придёт проверка, состояние откатится на корректное, и мы перейдём по ошибке. Что тогда можно сделать? По адресу ecx завести наш массив, а перед обращением удостовериться, что этого массива нет в кэше. Тогда его кусочек (по которому мы нелегально обратились) залезет в кэш, а остальные кусочки --- нет. И померив, какой кусочек массива у вас в кэше есть, а какого --- нет (по скорости обращения), мы узнаем, куда же мы в итоге нелегально обратились. Есть нюансы с тем, что мы узнаем только кэш-линию, а не байт, но мы можем сделать эту пару команд несколько раз, каждый раз прибавляя к ecx то единичку, то двоечку, то что ещё. И тогда мы в один момент перескочим из данной кэш-линии в другую. Тогда мы и узнаем, какой конкретной байт у нас есть, а значит именно то значение, которое было в eax. Как это исправили? ОС перед передачей управления пользовательскому коду выкидывает из его адресного пространства всё, что нельзя. А по-хорошему это правится так, что обработка прав должна быть не медленнее, чем обращение к памяти. Это Intel'овская бага, и большой позор тому, кто её допустил. Эта уязвимость существует в Intel и некоторых ARM.\\
    Spectre --- это похожая вещь, но с более ужасными последствиями. Spectre нас будет очень долго преследовать, и его править никто не собирается. Spectre существует двух вариаций. Так выглядит первая:
    \begin{minted}{c}
        unsigned char buf[N];
        unsigned int x;
        if (x < N)
        {
            y = buf[x];
            z = buf2[y];
        }
    \end{minted}
    При условии, что \mintinline{c}{buf2} имеет достаточный размер, этот код совершенно корректен. Как эта штука выполняется современными процессорами? Пусть у нас очень много раз этот переход происходит, а потом мы задаёт \mintinline{c}{x} как что-то очень большое. Тогда переход будет предсказан неверно, мы выполним тело \mintinline{c}{if}'а, потом откатимся и перейдём в \mintinline{c}{else}. Проблема возникает, если у нас этот код привилегирован, а \mintinline{c}{buf2} и \mintinline{c}{x} --- что-то пользовательское. И не в кэше. И тогда вы спрашиваете такое значение \mintinline{c}{x}, которое даст вам не значение в \mintinline{c}{buf}, а что-то из какого-то места памяти (у нас же 32-битная модулярная арифметика). А в своём коде вы опять смотрите на \mintinline{c}{buf2} и то, что у вас в буфере вдруг закэшировано. Это, как видно, похоже на Meltdown, но если там это был конкретный баг, то тут мы читаем то, что нам можно читать (это же привилегированный код). Чтобы это пофиксить, нужно очень по-уродски переписать все системные вызовы, все драйвера и всё остальное, чтобы писать код станет невозможно. А ещё это нельзя пофиксить, убрав кэш, ведь то же самое можно сделать с оперативной памятью (у нас же там открываются и закрываются линии). Если это прям честно пофиксить, то придётся убить предсказателя, а это очень плохо по скорости. Поэтому всё, что можно сделать, --- компилировать системный код со специальными ключами компилятора, чтобы они как-то попытались поставить перед данными \mintinline{c}{if}'ом специальную команду, чтобы исправить предсказателя. Кстати, то же происходит с браузерами, ведь они --- привилегированный код по отношению к JavaScript. И там то же самое. Поэтому браузеры первое что сделали --- порезали системные таймеры, чтобы это было сложнее. Но это всё равно можно обойти.\\
    Spectre 2 делает почти то же самое, но он спекулирует не предсказателями, а тем, куда условный переход произойдёт.\\
    Вообще подобных каналов утечек есть тьма, но на них забивают, потому что бороться с ними сложно и дорого. Но если вы занимаетесь безопасностью всерьёз, и вам это критично, то вам нужно учиться со всем этим жить. И <<порезать таймеры>> --- разумеется, недостаточное решение, потому что человек, знающий математическую статистику, справится вытащить результат из нескольких попыток. Более разумная заплатка --- добавление специальных действий, которые при переключении в режим ядра позволяют сбросить буфер предсказаний. Это убивает скорость, но так делают все заплатки, лол. Кстати, аналогично есть с временем выполнения чего-либо. Так, в простом криптографическом алгоритме от ключа может зависеть время шифрования (если какой-то бит 0, вы не делаете действие, а иначе делаете). И это возможно даже на аппаратном уровне. Поэтому в криптографических алгоритмах пытаются сделать константное время выполнения (добавляя бессмысленные команды). Но это делать сложно, потому что, здравствуйте, оптимизирующий компилятор. Короче, сложно жить, нужно уметь правильно программировать, потому что вырубать оптимизацию совсем --- отвратительное решение. Ещё интересная область --- внедрение ошибок. Если вы считаете криптографический алгоритм с ошибкой, например, в умножении, возможно, вылезет много информации о секретном ключе. Самый простой способ заставить железо ошибаться --- занизить напряжение питания. При разгоне процессора во избежание ошибок нужно повышать напряжение, а можно наоборот, ничего не разгонять, н понижать напряжение. И вот идея в том, чтобы понизить не фатально, но так, чтобы ошибки происходили с хорошей вероятностью. При этом люди даже умеют предсказывать, на каком железе какие ошибки происходят, а значит вы можете из правильного алгоритма, в который вы внедряете конкретные ошибки, вытащить данные. Вообще это довольно интересная и обширная тема с кучей мемов. Например, можно распознавать речь в помещении на основе задержек ответа жёсткого диска. Звуковые колебания приводят к дрожанию винчестеров, что и увеличивает время получения информации. Эти задержки скармливают нейронной сети, и она распознаёт речь.
    \section{Устройство внешних носителей данных.}
    Сегодня мы рассматриваем магнитные, оптические и на флэш-памяти.
    \paragraph{\undercolorblack{orange}{Магнитные накопители}.}
    Самое простое устройство --- дискета. Есть материал, хорошо сохраняющий намагниченность. Точнее, не он сам, а тонкое покрытие/напыление, нанесённое на плёнку как-то так:
    \begin{center}
        \begin{tikzpicture}[scale=2]
            \draw (-1,-1) rectangle (1,1);
            \foreach\i in {.125,.25,.375,.5,.625,.75,.875}
            {
                \draw (0,0) circle (\i);
            }
            \foreach\i in {0,...,7}
            {
                \draw[rotate=45*\i+22.5] (.125,0) -- (.875,0);
            }
        \end{tikzpicture}
    \end{center}
    И ради защиты от физических воздействий (чтобы пальцами не стереть покрытие) диск располагают в конвертиках, на которых есть отверстие, чтобы магнитная головка могла получить доступ к любой области диска за счёт вращения. Физически это --- ориентация магнитных доменов, и либо вы меняете эту ориентацию, либо смотрите на неё, если надо читать. Внутри информация состоит из дорожек, которые разбиты на сектора. Дорожки --- это кружочки, их традиционно 80 штук, причём информацию можно писать с каждой стороны диска, поэтому адресация там была CHS (Cylinder, Head, Sector). Цилиндр --- номер дорожки, головка --- сторона (нижняя или верхняя), сектор -- сектор. Размер каждого сектора константа, и традиционно он 512 байт полезных данных. Но дисководы давали низкоуровневый доступ, позволяющий делать сектора и другого размера, и вообще странно их располагать и прочие извращения.\\
    Хорошо, а как понять, где вы на этом диске? Для этого в каждом секторе хранится, какой он (именно поэтому 512 --- это полезная информация, служебной там немало). Кстати, можно зачем-то извратиться и нумеровать сектора непоследовательно. И сектора могут быть ещё и разного размера, короче доступ у вас есть ко всему. Ищутся сектора просто последовательно, проходя линейно по всем, потому что изменять направление вращения нельзя. Скорость доступа у этого, понятно, не очень, а скорость передачи --- ну, норм для того времени. Классический объём этого --- 1.44 МБ. В то время это было неплохо.\\
    Система, кстати, не очень надёжна, любое магнитное поле портит данные. Поэтому там хранятся коды CRC (cyclic redundancy check) --- хэш от ваших данных. При считывании вы пересчитываете хэш, если не совпадают --- вы проиграли, иначе, с довольно хорошей вероятностью --- не проиграли. И вообще никто ни на каких носителях вам не гарантирует, что всё читается корректно, а гарантируется вероятность ошибки $10^{-x}$ степени. Ещё вам говорят, что если CRC не сойдётся, данные вам просто не дадут. Читаете вы полностью сектор (это минимальная адресуемая ячейка на дискете), непонятно, как читать меньше, к тому же хэш считается только по всему сектору, поэтому пишут только целый сектор. Чтобы ваш диск не был совсем уж дорогим, какие-то его области могут быть сделаны чуть хуже, а какие-то --- чуть лучше. Поэтому хочется, чтобы при небольшом количестве ошибок хочется жить. Поэтому вместе с CRC есть ECC (error correction code). Можете почитать про хороших их пример --- коды Рида---Соломона, хорошо ломает мозг. Тут всё как на дискретке --- у вас код, и он восстанавливает какое-то количество ошибок (например, 16 бит на 4 байта кода). Можно сделать б\'{о}льшие коды коррекции, и будет надёжнее, но сложнее жить. Но ECC пытается восстановить информацию всегда, даже если ошибок было больше, чем то, на что он рассчитан. Поэтому ECC не отменяет CRC. Вопрос: что лучше --- сначала сделать CRC, а потом ко всему полученному применить ECC, или наоборот. Лучше первое, потому что иначе CRC при даже однобитовой ошибке не даст вам данные. И если на низкоуровневых дисководах можно обратиться к диску напрямую, самому всё прочитать, посмотреть на CRC и ECC самому, и так далее. Этим, кстати, USB-дисководы отличаются от настоящих, потому что настоящие могут переупорядочить ваш диск так, чтобы обойти плохие области, на хороших сделать поменьше ECC, увеличив их люъём и т.п., а USB так вообще не умеют.\\
    Другой пример магнитных носителей --- магнитные ленты. Идея записи вся та же самая, но информация располагается на ленте. Как ни странно, ленты --- даже сейчас самый надёжных и дешёвый способ хранения долговременной информации, только они гарантируют вам 30 лет сохранения данных. А ещё их следует хранить в холодильнике. Вдобавок ленты дёшевы. Единственный минус лент --- отсутствие произвольного доступа, придётся промотать всю ленту. Поэтому именно на лентах очень хорошо хранить резервные копии. Это большие объёмы информации, которые редко используются, но очень хочется сохранность. В прошлом ленты использовались для хранения аналоговой информации, а сегодня это цифровая, как и всё.\\
    Развитие этой идеи, которые можно видеть сейчас --- винчестеры. Это по сути та же дискета, но в закрытом корпусе, за счёт чего можно хранить всё плотнее. Тут также есть сектора и дорожки, но расположены они чуть по-другому.
    \begin{center}
        \begin{tikzpicture}[scale=2]
            \draw (-1,-1) rectangle (1,1);
            \foreach\i in {.125,.25,.375,.5,.625,.75,.875}
            {
                \draw (0,0) circle (\i);
            }
            \foreach\i in {0,...,4}
            {
                \draw[rotate=360/5*\i] (.125,0) -- (.125*3,0);
            }
            \foreach\i in {0,...,7}
            {
                \draw[rotate=360/7*\i+360/15] (.125*3,0) -- (.125*5,0);
            }
            \foreach\i in {0,...,9}
            {
                \draw[rotate=360/9*\i+360/15*2] (.125*5,0) -- (.125*7,0);
            }
        \end{tikzpicture}
    \end{center}
    Тут суть в том, что на любом секторе одинаковая площадь. На дискете не очень эффективно использовалась поверхность. На винчестере дорожки не все содержат одинаковое количество секторов, есть группы дорожек с одинаковом количеством секторов, но вообще ближе к центру --- меньше секторов. Тут уже невозможна адресация по CHS, потому что в не особо хотите знать, где сколько секторов. Поэтому там используется адресация на современных винчестерах --- LBA (logical block addressing), это просто число от 0 и до максимума, а трансляция его в физический адрес осуществляется контроллером внутри винчестера. Притом это вы можете даже увидеть, глядя на скорость передачи данных. Дорожки нумеруются начиная с внешней и так, как диск крутится с фиксированной угловой скоростью, скорость передачи данных в начале диска больше, чем в его конце. И разница между скоростями в начале и конце в два раза. Ещё в винчестерах может быть не один диск, а несколько, и магнитная головка стоит с каждой стороны каждого диска. В принципе сейчас есть идеи разделить блок этих магнитных головок на 2 части, чтобы независимо обращаться на одном диске к верхней половине и к нижней. Но это для системы будет выглядеть как два диска вместо одного, что уже сомнительно.\\
    И ещё винчестеры отличаются тем, что они боятся физических воздействий. Вы хотите очень близко подвести магнитную головку к поверхности, чтобы плотность была большая. Поэтому если стукнуть винчестер, магнитная головка может либо расцарапать диск, либо сама сломаться. В ноутбуках, кстати, с этой же целью ставятся гироскопы, чтобы можно было как-то жить.\\
    В наше время в целях экономии появляются так называемые shingled винчестеры, у которых суть в следующем. По жизни, если хочется больше памяти, можно сделать больше дорожек. Но магнитная головка же не по математической линии считывает, а по некоторой области. И вот в shingled при записи на дорожку могут побиться другие дорожки. Потому пока вы пишете последовательно, у вас всё хорошо, но если вы обращаетесь в произвольное место памяти, вам придётся очень долго перезаписывать потёртые данные. Поэтому этим пользоваться можно тогда и только тогда, когда вам нужен исключительно последовательный доступ (для камер наблюдения, например).\\
    Понятно, что с поднятием плотности увеличивается процент ошибок, поэтому надо улучшать коррекцию. Современные процессоры перешли на 4КБ сектора. Простой пример, почему: ECC в 8 секторах на 512 байт и в одном на 4КБ имеют одинаковый размер, на 4КБ лучше, потому что если у вас ошибок немного, но они сконцентрированы в одной области, то в маленьких секторах вы проиграли, а в большом --- нет. Но так как 512-байтные сектора были очень долго, все просто захардкодили 512Б. Поэтому 4КБ-сектора сами по себе работать нем будут, а будут только с эмуляцией 512 байт. Разумеется, ничего хорошего не происходит, если обращаться по секторам, потому что винчестер должен будет считать весь свой настоящий сектор на 4КБ, заменить там 512Б и перезаписать, что долго и неэффективно. С эти надо что-то делать, и файловые системы делают. Они оперируют таким понятием как <<кластер>> (своего рода сектор, но для файловой системы), который обычно 4КБ. Поэтому винчестер надо правильно форматировать, нужно начинать файловую систему с адреса, кратного 4КБ, и поставить там размер кластера не меньше 4КБ.\\
    Следующая интересная вещь про винчестеры --- система SMART (self-monitoring, analysis and reporting technology). Контроллер винчестера ведёт статистику каких-то параметров (количество исправленных ошибок, температура и много чего ещё), которые можно у винчестера спросить. Современные винчестеры злопамятны и ведут количество раз, которое его били и нецивилизованные выключения питания. Так есть количество reallocated секторов. Если у вас один сектор побился, при чтении будет грустно, а при записи всё внезапно починится, потому что SMART после записи поймёт, что сектор плох в специальную резервную зону. И SMART хранит, сколько раз такое было. Если это число --- 0, всё прекрасно, если небольшая константа --- норм, а если она растёт, то вашему винчестеру плохо. Если вам SMART говорит, что всё плохо, значит всё реально плохо, а если говорит, что хорошо, то это ничего не значит.
    \paragraph{\undercolorblack{orange}{Оптические накопители}.}
    Оптические диски бывают нескольких видов. Как устроены они? Информация пишется также секторами, но другой принцип записи. В оптику информация пишется в виде ямок и не-ямок. И можно узнать, ямка там или нет. При этом в оптических дисках всё --- это спираль, то есть одна дорожка, разделённая на сектора. Спираль стартует в центре, поэтому они как раз тем быстрее, чем больше диск заполнен. Точнее, так было бы, ведь в дисках есть не только режим фиксированной угловой скорости, но и скорости линейной, что очень хорошо, если ты, например, музыку проигрываешь, или пишешь что-то. Типичный размер сектора --- 2КБ. Начнём с интересных фактов про царапины. Как хуже царапать диск, вдоль спирали или поперёк? Разумеется, поперёк, ведь так у вас будет одна ошибка в разных секторах, и это будет проще восстановить. Но с другой стороны, такая царапина может сбивать считывающую головку, поэтому иногда даже лучше аккуратно закрасить царапину чёрным маркером. Однако в целом диски довольно надёжны, единственное совсем плохое, что с ними случается, --- это отслоение защитного покрытия, попадание туда воздух и, как следствие, ржавение, что уже, очевидно, не восстанавливается. В плане того, что с дисками можно делать, диски бывают разные. ROM --- только чтение, <<ямки>> были сделаны во время производства. Это надёжно, но, понятно, не перезаписываемо. R-диски продаются чистыми и вы туда можете один раз понаделать <<ямок>>. И вам нужен более мощный лазер, который эти <<ямки>> умеет делать. И изменить эту информацию нельзя, разве что на уровне файловой системы, которая просто пометит файл как удалённый. RW-диск выглядит как R, и исходно вообще назывался E (erasable). И у них суть в том, что их можно нагреть, и их поверхность разгладится и очистится. То есть информацию можно стереть и превратить в изначальное состояние диска R. Кстати, это можно сделать примитивно при помощи солнца. Стирать данные, понятно, можно не бесконечно, рано или поздно ваши ямки превратятся совсем в дырки, а ещё поверхность RW-дисков по-другому отражает, нежели R и ROM, что приводит к тому, что RW-диски могут быть вообще нечитаемыми для читающих R и ROM. Потенциально ещё бывают RAM --- развитие RW, которые позволяют делать то же самое, но лучше (надёжнее и дольше), но они довольно редки, непопулярны и совсем по-другому устроены, нежели RW, поэтому их трудно не только найти, но и прочитать.\\
    Исходно эти диски были сильно дешевле в соотношении к объёму, нежели, например, винчестеры. Если копнуть глубже, то изначально CD-ROM был создан для хранения музыки, и были настолько оптимизирован под это, что сектора нумеруются минутами и секундами. Существуют три поколения дисков (CD, DVD и Blu-Ray), причём в третьем поколении ещё была война стандартов, но не суть. Различаются поколения в основном длиной волны лазера (дальше --- меньше длина вольны, а значит меньше дырки и больше данных). В CD стандартный размер --- 700МБ, в DVD --- 4.7ГБ (если односторонний и однослойный), а Blu-Ray --- >20ГБ. <<Односторонний и однослойный>> значит следующее: начиная с DVD можно писать данные на двух сторонах, если переворачивать их ручками, а ещё можно сделать второй полупрозрачный слой, и фокусировать лазер на нём, читая именно его. Односторонные двухслойные имели 9ГБ памяти. Вообще, двухслойные диски R и RW были, но были очень дорогими, поэтому двухслойные прижились только как DVD-ROM. А двухсторонние были очень популярны у пиратов, которые на дешёвый двухсторонний диск писали то, что было в более дорогом одностороннем двухслойном. В свою очередь Blu-Ray бывают даже четырёхслойными (технология BDXL) и такие имеют 128ГБ. В первом поколении ещё были выкрутасы, например музыка писалась в специальном формате 2352Б/сектор, и это был отдельный звуковой режим, пока в стандартном цифровом было 2048Б/сектор. И в первом нет CRC и ECC на последнем уровне, потому что зачем они, музыка пишется без сжатия, а значит пара бит не повлияет ни на что. Поэтому, кстати, возникает проблема с копированием музыки на CD-дисках, ведь вы не знаете, правильно её прочитали или нет. Поэтому аудио пытаются просто прочесть несколько раз, что, очевидно, не избавляет от царапин или ещё чего, что всегда даёт вам одну и ту же ошибку. В дальнейшем это не прижилось, и даже в audio-DVD были просто двоичные данные. Второе и третье поколение созданы в основном для кодирования видео и были оптимизированы под это. Но ещё при этом они охуели с защитой. Так, в DVD разделили мир на Америку, Европу и Японию, Китай, Россию и Африку, и кучку других регионов, и пытались сделать так, чтобы диски в разных регионах читались по-разному, чтобы были разные цены. Но вся это система полетела, там было 32 бита шифровального ключа, и вообще на старых прошивках можно было программно выбрать свой регион, а на Blu-Ray вообще довольно приличная система с отзывом ключей (можно шифровать несколькими ключами, и если один раскроют, то система, которую раскрыли, больше не сможет читать, а другие --- смогут). Первый ключ выкопали из WinDVD, сделав дамп всей памяти и попробовав все порции из 32 бит, одна из которых была ключом. И чем дальше, тем хуже, поэтому эти диски сами себя убили, поэтому существование следующего поколения под большим вопросом, несмотря на то, что оптические диски довольно эффективны, например, по плотности данных. Вообще много что умирало из-за патентов и идиотизма в стандартах. Так, JPEG-2000, который должен был придти на смену JPEG, не прижился вообще из-за того, что там в стандарте было написано <<мы не знаем, есть ли у кого-нибудь патенты на технологии и алгоритмы тут>>.
    \paragraph{\undercolorblack{orange}{Накопители на флэш-памяти}.}
    Что такое флеш-транзисторы? Это полевой транзистор, у которых есть <<плавающий затвор>>. Что это? Это никуда не подключенный провод, куда можно с обычного затвора при помощи туннельного эффекта заселить электроны. И он будет при таком будет вести себя как обычный затвор с напряжением. И эти самые электроны и могут хранить информацию. Выселяются электроны подачей напряжения на подложку. Это плавающий затвор деградирует со временем, и либо туда будет не заселить электроны, либо не выселить. Поэтому тут, как и в оптике, нет возможности перезаписать, только очистить данные. И если запись происходит секторами, то стирание --- очень большими блоками (иногда вообще весь диск).\\
    Исходно флэш-память использует те же интерфейсы, что и винчестеры, но работает по-другому. Если ваш SSD забит под завязку, то записать на него данные --- очень дорогая операция, потому что вам нужно считать большой блок, слить его в новыми данными, очистить и перезаписать. И, разумеется, это увеличивает износ диска, ведь вам приходится писать больше данных, чем хочется (параметр, характеризующий, насколько больше --- write amplification). Единица --- хорошо, больше единицы --- вот, приходится писать много, меньше единицы --- если ваш контроллер сжимающий и вы пишете данные, которые сжались. Соответственно, если на SSD есть свободное место, контроллеру жить проще: вместо того, чтобы писать в забитый блок, он пометит ваш текущий сектор как неиспользуемые данные под стирание, а в пустом пространстве назначит новый под ваши данные. А как-нибудь потом контроллер будет в фоне стирать ваши недостёртые данные. Ещё SSD пытается балансировать загрузку, если вы пишете в какой-то сектор часто, то SSD пытается сделать так, чтобы этот сектор не так сильно изнашивался, через некоторое время переназначая его номер. Этим именно и отличаются тупые флэшки от умных SSD. Поэтому и отличаются времена жизни и времена записи памяти у флэшек и SSD. Кстати, поскольку SSD наследуют HDD, в них также есть SMART, поэтому также можно узнавать, насколько плохо вашему диску. А ещё можно узнать, сколько записей вы сделали.\\
    Теперь про режимы работы флэш-памяти. Электрончики не обязаны держать транзистор только в открытом или только в закрытом состоянии. Транзистор --- аналоговое устройство, и может находится в разных степенях открытия. И ваша память может работать в SLC (single-level cell) --- стандартно, один бит на транзистор, а может --- в MLC (multi-level cell), когда состояний обычно 4, и соответственно хранится 2 бита на транзистор. Потом появился TLC (triple-level cell) --- 3 бита. Потом появились QLC и разрабатывается PLC --- соответсвенно 4 и 5 бит. Понятно, что ресурс по перезаписям сильно с этим связан, ведь не отличить 2 значения намного сложнее, чем не различить 8, а значит больше значений --- меньше перезаписей. И если в SLC --- лимит перезаписей порядка 100000, то в MLC --- 5000--10000, в TLC --- 3000, в QLC --- вообще хз, скорее всего около 1000. Причём обычно чем меньше техпроцесс (и новее память), тем больше значений ячейки, тем меньше перезаписей. Но вот флэш-память --- это первая штука, которую начали располагать в 3D, вместо того, чтобы увеличивать количество ячеек, потому что она почти не греется. Кстати, QLC даже имеет смысл, например если есть много (просто очень много) данных, которые ты пишешь почти никогда, а читать хочется быстро, то вот тебе и решение. А читаются данные реально быстро, а точнее скорость доступа очень большая, потому что в винчестере надо долго искать сектор, а тут вы берёте и обращаетесь к памяти. Сейчас про SLC все производители забыли, поэтому сейчас придётся искать MLC и пытаться не вляпаться в <<MLC triple-bit>>. Если цена подозрительно маленькая, это может быть QLC или не дай боже PLC. Кстати, из-за долгой записи памяти, TLC и далее имеют маленький SLC-буфер, в который вы очень быстро пишете, а когда его не хватает, ваша скорость резко проседает.\\
    Ещё интересный момент про SSD --- команда TRIM. В HDD при удалении файла никто его специально не уничтожал, а просто помечал его как удалённый. А в SSD вообще нет, ведь если вы действительно очистите сектора, их можно будет использовать. И вот TRIM --- расширение стандарта HDD, чтобы с ним и SSD могли жить. Что с этой командой делают HDD --- просто берут и помечают блок как чистый, не трогая данные. Соответственно, вам нужна операционная система, которая в это умеет и отсутствие какого-нибудь устройства между процессором и диском, которое эту команду не понимает и выкидывает.
    \paragraph{\undercolorblack{orange}{Post scriptum}.}
    В данный момент продолжаются попытки сделать какой-то новый более эффективный и живучий тип памяти, существует множество перспективных интересных технологий, как, например, R-DRAM, память основанная на резисторах, она хранится веками и без энергии, но никакая технология не дошла до более эффективного, чем флэш-память массового производства.
    \paragraph{\undercolorblack{orange}{Фрагментация}.}
    Если ваш файл лежит не подряд, то понятно, что HDD умрёт по времени, ведь кусочки вашего файла надо будет везде искать для каждого кусочка. А SSD вообще говоря, всё равно.
\end{document}