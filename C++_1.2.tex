\documentclass{article}
\input{Headers/header}

\usepackage[outputdir=Output, cachedir=mintedcache]{minted}
\usemintedstyle{tango}
      
\geometry{legalpaper, paperheight=8906pt, margin=1in}
\setcounter{totalnumber}{100}
\pagestyle{empty}

\setcounter{tocdepth}{5}

\begin{document}
    \tableofcontents
    \section{Вступление про устройство компьютера.}
    Стандартно до непосредственно C++ рассказывают немного Архитектуры ЭВМ и немного ассемблера. Разумеется, только базовое представление. Зачем? Когда мы будем говорить про языковые конструкции, мы не будем говорить только то, как они работают, но ещё и почему так, как эффективно ими пользоваться и т.п. Почему, например, лямбды без списка захвата приводятся к указателю на функцию, а со списком~--- нет? Без изучения основ архитектуры компьютера, мы не сможем ответить на этот вопрос. А если мы изучим базу, вопрос будет не такой, а <<как может быть иначе>>. Есть более простые и практические вещи: если вы что-то профилируете и желаете ускорить, то высокоуровневые оптимизации (убрать ненужное действие, не считать что-то дважды)~--- это легко, а более низкоуровневые вообще нельзя сделать без знаний того, как внутри компьютер работает. Скаков даже приводил пример с подсчётом суммы положительных чисел на массиве (если его предварительно отсортировать, будет сильно быстрее). Существует множество историй о том, как программисты не могли разобраться в вопросе, почему их код работает не с такой скоростью, как они рассчитывают, пока им это не поясняла Intel. Ещё основы архитектуры компьютера пригодятся при отладке. Если программа работает не так, то для понимания, где же именно ошибка, нам требуется понимать, что внутри процессора происходит. И наконец есть более философская полезность: если вы чем-то пользуетесь, то чем лучше вы разбираетесь, как оно работает, тем грамотнее можно этим пользоваться. То же самое с библиотеками, например (если библиотека что-то умеет, а вы не знаете об этом, вы начинаете городить костыли). Например, в x86 есть специальная инструкция с длинной арифметикой, и лучше бы писать такой код, чтобы компилятор догадался пользоваться ей.
    \paragraph{Работа с памятью.}
    В нашем поверхностном знакомстве мы построим упрощённую модель, а потом уточним её там, где надо. В жизни всё, разумеется, работает очень сложно, и мы будем сталкиваться (не часто, но будем) с тем, что не сможем объяснить. Что с точки зрения нашей простой модели есть память? Пронумерованный набор ячеек со значениями от 0 до 255. К одному биту у нас обратиться способа нет, как мы знаем из ЭВМ (нам придётся считать байт и работать битовыми операциями с ним). Память поддерживает две операции: чтение и запись. Первое по номеру ячейки даёт число (данные в нужной ячейке), второе~--- по числу и номеру~--- записывает данные. Номер называется адресом памяти (то есть адрес~--- это число, ничего более умного).\\
    Как процессор берёт команды из памяти? У него есть регистр (то есть маленький кусочек памяти), который называется IP (instruction pointer)~--- адрес следующей инструкции, которую он будет исполнять. И вот процессор миллиарды раз в секунду читает IP, исполняет записанную по этому адресу инструкцию, после чего переходит к следующей (увеличивая IP).
    \paragraph{Ассемблер и возможности процессора.}
    Команды пишутся байтами. Это неудобно читать, неудобно писать и, самое главное, неудобно запоминать, какая комбинация байтов что значит. Поэтому, чтобы не запоминать, люди придумали набор человеко-читаемых мнемоник и назвали его <<ассемблер>>. Важно понимать, что набор мнемоник отличается не только от архитектуры к архитектуре, но и от прибора, которым вы ассемблируете код, к прибору.\\
    Что процессор умеет? Кроме IP у процессора (на x86) есть 8 регистров общего назначения (\mintinline{nasm}|AX|, \mintinline{nasm}|BX|, \mintinline{nasm}|CX|, \mintinline{nasm}|DX|, \mintinline{nasm}|SP|, \mintinline{nasm}|BP|, \mintinline{nasm}|SI|, \mintinline{nasm}|DI|). Нам сейчас не очень важно, что они все значат. Каждый из них имеет 16 бит. Самая простая команда процессора~--- \mintinline{nasm}|MOV dst, src|. Это простое присваивание вида \mintinline{c}|dst = src|. В качестве её аргументов можно пихать константы или регистры. Также при помощи \mintinline{nasm}|MOV| можно читать и писать память. Для этого используется обозначение вида \mintinline{nasm}|[10]|: когда мы так пишем, мы имеем ввиду не число 10, а значение в десятой ячейке памяти. \mintinline{nasm}|MOV| может оперировать память двумя путями: \mintinline{nasm}|MOV [AX], BX| и \mintinline{nasm}|MOV AX, [BX]|, но не может \mintinline{nasm}|MOV [AX], [BX]| (для этого физически в кодировке команд нет возможности). А какие возможности есть? А вот такие:
    \begin{itemize}
        \item \mintinline{nasm}|MOV reg, reg|
        \item \mintinline{nasm}|MOV reg, imm|
        \item \mintinline{nasm}|MOV reg, [reg]|
        \item \mintinline{nasm}|MOV reg, [imm]|
        \item \mintinline{nasm}|MOV [reg], reg|
        \item \mintinline{nasm}|MOV [imm], reg|
        \item \mintinline{nasm}|MOV [reg], imm|
        \item \mintinline{nasm}|MOV [imm], imm|
    \end{itemize}
    Хорошо, теперь давайте подумаем вот о чём. Регистр \mintinline{nasm}|AX| шестнадцатибитный, а значит при выполнении команды \mintinline{nasm}|MOV| нужно откуда-то эти 16 бит читать. Откуда? А вот откуда: читается не только тот адрес, который запросили, но ещё и следующий. Но возникает вопрос: какой из прочитанных байт старший, а какой~--- младший? Оба варианта возможны. Если байты с младшими адресами являются младшими байтами, то это little-endian, если старшие~--- то big-endian. Пример: если у нас в ячейке с номером 100 записан байт \mintinline{c}|0x6C|, а с номером 101~--- \mintinline{c}|0xAA|, то в LE при чтении ячейки \mintinline{nasm}|[100]| мы получим число \mintinline{c}|0xAA6C|, а в BE~--- \mintinline{c}|0x6CAA|. В x86 используется исключительно первый. Комментарий: если у нас просто есть число, то некорректно говорить о его endianess (как говорить и endianess регистров), а endianess возникает, когда мы пишем либо читаем что-то в байтовом представлении.\\
    Хорошо, есть ли возможность читать 8 бит, а не 16? Да, есть, для этого есть регистры \mintinline{nasm}|AL|, \mintinline{nasm}|AH|, \mintinline{nasm}|BL|, \mintinline{nasm}|BH|, \mintinline{nasm}|CL|, \mintinline{nasm}|CH|, \mintinline{nasm}|DL|, \mintinline{nasm}|DH|. При этом \mintinline{nasm}|AL|~--- младшие 8 бит \mintinline{nasm}|AX|, а \mintinline{nasm}|AH|~--- старшие, и аналогично с \mintinline{nasm}|BX|, \mintinline{nasm}|CX|, и \mintinline{nasm}|DX| (в остальных 4 регистрах такого разделения нет).
    \subparagraph{Арифметика.}
    Процессор умеет выполнять все базовые арифметические инструкции (\mintinline{nasm}|ADD|, \mintinline{nasm}|SUB|, \mintinline{nasm}|AND|, \mintinline{nasm}|OR|, \mintinline{nasm}|XOR|). Работают они как \mintinline{c}|dst += src|, \mintinline{c}|dst -= src|, \mintinline{c}|dst &= src|, \mintinline{c}|dst |= src|, \mintinline{c}|dst ^= src|. Все они поддерживают те же комбинации \mintinline{nasm}|reg|/\mintinline{nasm}|imm|/\mintinline{nasm}|[reg]|/\mintinline{nasm}|[imm]|, что и \mintinline{nasm}|MOV| (см. выше). Также как и в \mintinline{nasm}|MOV|, в них нельзя смешивать 8 бит и 16 бит, даже в C++ если совершать операции с типами разного размера, компилятор расширит их до общего.\\
    Ещё есть унарные операции: \mintinline{nasm}|INC| и \mintinline{nasm}|DEC|. Они увеличивают/уменьшают значение на единицу. При этом, если передать унарным операциям регистр, то будет ясно, что они сделают, а в случае с памятью не вполне понятно, они оперируют 8 бит или 16. Поэтому в случае с памятью пишут \mintinline{nasm}|INC byte [reg]| или \mintinline{nasm}|INC word [imm]|. Аналогично работают унарные операции \mintinline{nasm}|NEG| и \mintinline{nasm}|NOT| (\mintinline{c}|dst = -dst| и \mintinline{c}|dst = ~dst|).\\
    Теперь разберёмся с умножением (\mintinline{nasm}|MUL|). Оно в процессоре x86 унарное и выполняется таким образом: аргумент всегда умножается на регистр \mintinline{nasm}|AX|. При этом если брать 16-битное умножение, то младшие 16 бит результата пишутся в \mintinline{nasm}|AX|, а старшие~--- в \mintinline{nasm}|DX|, а если 8-битное~--- то аргумент умножается на \mintinline{nasm}|AL|, а результат пишется в \mintinline{nasm}|AX|. Но это ещё не все, потому что в отличие от сложения, вычитания и прочих уже рассмотренных операция умножение разное в беззнаковых и в знаковых типах данных. Поэтому помимо \mintinline{nasm}|MUL| (который выполняет умножение для \mintinline{c}|unsigned|), есть ещё \mintinline{nasm}|IMUL|~--- для \mintinline{c}|signed|. Аналогично им есть есть \mintinline{nasm}|DIV| и \mintinline{nasm}|IDIV|. Они делят также принимают только один аргумент. Эти операции выполняют деление 32-битного числа на 16-битное. При этом 32-битное число берётся из регистров \mintinline{nasm}|DX| (старшие 16 бит) и \mintinline{nasm}|AX| (младшие). Результат деления считается 16-битным и записывается в \mintinline{nasm}|AX| частное. При этом также \mintinline{nasm}|DIV| и \mintinline{nasm}|IDIV| считают остаток, который пишется в \mintinline{nasm}|DX|. Поскольку мы делим 32 бита на 16, возникает вопрос, как поделить 16 на 16. Для беззнаковых чисел всё кристально ясно: надо обнулить старшие 16 бит, то есть обнулить \mintinline{nasm}|DX|. Обнулять \mintinline{nasm}|DX| рекомендуется при помощи \mintinline{nasm}|XOR DX, DX| (она занимает на один байт меньше, чем \mintinline{nasm}|MOV DX, 0|). А что со знаковыми числами? Тут в дополнении до 2 надо старшие 16 би заполнить битом знака (то есть старшим битом \mintinline{nasm}|AX|). Для этого есть специальная команда,~--- \mintinline{nasm}|CWD|. Теперь давайте узнаем, что будет, если мы делим на 0? Происходит системное прерывание. Причём не в таком случае, а ещё если мы делим 32 бита на 16, а результат не помещается в 16. Но есть ещё один способ получить деление на ноль (не деля при этом на ноль) для этого нужно поделить поделить минимальное целое число на -1; это происходит потому, что $-2^{15}$ влезает в 16 бит, а $2^{15}$~--- нет. Все эти ситуации, как уже было сказано, приводят к системным прерываниям. Системные прерывания работают следующим образом: у процессора есть IDTR~--- массив, содержащий обработчики прерываний (для каждого типа), который ОС подготавливает при запуске.
    \subparagraph{Control-flow.}
    Мы уже понимаем, что компилятор делает с арифметическими выражениями, а значит линейный код мы уже можем перевести на ассемблер руками. А вот ветвления и циклы~--- пока нет нет. Как они идейно работают? У процессора есть команды, которые называются branch'ами. Самая простая из них~--- \mintinline{nasm}|JMP| (своего рода \mintinline{c}|goto|). Её аргументом является число, которое нужно прибавить к IP, чтобы перейти на адрес следующей инструкции. В ASM, однако, это вместо этого пишется метка, по которой и осуществляется переход.\\
    Помимо \mintinline{nasm}|JMP| есть conditional branch (то есть переход, если выполнено какое-то условие). Осуществляются они комбинацией команды \mintinline{nasm}|CMP| и какой-то из команд \mintinline{nasm}|JE|, \mintinline{nasm}|JG|, \mintinline{nasm}|JL| или подобной. Первая команда (пока непонятным нам образом) сравнивает два регистра, а потом вторая получает результат этого сравнения и совершает переход только в определённом случае. В таблице ниже перечислены условия для каждой из команд:
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Команда & Эквивалент & Расшифровка\\
            \hline
            \mintinline{nasm}|JE| & \mintinline{c}|left == right| & jump if equal\\
            \mintinline{nasm}|JG| & \mintinline{c}|(signed)left > (signed)right| & jump if greater\\
            \mintinline{nasm}|JL| & \mintinline{c}|(signed)left < (signed)right| & jump if less\\
            \mintinline{nasm}|JA| & \mintinline{c}|(unsigned)left > (unsigned)right| & jump if above\\
            \mintinline{nasm}|JB| & \mintinline{c}|(unsigned)left < (unsigned)right| & jump if below\\
            \hline
            \mintinline{nasm}|JNE| & \mintinline{c}|left != right| & jump if not equal\\
            \mintinline{nasm}|JNG| & \mintinline{c}|(signed)left <= (signed)right| & jump if not greater\\
            \mintinline{nasm}|JNL| & \mintinline{c}|(signed)left >= (signed)right| & jump if not less\\
            \mintinline{nasm}|JNA| & \mintinline{c}|(unsigned)left <= (unsigned)right| & jump if not above\\
            \mintinline{nasm}|JNB| & \mintinline{c}|(unsigned)left >= (unsigned)right| & jump if not below\\
            \hline
        \end{tabular}
    \end{center}
    Теперь давайте всё же поговорим, как работает \mintinline{nasm}|CMP|? Для этого нам нужно поговорить о такой штуке как регистр флагов. Он содержит, собственно, битовые флаги. Из их большого набора нас интересуют CF~--- carry flag, ZF~--- zero flag, SF~--- sign flag и OF~--- overflow flag. В процессе своей работы разные инструкции устанавливают различные флаги (хотя какие-то на определённые флаги не влияют, у каких-то инструкций эти флаги значат свой, поэтому читайте документацию). А мы рассмотрим, как с ними работают инструкции, в частности арифметические. \mintinline{nasm}|ADD| и \mintinline{nasm}|SUB| работают так: они выставляют ZF~--- если результат равен 0, SF~--- если результат отрицательный, CF~--- если произошёл перенос в сложении/заимствование в отрицании беззнаковых чисел, OF~--- если знаковая операция вызвала переполнение. Так вот, \mintinline{nasm}|CMP| устанавливает флаги также как \mintinline{nasm}|SUB|. То есть она по сути делает вычитание, но отбрасывает результат. Поэтому, например, \mintinline{nasm}|JE| просто совершает переход, когда ZF~--- единица. Кстати, в контексте флагов было бы не лишним упомянуть, что существуют специальные инструкции условного перехода, которые совершают либо не совершают переход в зависимости от флагов. К таким относятся \mintinline{nasm}|JZ|, \mintinline{nasm}|JC|, \mintinline{nasm}|JS|, \mintinline{nasm}|JO|, \mintinline{nasm}|JNZ|, \mintinline{nasm}|JNC|, \mintinline{nasm}|JNS| и \mintinline{nasm}|JNO|. Их их названия понятно, что они делают. Кстати, несмотря на то, что в ассемблере есть \mintinline{nasm}|JE| и \mintinline{nasm}|JZ|, по сути они делают одно и то же и даже одинаковым набором байт обозначаются (поэтому если вы будете ассемблировать-дизассемблировать код, учтите, что в коде ASM одна из этих инструкций может замениться на другую). Теперь давайте определим, при каких комбинациях флагов совершают переходы оставшиеся инструкции. \mintinline{nasm}|JB|~--- понятно, если CF~--- истина. Также понятно \mintinline{nasm}|JA|~--- если CF и ZF оба ложны. А на какие биты смотрят \mintinline{nasm}|JG| и \mintinline{nasm}|JL|~--- хороший вопрос. Чтобы это понять, давайте сделаем график. Оси будут обозначать левый и правый аргумент, а клеточку мы будем закрашивать, если нужный нам флаг будет поставлен при \mintinline{nasm}|CMP|. График будет нарисован для трёхбитных чисел, чтобы на нём было всё лучше видно. Например, вот так выглядит область, где поставлен флаг ZF:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 15cm,
                height = 15cm,
                grid = both,
                xmin = -8.51,
                xmax = 7.51,
                ymin = -8.51,
                ymax = 7.51,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                axis line style = {->},
                axis on top = true,
                xtick = {-8.5,-7.5,...,7.5},
                xticklabels = \empty,
                ytick = {-8.5,-7.5,...,7.5},
                yticklabels = \empty,
                extra x ticks = {-8,...,7},
                extra x tick style = {grid=none},
                every tick label/.append style = {font=\tiny},
                every x tick label/.append style = {font=\tiny, yshift=0.5ex},
                every y tick label/.append style = {font=\tiny, xshift=0.5ex},
                extra y ticks = {-8,...,7},
                extra y tick style = {grid=none},
                xlabel = \empty,
                ylabel = \empty,
                ]
                \newcommand\ru{ -- ++($(axis cs:1,0)-(axis cs:0,0)$) -- ++($(axis cs:0,1)-(axis cs:0,0)$)}
                \newcommand\ur{ -- ++($(axis cs:0,1)-(axis cs:0,0)$) -- ++($(axis cs:1,0)-(axis cs:0,0)$)}
                \path[name path=A] (axis cs:-8.5,-8.5) \ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru;
                \path[name path=B] (axis cs:-8.5,-8.5) \ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur\ur;
                \addplot[green] fill between[of=A and B];
            \end{axis}
        \end{tikzpicture}
    \end{center}
    Но он нам не очень интересен, давайте нарисуем OF и SF. Сначала посмотрим на клетку $(0;1)$. Сто\'{и}т ли там SF? Ну, да, ведь $0-1<0$. А сто\'{и}т ли он выше? Ну, по-хорошему, тоже да, но в определённый момент мы станем из очень большого отрицательного числа вычитать что-то, и у нас будет происходить переполнение (то есть результат будет положительным). В каком месте это будет происходить? Ну, $(-8;1)$, $(-7;2)$, $(-6;3)$ и так далее. То есть выглядит это так:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 15cm,
                height = 15cm,
                grid = both,
                xmin = -8.51,
                xmax = 7.51,
                ymin = -8.51,
                ymax = 7.51,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                axis line style = {->},
                axis on top = true,
                xtick = {-8.5,-7.5,...,7.5},
                xticklabels = \empty,
                ytick = {-8.5,-7.5,...,7.5},
                yticklabels = \empty,
                extra x ticks = {-8,...,7},
                extra x tick style = {grid=none},
                every tick label/.append style = {font=\tiny},
                every x tick label/.append style = {font=\tiny, yshift=0.5ex},
                every y tick label/.append style = {font=\tiny, xshift=0.5ex},
                extra y ticks = {-8,...,7},
                extra y tick style = {grid=none},
                xlabel = \empty,
                ylabel = \empty,
                ]
                \newcommand\ru{ -- ++($(axis cs:1,0)-(axis cs:0,0)$) -- ++($(axis cs:0,1)-(axis cs:0,0)$)}
                \newcommand\ur{ -- ++($(axis cs:0,1)-(axis cs:0,0)$) -- ++($(axis cs:1,0)-(axis cs:0,0)$)}
                \path[name path=A] (axis cs:-8.5,-7.5) \ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru;
                \path[name path=B] (axis cs:-8.5,-.5) \ur\ur\ur\ur\ur\ur\ur\ur;
                \addplot[cyan] fill between[of=A and B];
            \end{axis}
        \end{tikzpicture}
    \end{center}
    Но на самом деле эта картинка неверна, потому что мы можем вычесть из большого положительного числа большое отрицательное и получить переполнение в другую сторону и отрицательное число в результате. Поэтому на самом деле картинка выглядит так:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 15cm,
                height = 15cm,
                grid = both,
                xmin = -8.51,
                xmax = 7.51,
                ymin = -8.51,
                ymax = 7.51,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                axis line style = {->},
                axis on top = true,
                xtick = {-8.5,-7.5,...,7.5},
                xticklabels = \empty,
                ytick = {-8.5,-7.5,...,7.5},
                yticklabels = \empty,
                extra x ticks = {-8,...,7},
                extra x tick style = {grid=none},
                every tick label/.append style = {font=\tiny},
                every x tick label/.append style = {font=\tiny, yshift=0.5ex},
                every y tick label/.append style = {font=\tiny, xshift=0.5ex},
                extra y ticks = {-8,...,7},
                extra y tick style = {grid=none},
                xlabel = \empty,
                ylabel = \empty,
                ]
                \newcommand\ru{ -- ++($(axis cs:1,0)-(axis cs:0,0)$) -- ++($(axis cs:0,1)-(axis cs:0,0)$)}
                \newcommand\ur{ -- ++($(axis cs:0,1)-(axis cs:0,0)$) -- ++($(axis cs:1,0)-(axis cs:0,0)$)}
                \path[name path=A] (axis cs:-8.5,-7.5) \ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru\ru;
                \path[name path=B] (axis cs:-8.5,-.5) \ur\ur\ur\ur\ur\ur\ur\ur;
                \addplot[cyan] fill between[of=A and B];
                
                \path[name path=C] (axis cs:7.5,-8.5);
                \path[name path=D] (axis cs:-.5,-8.5) \ur\ur\ur\ur\ur\ur\ur\ur;
                \addplot[cyan] fill between[of=C and D];
            \end{axis}
        \end{tikzpicture}
    \end{center}
    А ещё мы на самом деле уже обсудили переполнение. Флаг переполнения ставится в этих областях:
    \begin{center}
        \begin{tikzpicture}
            \begin{axis}[
                width = 15cm,
                height = 15cm,
                grid = both,
                xmin = -8.51,
                xmax = 7.51,
                ymin = -8.51,
                ymax = 7.51,
                axis equal,
                axis x line = middle,
                axis y line = middle,
                axis line style = {->},
                axis on top = true,
                xtick = {-8.5,-7.5,...,7.5},
                xticklabels = \empty,
                ytick = {-8.5,-7.5,...,7.5},
                yticklabels = \empty,
                extra x ticks = {-8,...,7},
                extra x tick style = {grid=none},
                every tick label/.append style = {font=\tiny},
                every x tick label/.append style = {font=\tiny, yshift=0.5ex},
                every y tick label/.append style = {font=\tiny, xshift=0.5ex},
                extra y ticks = {-8,...,7},
                extra y tick style = {grid=none},
                xlabel = \empty,
                ylabel = \empty,
                ]
                \newcommand\ru{ -- ++($(axis cs:1,0)-(axis cs:0,0)$) -- ++($(axis cs:0,1)-(axis cs:0,0)$)}
                \newcommand\ur{ -- ++($(axis cs:0,1)-(axis cs:0,0)$) -- ++($(axis cs:1,0)-(axis cs:0,0)$)}
                \path[name path=A] (axis cs:-8.5,.5) \ru\ru\ru\ru\ru\ru\ru;
                \path[name path=B] (axis cs:-8.5,7.5);
                \addplot[orange] fill between[of=A and B];
                
                \path[name path=C] (axis cs:7.5,-8.5);
                \path[name path=D] (axis cs:-.5,-8.5) \ur\ur\ur\ur\ur\ur\ur\ur;
                \addplot[orange] fill between[of=C and D];
            \end{axis}
        \end{tikzpicture}
    \end{center}
    При этом какая область нам нужна для \mintinline{nasm}|JL|? Нам нужна область строго выше ZF. Посмотрев внимательно на графики, получим что это SF \textrm{xor} OF либо же SF != OF. А что же нам нужно для \mintinline{nasm}|JG|? Ну, очевидно, SF == OF \& !ZF. Теперь мы можем составить полную таблицу условий, которые проверяют conditional-branch'и:
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            Инструкция & Флаги\\
            \hline
            \mintinline{nasm}|JE| & \mintinline{c}|ZF|\\
            \mintinline{nasm}|JG| & \mintinline{c}|SF == OF & !ZF|\\
            \mintinline{nasm}|JL| & \mintinline{c}|SF != OF|\\
            \mintinline{nasm}|JA| & \mintinline{c}|!CF & !ZF|\\
            \mintinline{nasm}|JB| & \mintinline{c}|CF|\\
            \hline
        \end{tabular}
    \end{center}
    Как определяются условия для остальных команд, либо очевидно (для \mintinline{nasm}|JZ|, \mintinline{nasm}|JC| и подобных), либо следует отсюда (для \mintinline{nasm}|JNE|, \mintinline{nasm}|JNG| и т.д.)\\
    остаётся только заметить, что нам не всегда нужно делать \mintinline{nasm}|CMP| до условного перехода, ведь иногда у нас флаги уже после каких-то операций стоят как нам хочется. Например, это можно пронаблюдать в таком примере:
    \begin{minted}{nasm}
loop:   MOV DX, AX
        ADD AX, BX
        MOV BX, DX
        DEC CX
        JNZ loop
    \end{minted}
    \subparagraph{Регистры большей битности.}
    Переносимся из 1978 года в 1985, когда Intel выпускают 32-битный процессор. Тогда появились регистры \mintinline{nasm}|EAX|, \mintinline{nasm}|EBX|, \mintinline{nasm}|ECX|, \mintinline{nasm}|EDX|, \mintinline{nasm}|ESP|, \mintinline{nasm}|EBP|, \mintinline{nasm}|ESI|, \mintinline{nasm}|EDI|, младшими 16-ю битами которых являются старый набор регистров. А в 2003 годы появилось 64-битное расширение, которое создало \mintinline{nasm}|RAX|, \mintinline{nasm}|RBX|, \mintinline{nasm}|RCX|, \mintinline{nasm}|RDX|, \mintinline{nasm}|RSP|, \mintinline{nasm}|RBP|, \mintinline{nasm}|RSI|, \mintinline{nasm}|RDI|. Но помимо к этому количество регистров удвоилось; для новых, правда, не стали придумывать названий, они называются по номерам: \mintinline{nasm}|R8|--\mintinline{nasm}|R15|. Их версии меньшей битности называются \mintinline{nasm}|R8D|--\mintinline{nasm}|R15D|, \mintinline{nasm}|R8W|--\mintinline{nasm}|R15W| и \mintinline{nasm}|R8B|--\mintinline{nasm}|R15B| (от слов dword, word и byte соответственно). То есть, например, \mintinline{nasm}|R8D|~--- младшие 32 бита \mintinline{nasm}|R8|, \mintinline{nasm}|R8W|~--- младшие 16 \mintinline{nasm}|R8D|, а \mintinline{nasm}|R8B|~--- младшие \mintinline{nasm}|R8W|.
    \begin{center}
        \begin{tikzpicture}[scale=.5]
            \newcounter{y}
            \setcounter{y}{0}
            
            \foreach\reg in {A,B,C,D}
            {
                \draw[fill=cyan!25!white] (-10,-1.5+\value{y}/2) rectangle (5,3.5+\value{y}/2);
                \node at (-8,1+\value{y}/2) {R\reg X};
                \draw[fill=cyan!50!white] (-5,-1+\value{y}/2) rectangle (5,3+\value{y}/2);
                \node at (-3,1+\value{y}/2) {E\reg X};
                \draw[fill=cyan!75!white] (0,-.5+\value{y}/2) rectangle (5,2.5+\value{y}/2);
                \node at (2.5,1.75+\value{y}/2) {\reg X};
                \draw[fill=cyan] (0,0+\value{y}/2) rectangle (2.5,1+\value{y}/2) rectangle (5,0+\value{y}/2);
                \node at ($(0,0+\value{y}/2)!.5!(2.5,1+\value{y}/2)$) {\reg H};
                \node at ($(5,0+\value{y}/2)!.5!(2.5,1+\value{y}/2)$) {\reg L};
                
                \addtocounter{y}{-11}
            }
            \foreach\reg in {SP,BP,SI,DI}
            {
                \draw[fill=cyan!25!white] (-10,-1.5+\value{y}/2) rectangle (5,3.5+\value{y}/2);
                \node at (-8,1+\value{y}/2) {R\reg};
                \draw[fill=cyan!50!white] (-5,-1+\value{y}/2) rectangle (5,3+\value{y}/2);
                \node at (-3,1+\value{y}/2) {E\reg};
                \draw[fill=cyan!75!white] (0,-.5+\value{y}/2) rectangle (5,2.5+\value{y}/2);
                \node at (2.5,1.75+\value{y}/2) {\reg};
                \draw[fill=cyan] (2.5,1+\value{y}/2) rectangle (5,0+\value{y}/2);
                \node at ($(5,0+\value{y}/2)!.5!(2.5,1+\value{y}/2)$) {\reg L};
                
                \addtocounter{y}{-11}
            }
            
            \setcounter{y}{0}
            \foreach\reg in {8,...,15}
            {
                \draw[fill=cyan!25!white] (5.5,-1.5+\value{y}/2) rectangle (20.5,3.5+\value{y}/2);
                \node at (7.5,1+\value{y}/2) {R\reg};
                \draw[fill=cyan!50!white] (10.5,-1+\value{y}/2) rectangle (20.5,3+\value{y}/2);
                \node at (12.5,1+\value{y}/2) {R\reg D};
                \draw[fill=cyan!75!white] (15.5,-.5+\value{y}/2) rectangle (20.5,2.5+\value{y}/2);
                \node at (18,1.75+\value{y}/2) {R\reg W};
                \draw[fill=cyan] (18,1+\value{y}/2) rectangle (20.5,0+\value{y}/2);
                \node at ($(20.5,0+\value{y}/2)!.5!(18,1+\value{y}/2)$) {R\reg B};
                
                \addtocounter{y}{-11}
            }
        \end{tikzpicture}
    \end{center}
    \subparagraph{Инструменты.}
    Чтобы увидеть, во что ваш компилятор превращает ваш код, пишите\\
    \mintinline{console}|g++ -S -masm=intel ...|, после чего вам создадут \mintinline{console}|.s| файл с ассемблерными командами. Или можно использовать \url{https://godbolt.org}, куда можно запихнуть разные компиляторы, параметры оптимизации и прочее, и сразу увидеть результат (причём понятнее, чем в \mintinline{console}|g++|). Ещё, кстати, на \url{https://godbolt.org} можно навести на команду и узнать информацию по ней. Если нужно больше информации~--- лезьте на \url{https://felixcloutier.com/x86/}.
    \subparagraph{Оптимизации компиляторов.}
    Если вы скомпилируете код вида \mintinline{c}|return a + b|, вы не увидите команду \mintinline{nasm}|ADD|, а увидите \mintinline{nasm}|LEA|. Эта инструкция расшифровывается как load effective address и делает следующее: \mintinline{nasm}|LEA| принимает на вход \mintinline{nasm}|LEA AX, [BX]|, но не читает адрес памяти с номером \mintinline{nasm}|BX|, а просто записывает значение \mintinline{nasm}|BX| в \mintinline{nasm}|AX|. И в x86 можно записать как адрес что-то такое: \mintinline{nasm}|[reg+1/2/4/8*reg+const]|, что позволяет написать \mintinline{nasm}|LEA AX [BX+CX]|, что будет быстрее, чем \mintinline{nasm}|ADD|+\mintinline{nasm}|MOV|.\\
    Ещё в x86 есть \mintinline{nasm}|SHL|/\mintinline{nasm}|SAL|~--- сдвиг влево, \mintinline{nasm}|SHR|~--- логический сдвиг вправо (оставляет на пустых местах нули), \mintinline{nasm}|SAR|~--- арифметический сдвиг справа (на пустые места пихает знаковый бит). В C++ для беззнаковых используется \mintinline{nasm}|SHL| и \mintinline{nasm}|SHR|, а для знаковых~--- \mintinline{nasm}|SAL| и \mintinline{nasm}|SAR|. Сдвиг используются также для быстрого умножения  и деления числа на степени двойки. Но даже для деления на прочие числа не всегда используется \mintinline{nasm}|DIV|. Например, результат компиляции \mintinline{c}|x / 3| содержит магический хак такого рода: вместо $\frac a3$ делают $\frac{a\cdot\frac{2^n}3}{2^n}$, и там подбирается $n$, чтобы работало. Много таких хаков можно почитать в книге Hacker's Delight.
    \subparagraph{Стек.}
    Зачем в процессоре стек? А вот зачем. Для глобальных переменных можно назначить фиксированный адрес памяти. Ну, правильно, а хуле. А с локальными переменными (и параметрами) такое не работает, потому что в программе может присутствовать рекурсия. К счастью, мы заходим и выходим в функции <<в порядке стека>> (то есть если мы зашли в первую функцию до второй, то выйдем сначала из второй, а потом~--- из первой), поэтому стек и используется. И процессор предоставляет вам интерфейс для работы с этим самым стеком. Самые простые команды~--- \mintinline{nasm}|PUSH| и \mintinline{nasm}|POP|. У нас есть регистр \mintinline{nasm}|RSP| (stack pointer), который показывает на вершину стека. Инструкция \mintinline{nasm}|PUSH| уменьшает этот адрес (вершина стека имеет наименьший адрес), после чего записывает по нему переданные данные, а \mintinline{nasm}|POP|~--- наоборот~--- сохраняет текущие данные, сдвигает \mintinline{nasm}|RSP| обратно и записывает эти данные по переданному ей адресу. Ещё есть инструкции \mintinline{nasm}|CALL| и \mintinline{nasm}|RET|~--- вызов и возврат из функции соответственно. Первая записывает адрес следующей инструкции после вызова в стек и делает \mintinline{nasm}|JMP| по адресу вызываемой функции, а вторая~--- берёт со стека адрес того, куда вернуться, после чего переходит по нему.\\
    Хорошо, вызывать функции мы научились, теперь нам хочется передавать в них параметры. Быстрее всего положить их в регистры (например, \mintinline{nasm}|EDI| и \mintinline{nasm}|ESI|). Но регистров у нас конечное число, поэтому если параметров много, то может не хватить. В таком случае параметры можно передавать через стек. И чтобы получить их, мы делаем \mintinline{nasm}|MOV RAX, [RSP+8]| или \mintinline{nasm}|MOV RAX [RSP+16]|. Но после возвращения из функции, у нас параметры всё ещё на стеке, надо исправить. Мы можем сделать две вещи. Можем сделать так, чтобы вызывающая функция почистила стек, прибавляя константу к \mintinline{nasm}|RSP| каждый раз. Но не лучше ли запихнуть это в вызываемую функцию? Ну, идейно да, но надо куда-то сохранить возвращаемое значение... В x86 вообще есть \mintinline{nasm}|RET n|, который берёт значение, сдвигает \mintinline{nasm}|RSP| на \mintinline{nasm}|n| и возвращается. Это называется <<вызываемая функция чистит стек>>. Осталось понять, что делать с локальными переменными? Ну, их можно положить выше на стек после адреса возврата.\\
    Хорошо, а кто определяет, как передавать параметры. В каких регистрах, в каком порядке на стеке, как возвращается результат, кто чистит стек и т.д. Процессору чисто поебать. А вот разработчикам компилятора надо бы договориться, как жить. Все эти соглашения~--- <<соглашения вызова функции>>. Исходно это определяет ОС~--- ОС компилируется неким компилятором, он что-то использует, а значит теперь ОС работает именно так. Windows в данном случае является исключением, потому что там есть много разных соглашений (cdecl, stdcall, thiscall, fastcall...). Чтобы полностью все их понять, открываете доку и читаете. Итак, кто чаще чистит стек? Вызывающая функция. Почему так, это же, вроде как, неудобно? Потому что variadic-функции. Когда вы делаете \mintinline{c}|printf|, компилятор просто пихает параметры на стек, а вызываемая в душе не ебёт, сколько их. Поэтому чистит вызывающая.\\
    Ещё есть такая штука как <<стековый фрейм>>. Вокруг тела функции пихаются команды \mintinline{nasm}|PUSH RBP|, \mintinline{nasm}|MOV RBP, RSP|, ..., \mintinline{nasm}|POP RBP|. Зачем это? Что делает этот код? Он сохраняет старое значение \mintinline{nasm}|RBP| на стек. А при вызове рекурсивной функции в \mintinline{nasm}|RBP| будет \mintinline{nasm}|RSP|. То есть во внутренней функции мы запихаем на стек адрес первой. И так далее. То есть на стеке есть односвязный список значений \mintinline{nasm}|RBP| от нового к старому. Поэтому пойдя по \mintinline{nasm}|RBP|, можем напечатать весь стек. Буквально так очень давно работали отладчики. В наше время этот режим менее актуален, поэтому генерировать эти инструкции~--- избыточно. Вместо этого компиляторы вместе с кодом генерируют отладочную информацию как раз о том, какие команды каким строкам кода соответствуют, как раскручивать стек и подобное. \mintinline{console}|gcc| генерирует стековый фрейм только с ключом \mintinline{console}|-g|. MSVC генерирует их по умолчанию. Возможно, это потому, что рандомная опубликованная exe'шка может в отладочных данных содержать секретики. Их вы публиковать не хотите, поэтому только стековые фреймы. К чему это всё для нас? Если вы пользуетесь какими-то инструментами, которые снимают стек (отладчик или профилировщик), убедитесь, что у вас есть отладочные символы, и дебажите вы тоже согласно им. Либо и то, и другое наоборот.\\
    А знаете ли вы, что будет, если засрать стек или целенаправленно сдвинуть \mintinline{nasm}|RSP| куда не надо (это же регистр общего назначения, никто же не мешает нам его изменить). Обычно после стека находится немного данных, которые помечены как те, в которые нельзя писать и которые читать. Если вы обратитесь туда, вам дадут прерывание, управление перейдёт ОС, ваша программа умрёт. А вот если вы уйдёте совсем далеко от стека, то вы пойдёте гулять по памяти, и вам никто не поможет.
    \paragraph{Взаимодействие разных программ.}
    В прошлый раз мы научились исполнять одну программу, но не научились делать абсолютно ничего, связанного с взаимодействием разных программ. И вообще совершенно не узнали ничего о том, как множество программ на вашем компе в принципе уживаются вместе.\\
    Пусть у вас есть программа:
    \begin{minted}{c++}
        int main()
        {
            for (;;)
                ;
        }
    \end{minted}
    Если мы посмотрим как это выглядит в ASM, то совершенно понятно, как метка и переход по ней же. В нашей предыдущей модели такая программа повесила бы процессор навсегда вообще. Но когда мы это запустим, такого не произойдёт, а значит есть что-то, что позволяет жить в таком случае.
    \subparagraph{Кратко о прерываниях.}
    Это что-то~--- прерываний в процессоре. Изначально они были созданы для того, чтобы устройства, которые, например, читают данные, сами оповещали процессор о том, что они дочитали, вместо того, чтобы он постоянно их сам спрашивал. С точки зрения программы это выглядит так: ОС её прерывает, выполняет что-то, после чего возобновляет выполнение там, где прервала.\\
    Если вам хочется посмотреть на прерывания, вам нужен файл \Verb|/proc/interrupts|. Там вы можете посмотреть, все типу прерываний с процессорами и описаниями. Например, при нажатии на кнопку и отжатии кнопки на клавиатуре посылается специальное прерывание, с тачпадом то же самое и т.п. Сейчас нас интересует local time interrupts~--- прерывания, которые можно запрограммировать по таймеру. При загрузке ОС она взводит их, чтобы мочь получать из программы управление назад. При этом она сохраняет куда-то состояние регистров остановленной программы, а при запуске её обратно~--- восстанавливает.\\
    При этом ждать, пока будет прерывание, Вы не можете (если вы не ядро; если ядро, у вам есть команда \mintinline{nasm}|HLT|, которая это и делает). Ядро ОС умеет усыплять ядра процессора, а изнутри программы мы это сделать не может~--- максимум вызвать что-то из ОС, что потом вас прервёт. Например, читать из stdin, где нет данных или делать sleep.
    \subparagraph{Работа с памятью (на самом деле).}
    Теперь давайте поговорим про второй вид ресурсов~--- память. Что будет, если мы возьмём рандомное число, кастанём его в \mintinline{c++}|char*|, после чего запишем по нему букву. Будет SEGFAULT. Что это такое вообще? Чтобы ответить на этот вопрос, надо понять, как в одной памяти живут программы. В процессоре есть механизм, который позволяет делать две вещи. Первая~--- виртуализация (для программы создаётся иллюзия, что вся память~--- её память). Вторая~--- изоляция программ друг от друга. То есть одна программа без разрешения не трогает данные другой. ОС использует эти функции, чтобы испортить чужие данные вы не могли.\\
    Хорошо, как конкретно это работает? В нашей прошлой модели память~--- пронумерованные ячейки. Мы будем называть \textit{физической памятью} то, что у нас в жизни в оперативке. Этот уровень недоступен даже ядру ОС, максимум можно догадываться, что там. Вместо этого когда вы обращаетесь к памяти, процессор этот адрес как-то преобразует (\textit{транслирует}) в физический адрес, по которому и обращается. У вас нет способов этого избежать, максимум (если вы в ядре)~--- слабо повлиять. И суть в том, что пересчёт разный для разных программ, поэтому в разных программах одно и то же число адреса~--- разные ячейки физ. памяти.\\
    Набор адресов физической памяти~--- \textit{физическое адресное пространство}, а то, что видит программа~--- \textit{виртуальная память}. На базовом уровне механизм в процессоре делает вот что: разделим физическую и виртуальную память на кусочки по 4 КБ, которые называют страницами. Процессор может настроить механизм так, чтобы произвольная страница виртуальной памяти транслировалась в произвольную физической. Этот механизм~--- \textit{механизм страничной адресации}. В принципе, ОС ничего не мешает сделать две страницы виртуальной памяти и направить их в одну страницу физической. Работать это будет так, как вы думаете. Если делать это из разных программ, они смогут общаться. Ещё мы можем запрещать какие-то страницы (помечая их как отсутствующая). То есть считается, что эта страница никуда не транслируется. Именно поэтому и происходят SEGFAULT'ы. Соответственно, процессор даёт эту информацию ОС, а она даёт программе sigsegv, sigbus или ещё чего.\\
    В 32-битных системах система страничной адресации основана на вот таких штуках:
    \begin{center}
        \begin{tikzpicture}[scale=.3]
            \draw[fill=white] (-31,-8) rectangle (-12,0);
            \node at (-21.5,-4) {Физический адрес страницы};
            \draw[fill=cyan!25!white] (-12,-8) rectangle (-9,0);
            \node at (-10.5,-4) {\rotatebox{-90}{Avail.}};
            \draw[fill=white] (-9,-8) rectangle (-8,0);
            \node at (-8.5,-4) {G};
            \draw[fill=cyan!25!white] (-8,-8) rectangle (-7,0);
            \node at (-7.5,-4) {0};
            \draw[fill=white] (-7,-8) rectangle (-6,0);
            \node at (-6.5,-4) {D};
            \draw[fill=cyan!25!white] (-6,-8) rectangle (-5,0);
            \node at (-5.5,-4) {A};
            \draw[fill=white] (-5,-8) rectangle (-4,0);
            \node at (-4.5,-4) {C};
            \draw[fill=cyan!25!white] (-4,-8) rectangle (-3,0);
            \node at (-3.5,-4) {W};
            \draw[fill=white] (-3,-8) rectangle (-2,0);
            \node at (-2.5,-4) {U};
            \draw[fill=cyan!25!white] (-2,-8) rectangle (-1,0);
            \node at (-1.5,-4) {R};
            \draw[fill=white] (-1,-8) rectangle (0,0);
            \node at (-.5,-4) {P};
            \node[scale=.75] at (-31, .5) {31};
            \node[scale=.75] at (-11.5, .5) {11};
            \node[scale=.75] at (-9.5, .5) {9};
            \node[scale=.75] at (0, .5) {0};
        \end{tikzpicture}
    \end{center}
    Сначала адрес, затем разные флаги. Например, R~--- read only или нет. W~--- write through~--- про кеширование, прочие флаги содержат другие данные для ОС. В 64-битных то же самое, но адрес побольше, и сама структура занимает больше бит. Такие структуры хранятся в памяти в сложной структуре в виде дерева. Как конкретно? Если подойти наивно, то получится набор страниц, для каждой храним 32-битное число. То есть имеем массив таких структурок. Это работает, но имеет одну проблему: в 32-битном режиме имеем 4ГБ памяти, то есть нужно 4МБ памяти на процесс. Это до жопы, особенно учитывая то, что в древности 4МБ~--- это типовой размер был. А в наше время в 64-битном режиме на одну программу понадобится 32ПБ. Поэтому заметили вот что. Большая часть программ используют меньше 4ГБ памяти. А значит б\'{о}льшая часть страниц недоступна. Поэтому давайте вместо 1048576 элементов хранить 1024*1024 (\textit{таблица страниц}). И мы можем просто в изначальном массиве на 1024 элемента поставить недоступность, чтобы пометить недоступным сразу много страниц. Хорошо, а как корень дерева найти? Для этого есть специальный регистр CR3, который и переключается при смене исполняемой программы.
    \begin{center}
        \includegraphics[scale=.35]{Images/Таблица_страниц.png}
    \end{center}
    То есть процессор смотрит на CR3, получает массив структурок. Берёт старшие 10 бит адреса, идёт в этот массив и берёт нужную оттуда. Там есть адрес, по которому можно получить следующий массив. Со следующими 10 битами идёт в нужный элемент второго массива, где берёт требуемую страницу. Остаток адреса означает, какой байт в этой странице надо взять.\\
    А что в 64-битном режиме? Там виртуальный адрес сильно больше (64 бита, собственно). Ещё изменение~--- больше физической памяти. Размер структурки также удваивается, а значит структурок в одном массиве теперь 512, а не 1024. То есть адрес мы уже делим на кусочки по 9 бит, а не по 10. Но даже в 3 уровня останется куча лишних битов. Тогда <<лишние>> биты должны совпадать со старшим не-лишним. Имеем по сути 39-битный виртуальный адрес. Современные процессоры уже и 4 уровня поддерживают, что даёт нам 48 бит. А самые новые intel'овские процессоры дают нам 5 уровней и 57 битов (127 ПБ можно адресовать).\\
    Как это используется ОС? Чтобы раздавать память~--- понятно, но из интересного есть memory-mapped файлы (дай мне в память файл, и теперь когда вы туда обращаетесь, вам дают иллюзию, что вы тупа обращаетесь в этот файл). Преимущество этого~--- ОС читает только те страницы, которые вам нужны. Второе преимущество~--- если несколько программ так сделали, вы можете переиспользовать физическую память (то есть всем давать один и тот же кусочек памяти, совсем одинаковый). Так, файл в 2 ГБ будет исполняться мгновенно, потому что ОС mapp'ит файл в память, а подчитывает всё нужное потом. Ещё с memory-mapped связано то, что вы можете mapp'ить то, что больше памяти. Тогда ОС просто будет читать с диска заново то, что не помещается.\\
    Ещё из интересного есть уже обсуждённая разделяемая память. Это самая низкоуровневая вещь для взаимодействия программ. А вообще есть, например, PIPE'ы, реализованные на базе разделяемой памяти.\\
    Интересный вопрос: можете ли вы зажрать больше памяти, чем есть? Как ни странно, да, тогда ОС создаст файл подкачки (swap) на жёстком диске, где и будет хранить память. Процессор об этом ничего не знает, если что.\\
    Ещё есть механизм copy-on-write~--- это вот что. Обычно недостаточно просто дать программе управление и всё. А ещё бывает нужно исправить то, что мы загрузили. То есть формально файл не совсем такой, как прочитано. Тогда при записи мы делаем копию памяти, а то, что не менялось~--- переиспользуем.
    \paragraph{Уточнение модели процессора.}
    Прошлые разы поговорили об одной программе, о нескольких программах, одну программу мы даже написали, а сегодня поговорим о том, какие операции процессора дорогие, а какие~--- дешёвые. Потому что нам надо знать, как оптимизировать программы. Скорее всего, наш код, если переписать его в плюсы, а потом скомпилировать, то результат будет оптимальнее. У нас и не было цели сделать быстро, но всё же. И сегодня мы поговорим о различных интересных аспектах процессора.\\
    Если мы занимаемся оптимизацией, то какие-нибудь высокоуровневые оптимизации (когда что-то считается много раз, например) мы можем сделать легко, а на более низком уровне придётся знать поднаготную процессоров, потому что там всё работает не так уж интуитивно.\\
    Мы рассмотрим несколько примеров, которые в нашу текущую модель не укладываются вообще, разберёмся в них и уточним модель. При этом мы не стремимся получить максимальную детализацию модели. Во-первых, если у нас есть эффект, дающий нам 0.01\%, он нам не очень критичен. Во-вторых, чтобы анализировать и делать выводы, нам придётся нашу модель сделать проще. Физики вон, упрощают реальный мир, чтобы делать свои предсказания.\\
    Сначала разберёмся, о каких процессорах мы будем говорить. Ответ~--- в каком-то смысле про все современные (последние 17 лет) процессоры. Причём вне зависимости от архитектуры. И это не заговор разработчиков, а в течение 40 лет все думали, как процессоры сделать быстрее и энергоэффективнее, и то, что оптимизации поддавалось, то оптимизировали. А то, что поддавалось оптимизации сложно, то оставалось медленным. Например, операция деления занимает много больше времени, чем, скажем, сложение. И это не потому, что разработчики процессоров дураки или лентяи, а потому что есть внутренняя сложность в операции деления.
    \subparagraph{Кэш.}
    Начнём с совсем простой модели: процессор делает инструкции одну за другой, время работы пропорциональна их количеству. Это, на самом деле, далеко не самая плохая модель, но она имеет ошибку на таком примере:
    \begin{multicols}{2}
    \begin{minted}{c}
        for (size_t i = 0; i < N; ++i)
            for (size_t j = 0; j < N; ++j)
                a[i][j] = 0;
    \end{minted}
    \columnbreak
    \begin{minted}{c}
        for (size_t i = 0; i < N; ++i)
            for (size_t j = 0; j < N; ++j)
                a[j][i] = 0;
    \end{minted}
    \end{multicols}\noindent
    Разница в этих примерах будет очень большая (второй медленнее), из-за причин, обсужденных в курсе АрхЭВМ. Если посчитать зависимость среднего времени одного присваивания в зависимости от \mintinline{c}|N|. Это \textbf{не} объясняется специальными инструкциями процессора, который обращается в несколько ячеек последовательно за раз, потому что мы можем написать то же самое на ASM, результат будет тот же. А дело, как мы знаем, в процессорном кэше.\\
    Зачем существует кэш вообще? Как мы знаем, согласно закону Мура, мощность процессоров от времени зависит экспоненциально. Так вот памяти~--- тоже. Но скорость памяти растёт сильно медленнее (сейчас процессор делает по 4 операции за такт, а обращение к памяти занимает 200+).
    \begin{center}
        \includegraphics[scale=.55]{Images/CPU and memory performance over time.png}
    \end{center}
    Это никуда вообще не годится, поэтому на процессорах появились кэши. Занимают они чуть ли не половину кристалла, и так было что в пентиумах, что во всех современных процессорах. Типовое время обращения к памяти~--- 4, 12, 36 и 230 тактов для L1, L2, L3 и RAM соответственно. Поэтому сначала надо оптимизировать данные, а уже потом код.
    \subparagraph{Префетчинг.}
    Префетчинг~--- это метод, при помощи которого заранее определяется, к каким областям памяти в будущем пойдут обращения. Осуществляется это, например, при помощи улавливания последовательных обращений к памяти (если вы сначала обращаетесь к первой ячейке, а потом~--- ко второй, то можно заранее начать обращение к третьей, вдруг вы туда обратитесь). В современных процессорах есть аж целых 4 разных префетчера, два для L1 и по одному для L2 и L3. Идейно префетчинг позволяет тратить ресурсы процессора на то, чтобы ускорять память, что полезно всё по той же причине~--- память медленнее.
    \subparagraph{Промежуточные выводы касательно памяти.}
    Касательно памяти есть следующие практики:
    \begin{itemize}
        \item Иногда выгоднее будет что-то пересчитать, чем хранить всё в памяти (процессор быстрее же).
        \item Если вы знаете, в каком порядке вы будете обращаться к данным, важно правильно их положить (тоже последовательно).
        \item Хранить <<горячие>> и <<холодные>> данные нужно в разных местах. <<Горячие>>~--- это которые вам часто нужны, <<холодные>>~--- которые не очень. Почему в разных? Потому что иначе у вас в кэше будут лежать и <<горячие>>, и <<холодные>> данные, вместо того, чтобы забить его <<горячими>> полностью.
    \end{itemize}
    Как, например, правильно реализовать хэш-таблицу с открытой адресацией? Мы можем хранить всё парами из ключа и значения, а можно~--- сначала все ключи, а потом все значения. А вот что лучше, зависит от hit rate'а нашей таблицы. Если мы чаще находим значения, мы смотрим на ключ, и берём значение, которое рядом с ним, удобно. А если мы редко их находим, то мы ведь долго бежим чисто по ключам, а значит нам выгоднее будет сохранить их вместе.\\
    Ещё ст\'{о}ит избегать непрямых обращений к памяти, потому что обращение по рандомному указателю~--- это, здравствуйте, промах по кэшу. Вместо этого можно просто заменить этот указатель на сами данные. С другой же стороны, если у вас указатель на <<холодные>> данные есть в <<горячих>>, то тупо вставлять эти данные внутрь не очень выгодно~--- как уже было сказано <<горячие>> и <<холодные>> надо бы хранить в разных местах.
    \subparagraph{Отступление про указатели.}
    Что ещё можно сказать про указатели? А то что ваша программа процентов на 80 состоит из них. Так, \mintinline{c++}|std::vector|~--- это три указателя, \mintinline{c++}|std::list|~--- два указателя и одно число размером с указатель, \mintinline{c++}|std::set| и \mintinline{c++}|std::map|~--- один указатель и одно число. При этом указатели на x86-64 здоровые, 64 бита занимают. А ведь вам обычно не нужны 64-битные указатели, вам хватит и 32 бит, а значит памяти они занимают вдвое больше, чем могли бы. Поэтому Intel сделали ABI x32. Для ОС это выглядит как 64-битная программа, но внутри она имеет 32-битные указатели. Во всём остальном она \sout{верблюд} x86-64. Конвенции вызова там точно такие же, вещественная арифметика~--- тоже, количество регистров~--- 15 целочисленных и 16 вещественных. К сожалению, этот ABI не очень прижился, что довольно грустно. Но что интересно, на целочисленных тестах x32 было на 5--8\% быстрее, чем x86-64 (просто из-за того, что данных меньше), на дробных данных разницы нет, а на одном специфичном бенчмарке (там просто куча указателей) ускорение достигало 40\%. А в сравнении с x86, ускорение было соответственно в 7--10\% и 5--11\% для целых и дробных тестах, а специфичный бенчмарк был с 64-битной арифметикой (и тоже имел 40\% ускорение).
    \subparagraph{Ускорение трансляции адресов.}
    Давайте вспомним про виртуальную память. Имея нашу древовидную структуру, на каждое обращение к памяти в программе нам придётся делать 4 (или 5, если уровней 4) обращения в память внутри процессора (чтобы пройтись по дереву). Это треш, поэтому результат трансляции виртуальной памяти в физическую также кэшируется. Буфер, в который кэшируется, называется TLB (translation lookaside buffer). А значит это всё, что если наша программа обращается к реально большому объёму памяти, то мы платим не только за этот факт сам по себе, но и за трансляцию.\\
    Что ещё может улучшить сию неприятную ситуацию с трансляцией? Страницы по 4 KB достаточно маленькие, и заниматься администрированием их довольно накладно. Поэтому в процессоре есть механизм Huge Pages, который позволяет нам на промежуточном уровнем дерева установить специальный бит, который говорит, что этот промежуточный элемент хранит не ссылку на следующий, а сразу страницу данных.
    \begin{center}
        \includegraphics[scale=0.55]{Images/Huge pages.png}
    \end{center}
    И тогда страница будет иметь размер 2 MB, если брать предпоследний уровень или вообще 1 GB, если третий снизу. Это экономит и время трансляции, и место в TLB.
    \paragraph{Выделение памяти ядром.}
    Как мы помним, выделение памяти из ядра осуществляется при помощи \mintinline{c}|mmap|. Можно заметить интересный эффект: если мы просто делаем выделение памяти кучу раз, это будет относительно быстро, а когда мы начнём к выделенной памяти обращаться, ты мы зависнем надолго. Почему так? Точнее на вопрос <<почему>> ответ простой~--- потому что ОС даёт нам память только тогда, когда мы её используем, а вот <<зачем>>~--- интересный вопрос. Дело в том, что обычно у нас нет свободной оперативной памяти, она вся либо отдана другим программам, либо используется как дисковый кэш. Поэтому когда кто-то просит память, вам придётся сбрасывать дисковый кэш, либо выгружать кого-то в swap-файлы. А если вдруг ваша программа будет использовать выделенную память как-то потом (или не будет вообще), то давать ей память сразу невыгодно, поэтому ОС даёт её при обращении и маленькими кусочками (ведь используете вы маленькими кусочками, а \mintinline{c}|mmap| выделяет сразу кучу памяти).\\
    Кстати, в \mintinline{c}|mmap| есть специальный флаг (\mintinline{c}|MAP_POPULATE|), который заставляет выделять память сразу. При этом, если сделать так, то работать это будет быстрее, чем если выделить память обычным образом, а потом к ней пообращаться, потому что с флагом не будет происходить множество переходов между userspace'ос и ОС при каждом обращении.\\
    Хорошо, а что в \mintinline{c}|mmap| занимает больше всего времени? А обнуление выделенной страницы. Зачем? А вдруг там кто-то криптографию оставил. Кто-то, кого вы только что убили, например. Но вообще под это тоже есть специальный флажок \mintinline{c}|MAP_UNINITIALIZED| (но только для анонимных страниц, правда), который был создан специально для миниатюрных устройств. И работает он только в том случае, если ОС была собрана специальным образом. Если, кстати, делать \mintinline{c}|mmap| без флага \mintinline{c}|MAP_POPULATE|, то ещё больше времени, чем на зануление, будет тратиться на передачу обращения между ОС и userspace'ом.
    \paragraph{Продолжаем уточнять модель процессора.}
    Теперь мы поговорим о чуть менее затратных вещах (которые дают накладные расходы меньше 200 тактов).
    \subparagraph{Branch prediction.}
    Мы уже давно знаем о том, что эффективность условного перехода зависит от того, насколько хорошо он предсказывается. Это даёт расходы в 14--19 тактов. Отсюда хочется писать код без условных переходов. Для этого рассмотрим пример с делением на 2. Деление на 2 нельзя сделать арифметическим сдвигом, потому что округление идёт не туда. И вообще, можно было это за\mintinline{c}|if|ать, но условие~--- это вроде как плохо, вместо этого компилятор хитрит и делает несколько арифметических операций, которые по сути делают то же самое, что делал бы условный переход.\\
    Касательно предсказаний, процессор умеет предсказывать много различных паттернов, поэтому искусственно составить что-то, что будет сложно предсказываться, довольно проблемно. Но это не единственное, что процессор умеет. Давайте рассмотрим генератор случайных битов, который называется линейный регистр сдвига с обратной связью. (Раз биты случайные, то предсказываться должно просто отвратительно.) Он работает примерно так:
    \begin{minted}{c}
        unsigned lfsr = 0xace1;
        for (unsigned i = 0; i != 1000000000; i++)
        {
            unsigned lsb = lfsr & 1;
            lfsr >>= 1;
            if (lsb)
                lfsr ^= 0xb400;
        }
    \end{minted}
    Его можно написать без условия двумя способами:
    \begin{multicols}{2}
    \begin{minted}{c}
        unsigned lfsr = 0xace1;
        for (unsigned i = 0; i != 1000000000; i++)
        {
            unsigned lsb = lfsr & 1;
            lfsr >>= 1;
            lfsr ^= 0xb400 * lsb;
        }
    \end{minted}
    \columnbreak
    \begin{minted}{c}
        unsigned lfsr = 0xace1;
        for (unsigned i = 0; i != 1000000000; i++)
        {
            unsigned lsb = lfsr & 1;
            lfsr >>= 1;
            lfsr ^= 0xb400 & -lsb;
        }
    \end{minted}
    \end{multicols}
    Если сравнить время работы этих программ, то они будут отличаться так, как ожидается (первая самая долгая, третья~--- самая быстрая), но ненамного. А ещё, если проанализировать программу какими-нибудь прошаренными средствами, то можно заметить, что неверные предсказания дают нам 0.01\% от всех предсказаний. А дело в том, что компилятор породил инструкцию \mintinline{nasm}|CMOVNE|, которая является условным переходом без условного перехода. Компилятор просто посчитал обе ветки и решил, что нам нужна вот эта специальная инструкция, которая делает \mintinline{nasm}|MOV|, но только если не установлен Z флаг. Очень удобно, что процессор умеет вот в такие штуки.\\
    Хорошо, но всё же что будет, если правда сделать условный переход? Для этого компилятору надо дать ключи \mintinline{console}|-fno-if-conversion -fno-if-conversion2|, которые заставят его не использовать эту ебейшую инструкцию, и вот тогда уже всё замедлится намного сильнее.\\
    Что ещё нужно знать? Ещё нужно знать, почему такой код
    \begin{minted}{c}
        for (size_t c = 0; c < size; c++)
            if (data[c] >= 128)
                sum += data[c]
    \end{minted}
    работает быстрее, если предварительно отсортировать массив. Ну, тоже потому что предсказание перехода. Если данные случайны, то переход случайно происходит, его не предскажешь. А в отсортированных данных вы сначала всегда не переходите, а потом всегда переходите.
    \subparagraph{Спекулятивное взаимодействие с памятью.}
    У нас есть чтения и записи. По-хорошему, нельзя читать до того, как закончат выполняться записи, потому что в случае, если мы читаем то, что писали, хочется прочитать то, что записано, а не что-то левое. Но процессор выполняет операции спекулятивно, в надежде на отсутствие коллизий. Поэтому код
    \begin{minted}{c}
        uint32_t count[256] = {};
        
        for (size_t i = 0; i < size; i++)
            ++count[src[i]];
    \end{minted}
    Будет работать тем быстрее, чем более разные данные в \mintinline{c}|src| (если данные одинаковые, процессор спекулятивно запускает несколько инкрементов за раз, потом понимает, что они инкрементят одно и то же и откатывает все, кроме одного; в результате не только простаивает superscalar, но и происходят откаты туда-обратно). Чтобы это пофиксить, придётся делать так:
    \begin{minted}{c}
        uint32_t count[8][256] = {};
        
        size = size / 8 * 8;
        for (size_t i = 0; i < size;)
        {
            ++count[0][src[i++]];
            ++count[1][src[i++]];
            ++count[2][src[i++]];
            ++count[3][src[i++]];
            ++count[4][src[i++]];
            ++count[5][src[i++]];
            ++count[6][src[i++]];
            ++count[7][src[i++]];
        }
    \end{minted}
    \paragraph{Ссылки.}
    Подробнее про это все хаки и финты можно почитать в двух книжках: J. Shen, M. Lispasti~--- Modern Processor Design: Fundamentals of Superscalar Processors и J. Hennessy, D. Patterson~--- Compiuter Architecture: A Quantitative Approach. Они сильно выходят за рамки нашего курса, но тем не менее интересны.
    \section{Введение в C.}
    Раньше мы разговаривали про какие-то ассемблерные штуки и познакомились с тем, как (упрощённо) работает компьютер. Это раздел кончился, и мы начнём говорить про C++. И начнём мы с базовых вещей, которые появились в C. И вообще текущая тема может быть также названа введением в C++. Однако C и C++~--- это разные языки: во-первых, их разрабатывают разные люди с разными целями. Во-вторых, они имеют разные компиляторы, несмотря на то, что обычно компании, имеющие компиляторы C++ также имеют компилятор C. Эти компиляторы имеют общий код, но они всё же не одинаковы~--- этот самый общий код также используется и для Go, и для D, и для Ada... Правда, clang является исключением из этого правила, там просто \mintinline{c}|if|'ами различаются C и C++. Правда, там ещё и Objective-C и нечто ещё. В-третьих, стили программирования на C и C++ кардинально отличаются, если вы пишете на них одинаково, вы дурачок. А в-четвёртых, C не является подмножеством C++, случайная программа на C вообще не факт что будет корректна в C++. Правда, обычно придётся менять её не очень сильно. Примером такого отличия является код вида \mintinline{c}|a ? b : c = 42|. В C~--- это \mintinline{c}|(a ? b : c) = 42|, а в C++~--- \mintinline{c}|a ? b : (c = 42)|.\\
    Так вот, у нас всё будет обсуждаться в терминах C++: в местах отличий мы не будем обсуждать оба языка. Поправка по курсу. Считается, что мы знаем, что такое переменная, как вообще всё живётся, а обсуждать будет то, о чём либо редко говорят, либо о том, что специфично для C/C++.
    \paragraph{Типы данных.}
    \subparagraph{Целочисленные типы.}
    Объявление целочисленного типа~--- знаковость, размер и слово \mintinline{c}|int|. При этом всё из этого можно опустить, по умолчанию считается обычный размер и \mintinline{c}|signed|. Знаковость~--- \mintinline{c}|signed| и \mintinline{c}|unsigned|, размер~--- \mintinline{c}|short|, размер по-умолчанию, \mintinline{c}|long| и \mintinline{c}|long long|.\\
    Ещё есть символы. \mintinline{c}|char|, \mintinline{c}|unsigned char| и \mintinline{c}|signed char|. И это три разных типа. Да, это правда, что \mintinline{c}|char| по диапазону значений совпадает с одним из остальных двух, но типы это разные.\\
    Кстати, как проверить, что два типа~--- это одно и то же? Можно определить перегрузку функции \mintinline{c}|void f(int)| и \mintinline{c}|void f(signed int)|, и тут будет ошибка компиляции, потому что \mintinline{c}|int| и \mintinline{c}|signed int|~--- одно и то же. А вот если написать
    \begin{minted}{c}
        void f(char)
        {}
        
        void f(signed char)
        {}
        
        void f(unsigned char)
        {}
    \end{minted}
    То это будет исправно компилироваться.\\
    Хорошо, мы уже поговорили, что есть 4 разных размера. А какого они размера в байтах? А вот хрен знает. Вообще в стандарте не специфицировано, там лишь написано, какой минимальный размер они имеют и кто меньше кого. На практике же можно встретить не так много вариантов. На 32-битных системах размеры~--- 1/2/4/4/8 байт, на 64-битном Windows~--- тоже, а на 64-битном Linux~--- 1/2/4/8/8. Разумеется, вы можете найти экзотическую архитектуру, где значения будут другими, поэтому не надо никак опираться на данные, которые вы тут видите. Если вам чётко 2 байта, вам придётся брать заголовочный файл \mintinline{c++}|<cstdint>| и брать оттуда типы \mintinline{c++}|int8_t|, \mintinline{c++}|uint8_t|, \mintinline{c++}|int16_t|, \mintinline{c++}|uint16_t| и подобные прочие. Разумеется, сам этот заголовок делает \mintinline{c}|typedef|'ы на базовые типы, но на какие именно~--- вы никогда не знаете.\\
    Хорошо, а как жить в таком коде?
    \begin{minted}{c}
        for (??? i = 0; i < 100; i++)
            arr[i] = 42;
    \end{minted}
    Какого типа должно быть \mintinline{c}|i|? Для этого есть специальный тип~--- \mintinline{c}|size_t|, который необходим и достаточен для обращения в память. Если вы будете брать тип фиксированной длины больше, чем \mintinline{c}|size_t|~--- будет немного медленнее, а если меньше~--- то может не хватить для адресного пространства. К тому же компилятор может немного хуже оптимизировать код, если вы используете битность меньше \mintinline{c}|size_t|. У \mintinline{c}|size_t| есть знаковый аналог~--- \mintinline{c}|ptrdiff_t|~--- это результат разности двух указателей.\\
    Как выбрать тип для переменной? Если вы получаете значение как возврат функции, то не выёживайтесь и пишите то, что написано в библиотеке, вне зависимости от того, что там, даже если какой-нибудь \mintinline{c}|DWORD_PTR|. В противном случае проверьте, не считаете ли вы объекты в памяти, или не является ли у вас ваша переменная индексом массива. Если да~--- то берёте \mintinline{c}|size_t| или \mintinline{c}|ptrdiff_t|. Если же это тоже не так, то берёте тип фиксированного размера в зависимости от предметной области. Это алгоритм не полон, и мы ещё поговорим о нём. Например, что делать, если вам нужно перечислить все типы (например, вы пишете свой \mintinline{c++}|std::numeric_limits|)? Тут уж придётся перечислять все 11 типов языка (а не 8 фиксированной битности).
    \subparagraph{Перечисляемый тип.}
    Самым простым составным типом является перечисляемый тип. В C++ мы будем использовать только строгий их вариант~--- \mintinline{c++}|enum class|. Это кто? Это перечисление набора вариантов. Зачем это используется? Ну, вместо этого можно использовать константы, но \mintinline{c++}|enum class| безопаснее (в него сложно присвоить то, чего в нём нет), понятнее (если в функцию передаётся три разных \mintinline{c++}|int|'а, то вы легко их перепутаете, а перепутать три разных перечисляемых типа вам не дадут). А ещё когда пишутся константы, не видно, что они как-то связаны, а в \mintinline{c++}|enum class|'е явно видно, что <<вот эти штуки>>~--- они вместе. Изнутри \mintinline{c++}|enum class|~--- это просто \mintinline{c++}|int|, причём вы можете ещё и явно указать, какой конкретно \mintinline{c++}|int| при помощи такой конструкции:
    \begin{minted}{c++}
        enum class color : uint16_t
        {
            red,
            green,
            blue
        };
    \end{minted}
    Но арифметика с перечисляемыми типами (строгими) не работает.
    \subparagraph{Структура.}
    Следующая вещь~--- структура. Это способ сгруппировать набор данных в одну сущность. Этим прям надо пользоваться, не надо таскать в разные места несгруппированные данные. Иначе ваш код раздувается до невероятных размеров и вообще обретает форму спагетти. А ещё вы увеличиваете вероятность ошибиться.\\
    Поговорим ещё о том, как структуры лежат в памяти. Если мы сделаем структуру
    \begin{minted}{c++}
        struct point
        {
            int x, y, z;
        };
    \end{minted}
    То у вас эта штука занимает 12 байт, первые 4~--- это \mintinline{c++}|x|, следующие~--- \mintinline{c++}|y|, последние~--- \mintinline{c++}|z|. А сколько памяти занимает
    \begin{minted}{c++}
        struct mytype
        {
            char a;
            int b;
        };
    \end{minted}
    А вот не 5, а 8. Это связано с тем, что процессоры либо не умеют, либо плохо читают N байт, адрес начала которых не делится на N (это называется невыравненное обращение к памяти). Поэтому компиляторы стараются располагать структуры так, чтобы данные в них были выравнены. В нашем случае в структуре есть один байт под \mintinline{c++}|a|, три пустых байта и ещё 4 байта под \mintinline{c++}|b|. Хорошо, давайте поправим данный пример:
    \begin{minted}{c++}
        struct mytype
        {
            int b;
            char a;
        };
    \end{minted}
    Тут будет 5? Нет, не будет, потому что вы можете сделать массив таких структур, и тогда во всех, кроме первой \mintinline{c++}|b| будет не выравнен. Поэтому всё равно 8.
    \subparagraph{Объединение.}
    У нас есть тип, которых хранит первое, \textbf{И} второе, \textbf{И} третье. А что, если мы хотим хранить строго одно из нескольких значений? Специально для этого есть тип \mintinline{c++}|union|, который этим и занимается. Пока \mintinline{c++}|struct| хранит следующее поле по смещению относительно предыдущего, у \mintinline{c++}|union|'а всё хранится по одному смещению. \textbf{Важно}: никакой информации о том, что хранит, \mintinline{c++}|union| не знает. Если вас это устраивает, вас это устраивает, а иначе вам нужно связать \mintinline{c++}|union| с \mintinline{c++}|enum class| в одну структуру (иначе undefined behaviour). \sout{И называется она \mintinline{c++}|std::variant|.} Пример использования такого~--- вы хотите у себя сохранить команду процессора на x86. Тогда у вам команда \mintinline{nasm}|MOV| может иметь своим вторым аргументом либо число, либо регистр.
    \subparagraph{Указатели и массивы.}
    Об указателях можно думать как о числах хранящих адрес ячейки памяти. Пишутся они так: \mintinline{c++}|type* p;|. И с ними есть две интересные операции: разыменование и взятие адреса. Взятие адреса~--- это \mintinline{c++}|&a|, разыменование по указателю дают значение в данной ячейке. Когда мы делаем указатель на структуру и хотим обратиться к полю \mintinline{c++}|y|, мы делаем \mintinline{c++}|(*p).y|, что имеет более короткую форму \mintinline{c++}|p->y|.\\
    Массивы~--- это \mintinline{c++}|std::array<type, size> arr|. Обращаются к нему по квадратным скобкам (\mintinline{c++}|arr[24] = '0'|). Ещё у него есть возможность взять указатель на первых элемент (\mintinline{c++}|arr.data()|), что используется для арифметики указателей. То есть мы можем делать что-то такое:
    \begin{minted}{c++}
        int* p = arr.data();
        p++;
    \end{minted}
    И теперь \mintinline{c++}|p| указывает на следующих элемент массива. Вообще с указателями можно делать вот какие операции: их можно складывать с числами, вычитать числа из них (в.т.ч. при помощи инкрементов и декрементов), а ещё можно брать разность указателей. Результат будет иметь тип \mintinline{c++}|ptrdiff_t| и равен количеству элементов между указателями. Ещё по указателями можно обращаться по квадратным скобкам и тогда выражение \mintinline{c++}|p[ind]| равносильно \mintinline{c++}|*(p + ind)|.\\
    Ещё про массивы можно сказать, что обычно нам ст\'{о}ит использовать \mintinline{c++}|std::array|, а не встроенные массивы из C (которые \mintinline{c++}|type arr[size]|), ведь те во всех планах хуже:
    \begin{enumerate}
        \item Массивы неявно конвертируются в указатели (что вызывает путаницу с тем, являются ли указатели и массивы одним и тем же или нет).
        \item Встроенные массивы нельзя копировать (поэтому нельзя их в функцию передавать, например).
        \item А если вы напишете массив в параметре функции, то он тоже неявно конвертируется в указатель.
    \end{enumerate}
    Ещё в массивах из C есть вопрос с тем, что \mintinline{c++}|int* a[10]|~--- это кто такой? Это массив указателей или указатель на массив? Первое. Второе~--- это \mintinline{c++}|int (*a)[10]|. В общем случае суффиксные деклараторы имеют б\'{о}льший приоритет, чем префиксные (т.е. это в первую очередь массив \textit{чего-то}, а во-вторую~--- \textit{что-то} это указатели). Ровно также работает их использование: если вы пишете выражение \mintinline{c++}|x = *a[1];|, то у вас сначала будет обращение к первому элементу, а потом его разыменовывание. Но вообще люди обычно не пишут все эти скобки, а пишут что-то такое:
    \begin{minted}{c++}
        typedef int type[10];
        type* a;
    \end{minted}
    Вместо \mintinline{c++}|int (*a)[10];|. Хорошо, если мы хотим завести себе \mintinline{c++}|typedef|, который будет являться типом переменной \mintinline{c++}|int ***(***a[10][20][30])[40][50][60];|. Как это сделать? Да элементарно,\\
    \mintinline{c++}|typedef int ***(***type[10][20][30])[40][50][60];|. То есть никакой разницы, переменную вы объявляете или \mintinline{c++}|typedef| делаете.\\
    Ещё хороший составной тип в данном контексте~--- указатель на функцию. В ASM можно делать что-то такое:
    \begin{minted}{nasm}
        mov rbx, func
        ...
        call rbx
    \end{minted}
    То есть вы где-то запомнили адрес функции, а потом этот адрес вызываете. В C и C++ это делается так:
    \begin{minted}{c++}
        void func(int)
        {}
        
        void main()
        {
            void (*a)(int) = &func;
            (*p)(42);
        }
    \end{minted}
    Это можно использовать для полиморфного поведения. Ещё ст\'{о}ит сказать, что указатель на функцию можно вызвать. И более того, функции неявно преобразуются в указатели на себя. Поэтому точно такой же код можно написать так:
    \begin{minted}{c++}
        void func(int)
        {}
        
        void main()
        {
            void (*a)(int) = func;
            p(42);
        }
    \end{minted}
    И вот указатели на функции подчиняются тем же правилам приоритета, что массивы и указатели. При этом считаются суффиксными.\\
    Следующий ужас, который мы можем увидеть~--- функция, возвращающая указатель на функцию. Это выглядит так: \mintinline{c++}|void (*get_function())(int)|. То есть это как объявление указателя на функцию, но с круглыми скобками после имени (это же не сам указатель, а функция, возвращающая его). То есть возвращаемое значение пишется не слева от функции, а вокруг. Хотя на практике с таким не встречаются, а делают \mintinline{c++}|typedef|.
    \paragraph{Rvalue, lvalue и их друзья.}
    Понятно, что мы не можем написать что-то типа \mintinline{c++}|2 + 2 = 7|, хотя и слева, и справа~--- \mintinline{c++}|int|. Но всё же, почему конкретно, как это в языке работает? А вот так. У нас глобально есть rvalue и lvalue. Первое может стоять справа от оператора присваивания, второе~--- может слева. Ещё обычно у lvalue можно взять адрес, а у rvalue (обычно) нельзя. Пример этого~--- \mintinline{c++}|a++| и \mintinline{c++}|++a|. Первый~--- rvalue, второй~--- lvalue. Поэтому написать \mintinline{c++}|++++a| можно, а \mintinline{c++}|a++++|~--- нет. А вот \mintinline{c++}|++a++| интерпретируется как \mintinline{c++}|++(a++)|, поэтому тоже некорректно (суффиксные операторы имеют больший приоритет, напомню). Хорошо, дальше интереснее. Что такое \mintinline{c++}|+++a|? Ну, сначала надо сказать, что это \mintinline{c++}|++(+a)|, потому что лексер разбивает на токены жадно (поэтому \mintinline{c++}|a++++b|) не сработает, несмотря на то, что существует способ распарсить это корректно. Ещё проговорим про такое: \mintinline{c++}|a = 5 = 6|. Это некорректно, потому что равенство правоассоциативно (т.е. такая штука парсится в \mintinline{c++}|x = (5 = 6)|), в отличие от остальных операторов. Но если мы напишем \mintinline{c++}|(x = 5) = 6|, то будет бессмысленно, но корректно. Потому что \mintinline{c++}|x = 5|~--- lvalue (присваивание возвращает левый операнд). Чуть менее бессмысленно это выглядит вот в таком варианте \mintinline{c++}|(x += 5) += 6|. Давайте дальше в примеры lvalue и rvalue. Что вот тут: \mintinline{c++}|& &a|? \mintinline{c++}|&a|~--- это rvalue, увы.
    \paragraph{Детали работы с числами.}
    \subparagraph{Суффиксы констант.}
    Какой тип имеет \mintinline{c++}|42|? \mintinline{c++}|int|. А если мы хотим другой? \mintinline{c++}|42U|, \mintinline{c++}|42L|, \mintinline{c++}|42UL|, \mintinline{c++}|42LL|, \mintinline{c++}|42ULL|, \mintinline{c++}|42.0f|, \mintinline{c++}|42.0L|. Это соответственно \mintinline{c++}|long|, \mintinline{c++}|unsigned long|, \mintinline{c++}|long long| , \mintinline{c++}|unsigned long long|, \mintinline{c++}|float| и \mintinline{c++}|long double|.
    \subparagraph{Конверсии.}
    Что будет, если складывать числа разного типа? Например, \mintinline{c++}|unsigned| и \mintinline{c++}|long|. А вот что. Упорядочим числа так: \mintinline{c++}|int|, потом \mintinline{c++}|unsigned|, \mintinline{c++}|long|, \mintinline{c++}|unsigned long|, \mintinline{c++}|long long|, \mintinline{c++}|unsigned long long|. Тогда из двух типов выбирается тот, кто больше, оба аргумента приводятся к нему и результат будет того же типа. Нюансы проявляются в том, что будет, если складывать два \mintinline{c++}|char|'а, например. Будет \mintinline{c++}|int|. А всё потому, что все арифметические операции с числами меньше \mintinline{c++}|int|'а выполняются в типе \mintinline{c++}|int|. Более того, вам даже операции делать не надо, при вызове функции это преобразование также происходит. Поэтому, кстати, если вы хотите принимать в функцию все типы (чтобы они сохраняли численное значение), то вам хватит \mintinline{c++}|int| и больше. Реализовать только \mintinline{c++}|long long| и \mintinline{c++}|unsigned long long| вы не можете, потому что \mintinline{c++}|long|, например, не знает, куда ему конвертиться. А вообще это работает так. В языке есть 3 типа конверсий (exact match, promotion и convertion), каждый следующий хуже всех предыдущих, и если у вас есть два одинаково хороших варианта, то ошибка компиляции. Так вот конверсия из \mintinline{c++}|short|'а в \mintinline{c++}|int|~--- promotion, а \mintinline{c++}|long| в \mintinline{c++}|long long| и \mintinline{c++}|unsigned long long| оба являются convertion'ами. Про всё это подробно можно почитать на \url{https://eel.is/c++draft/over.best.ics}.
    \paragraph{Мем.}
    \begin{minted}{c++}
        switch (a)
        {
        case 0:
            std::cout << "0";
            if (false)
        case 1:
            std::cout << "1";
            if (false)
        case 2:
            std::cout << "2";
            if (false)
        default:
            std::cout << "x";
        }
    \end{minted}
    Во-первых, это компилируется. Во-вторых, это выдаёт \Verb|0| для \mintinline{c++}|0|, \verb|1|~--- для \mintinline{c++}|1|, \Verb|2|~--- для \mintinline{c++}|2| и \Verb|x| для остальных. Как это понять? \mintinline{c++}|case|~--- это метки. И \mintinline{c++}|switch| делает \mintinline{c++}|goto| по ним. И если не опускать фигурные скобки в данной записи, то получится что-то такое:
    \begin{minted}{c++}
        switch (a)
        {
        case 0:
            std::cout << "0";
            if (false)
            {
            case 1:
                std::cout << "1";
            }
            if (false)
            {
            case 2:
                std::cout << "2";
            }
            if (false)
            {
            default:
                std::cout << "x";
            }
        }
    \end{minted}
    И теперь в целом понятно, что происходит, мы прыгаем внутрь \mintinline{c++}|if (false)|. Так писать ни в коем случае не надо, но с точки зрения языка возможно.
    \section{Компиляция и всё с ней связанное.}
    Зачем нам нужно это изучать? Во-первых, у студентов возникают с этим проблемы~--- когда компилятор пишет ошибку, а человек не понимает, что ему говорят. Во-вторых~--- если вы делаете ошибку в организации программы, причём такую ошибку, которая сразу к проблеме не приводит, то бывает такое, что при компиляции чуть-чуть по-другому всё сломается. Причём даже в крупных компаниях такое случается. Самое интересное, что ни в одной литературе про компиляцию не рассказывается (в совсем базовой считается что это сложно, а в продвинутой~--- что вы всё знаете), а все кто это знает, говорят, что пришло с опытом. 
    \paragraph{Этапы компиляции.}
    Как мы компилируем программу обычно? \mintinline{console}|g++ program.cpp|. Пока что ничего магического нет. А вот с чем мы не знакомы~--- так это с тем, что \mintinline{console}|g++| не делает всю работу самостоятельно, а вызывает другие команды, которые выполняют компиляцию по частям. И если посмотреть, что там, то там происходят \mintinline{console}|cc1plus|, потом \mintinline{console}|as|, в конце \mintinline{console}|collect2|, который вызывает \mintinline{console}|ld|. Давайте попытаемся это повторить. Дальше будет перечисление стадий с указанием двух моментов: как их можно выполнить руками и какое расширение обычно имеет результат этой стадии.
    \begin{enumerate}
        \item Препроцессирование. Выполняется при помощи \mintinline{console}|g++ -E| (если дополнительно передать ключ \mintinline{console}|-P|, то вывод будет чуть короче), выходной файл обычно имеет расширение \mintinline{console}|.i|.\\
        На файл с расширением \mintinline{console}|.i| можно и глазами посмотреть~--- в нём будет куча текста вместо \mintinline{c++}|#include|, а потом наш код. Собственно, \mintinline{c++}|#include|~--- директива препроцессора, которая тупо вставляет указанный файл в то место, где написана. Также препроцессор занимается макросами (\mintinline{c++}|#define|).
        \item Трансляция. Выполняется при помощи \mintinline{console}|g++ -S|, выходной файл обычно имеет расширение \mintinline{console}|.s|.\\
        Трансляция~--- это (с английского) <<перевод>>. Кого и куда переводим? Наш язык в ассемблер. Кстати, в этом ассемблере можно заметить интересную вещь, которую мы ещё не обсудили. Скомпилировав hello world, на x86-64 мы получим что-то вида
        \begin{minted}{nasm}
            SUB     RSP, 8
            MOV     EDI, OFFSET FLAT:LC0
            CALL    puts
            XOR     EAX, EAX
            ADD     RSP, 8
            RET
        \end{minted}
        \mintinline{nasm}|LC0|~--- это метка, где хранится строка \mintinline{c++}|"Hello, world"|, а вот зачем менять \mintinline{nasm}|RSP|, не ясно. Когда мы пишем на ассемблере, смысла в этом никакого. Но есть ABI~--- набор правил, как транслировать программу (какие регистры используются для возврата значения, например). И вот одно из правил~--- при входе в функцию стек должен быть выровнян по 16 байт.
        \item Ассемблирование. Выполняется специальной утилитой \mintinline{console}|as|, выходной файл обычно имеет расширение \mintinline{console}|.o| (и называется объектным файлом).\\
        Файлы \mintinline{console}|.o| бесполезно смотреть глазами, они бинарные, однако для этого есть специальные утилиты, например, \mintinline{console}|objdump|. Про него будет рассказано чуть позже. А вообще в \mintinline{console}|.o| файл попадают инструкции, которые были в ассемблерном файле, но в уже в бинарной форме.
        \item Линковка. Выполняется простым вызовом \mintinline{console}|g++| от объектного файла. На выходе даёт исполняемый файл.
    \end{enumerate}
    Хорошо, а что если файлов несколько? Да то же самое, честно говоря. Мы запускаем препроцессор независимо для каждого файла, потом независимо их всех транслируем и ассемблируем, а объединяются они только на этапе линковки. Независимые файлы \mintinline{console}|.cpp| файлы называют \textit{единицами трансляции}. Стоит сказать, что это до появления модулей в C++20, где можно доставать данные одного файла для другого. То есть там появляется зависимость друг от друга, а значит компилировать их надо в определённом порядке.
    \paragraph{Объявление и определение.}
    Продолжим про компиляцию нескольких файлов. Пусть у нас есть два файла:
    \begin{minted}{c++}
        // a.cpp
        int main()
        {
            f(42);
        }



        // b.cpp
        #include <cstdio>
        
        void f(int x)
        {
            printf("%i\n", x);
        }
    \end{minted}
    Мы получаем ошибку, что в файле \mintinline{console}|a.cpp| \mintinline{c++}|f| не определена в области видимости. Дело понятно в чём~--- в том что ошибка происходит на этапе трансляции, когда файлы ещё независимы. Всё потому, что для того чтобы вызвать функцию, надо что-то про неё знать. Например, если мы передаём в функцию \mintinline{c++}|int|~--- это один ассемблерный код, а если \mintinline{c++}|double|~--- то совершенно другой (потому что разные calling convention'ы могут быть). Поэтому на этапе трансляции нужно знать сигнатуру функции. Это исправляется вот так:
    \begin{minted}{c++}
        // a.cpp
        void f(int);

        int main()
        {
            f(42);
        }



        // b.cpp
        #include <cstdio>
    
        void f(int x)
        {
            printf("%i\n", x);
        }
    \end{minted}
    Когда мы пишем функцию и точку с запятой~--- это объявление/декларация (declaration). Это значит, что где-то в программе такая функция есть. А когда мы пишем тело функции в фигурных скобках~--- это определение (definition).\\
    Кстати, написать объявление бывает нужно даже если у нас один файл. Например, в таком файле:
    \begin{minted}{c++}
        #include <cstdio>

        int main()
        {
            f();
        }

        void f()
        {
            printf("Hello, world\n");
        }
    \end{minted}
    Тут дело в том, что компилятор смотрит файл сверху вниз, и когда доходит до вызова функции \mintinline{c++}|f| внутри \mintinline{c++}|main|, он ещё не дошёл до её определения. Тут можно переставить функции местами, да, но если у нас есть взаиморекурсивные функции, то там переставить их не получится~--- только написать декларацию.
    \paragraph{Ошибки линковки. Инструменты \texttt{nm} и \texttt{objdump}. Ключевое слово \texttt{static}.}
    Теперь пример чуть сложнее:
    \begin{minted}{c++}
        // a.cpp
        #include <cstdio>
        void f()
        {
            printf("Hello, a.cpp!\n");
        }

        // b.cpp
        #include <cstdio>
        void f()
        {
            printf("Hello, b.cpp!\n");
        }

        // main.cpp
        void f();

        int main()
        {
            f();
        }
    \end{minted}
    Тут вам напишут, что функция \mintinline{console}|f()| определяется дважды, что определяется на этапе линковки. Чтобы тут всё красиво посмотреть, можно использовать утилиту \mintinline{console}|nm|. Когда вы сгенерируете \mintinline{console}|a.o| и вызовете \mintinline{console}|nm -C a.o|, то мы увидим что-то такое:
    \begin{minted}{console}
                         U puts
        0000000000000000 T f()
    \end{minted}
    Что делает ключ \mintinline{console}|-C|, оставим на потом. На то что тут находится \mintinline{c++}|puts| вместо \mintinline{c++}|printf|, тоже обращать внимание не надо, это просто такая оптимизация~--- когда можно заменить \mintinline{c++}|printf| на \mintinline{c++}|puts|, заменяем. А надо обратить внимание на то, что \mintinline{c++}|puts| не определена (об этом нам говорит буква \mintinline{console}|U|), а функция \mintinline{c++}|f()|~--- определена в секции \mintinline{nasm}|.text| (буква \mintinline{console}|T|). У \mintinline{console}|main.cpp|, понятно, будет неопределённая функция \mintinline{c++}|f| и определённая \mintinline{c++}|main|.
    Поэтому, имея эти объектные файлы, можно слинковать \mintinline{console}|main.cpp| и \mintinline{console}|a.cpp|, а можно~--- \mintinline{console}|main.cpp| и \mintinline{console}|b.cpp|. Без перекомпиляции. Но нельзя все три вместе.\\
    Если мы хотим посмотреть на объектные файлы поподробнее, нам понадобится утилита \mintinline{console}|objdump|. У неё есть бесчисленное много ключей, которые говорят, что мы хотим увидеть. Например \mintinline{console}|-x|~--- выдать всё, что знаешь. Нам сейчас нужно \mintinline{console}|-d|~--- дизассемблирование и \mintinline{console}|-r|~--- релокации. Когда мы вызовем \mintinline{console}|objdump -dr -Mintel -C main.o|, мы увидим, что на месте вызова функции \mintinline{c++}|f| находится \mintinline{nasm}|call| и нули. Потому что неизвестно, где эта функция, её надо на этапе связывания подставить. А чтобы узнать, что именно подставить, есть релокации, которые информацию об этом и содержат. В общем случае релокация~--- информация о том, какие изменения нужно сделать с программой, чтобы файл можно было запустить.\\
    Давайте теперь вот на что посмотрим. Пусть в нашем файле определена функция \mintinline{c++}|f()|. И где-то по случайному совпадению далеко-далеко также определена функция \mintinline{c++}|f()|. Понятно, что оно так не слинкуется. Но мы можем иметь ввиду, что наша функция \mintinline{c++}|f| нужна только нам и никак наружу не торчит. Для этого имеется специальный модификатор \mintinline{c++}|static|. Если сделать на такие функции \mintinline{console}|nm|, то там можно увидеть символ \mintinline{console}|t| вместо \mintinline{console}|T|, который это и обозначает. Вообще функции, локальные для одного файла ст\'{о}ит помечать как \mintinline{c++}|static|, потому что это ещё помогает компилятору сделать оптимизации.
    \paragraph{Глобальные переменные.}
    Для глобальных переменных работает всё то же самое, что и для функций~--- например, мы также можем сослаться на глобальную переменную из другого файла. Только тут другой синтаксис: \mintinline{c++}|int x;|~--- это определение, а \mintinline{c++}|extern int x;|~--- объявление. И точно также в глобальных переменных можно писать \mintinline{c++}|static|.\\
    Теперь подумаем о том, что будет если так:
    \begin{minted}{c++}
        // a.cpp
        extern int a;

        void f();

        int main()
        {
            f();
            a = 5;
            f();
        }



        // b.cpp
        #include <cstdio>

        int a;

        void f()
        {
            printf("%d\n", a);
        }
    \end{minted}
    Тут выведется \mintinline{console}|0| и \mintinline{console}|5|, потому что глобальные переменные инициализируются нулями. Локальные переменные хранятся на стеке, и там какие данные были до захода в функцию, те там и будут. А глобальные выделяются один раз, и ОС даёт вам их проинициализированные нулём (иначе там могут быть чужие данные их нельзя отдавать).
    \paragraph{Декорирование имён.}
    Обсуждённая нами модель компиляции позволяет использовать несколько разных языков программирования. Пока ЯП умеет транслироваться в объектные файлы, проблемы могут возникнуть только на этапе линковки. Например, никто не мешает вам взять уже готовый ассемблерник и скомпилировать его с \mintinline{console}|.cpp| файлом. Теперь мы, кстати, знаем, зачем на ассеблере вызывали сначала \mintinline{console}|nasm|, а потом \mintinline{console}|ld|. Потому что первый~--- ассемблирование, второй~--- линковка.\\
    Но в вызове ассемблера есть одна проблема. Тут надо поговорить о такой вещи как \mintinline{c++}|extern "C"|. В языке C всё было так: имя функции и имя символа для линковщика~--- это одно и то же. Если мы скомпилируем файл
    \begin{minted}{c}
        // a.c
        void foo(int)
        {
            ...
        }
    \end{minted}
    То имя символа, которое мы увидим в \mintinline{console}|nm| будет \mintinline{console}|foo|. А в C++ появилась перегрузка функций. То есть \mintinline{c++}|void foo(int)| и \mintinline{c++}|int foo(double)|~--- это две разные функции, обе из которых можно вызывать. Поэтому одно имя символа присвоить им нельзя. Их компилятор mangle'ит/декорирует, то есть изменяет их имена так, чтобы символы получились уникальными. \mintinline{console}|nm| даже может выдать вам эти имена (в данном случае получится \mintinline{console}|_Z3fooi| и \mintinline{console}|_Z3food|). Но у вас есть и возможность увидеть их по-человечески: для этого существует ключ \mintinline{console}|-C|, который если передать программе \mintinline{console}|nm|, то она раздекорирует всё обратно и выдаст вам имена человекочитаемо. И \mintinline{console}|objdump|'у этот ключ дать тоже можно. А ещё есть утилита \mintinline{console}|c++filt|, которая по имени символа даёт сигнатуру функции.\\
    Так вот, \mintinline{c++}|extern "C"| говорит, что при линковке нам не нужно проводить декорацию. И если у нас в ассемблерном файле написано \mintinline{nasm}|fibonacci:|, то вам и нужно оставить имя символа как есть.
    \paragraph{Линковка со стандартной библиотекой.}
    Вопрос~--- а если мы используем некоторую функцию стандартной библиотеки, можем ли мы вместо подключения файла написать только заголовок этой функции? А вот можем. То есть вот такой код:
    \begin{minted}{c++}
        extern "C" printf(const char*, ...);
        
        int main()
        {
            printf("Hello, world!");
        }
    \end{minted}
    Вполне корректен. А где определение \mintinline{c++}|printf|, возникает вопрос. А вот смотрите. На этапе связывания связываются не только ваши файлы. Помимо этого в параметры связывания добавляются несколько ещё объектных файлов, и несколько библиотек. В нашей модели мира хватит информации о том, что библиотека~--- просто набор объектных файлов. И вот при линковке вам дают библиотеку стандартную библиотеку C++ (\mintinline{console}|-lstdc++|), вам дают математическую библиотеку (\mintinline{console}|-lm|), вам дают библиотеку \mintinline{console}|-libgcc|, чтобы если вы делаете арифметику в 128-битных числах, то компилятор мог вызвать функцию \mintinline{c++}|__udivti3| (деление) оттуда, и дают кучу всего ещё. В нашем случае нужна одна~--- \mintinline{console}|-lc|, в которой и лежит \mintinline{c++}|printf|.
    \paragraph{Директива \texttt{include}.}
    Если мы используем одну функцию во многих файлах, то нам надо писать её сигнатуру везде. А если мы её меняем, то вообще повеситься можно. Поэтому так не делают. А как делают? А так: декларация выделяется в специальный файл. Это файл имеет расширение \mintinline{console}|.h| и называется заголовочным. По сути это же происходит в стандартной библиотеке. Подключаются заголовочные файлы директивой \mintinline{c++}|#include <filename>|, если они из какой-то библиотеки, или \mintinline{c++}|#include "filename"|, если он ваш. В чём разница? Стандартное объяснение~--- тем, что треугольные скобки сначала ищут в библиотеках, а потом в вашей программе, а кавычки~--- наоборот. На самом желе у обоих вариантов просто есть список путей, где искать файл, и эти списки разные.\\
    Хорошо, а почему в нашем примере писать сигнатуру \mintinline{c++}|printf| напрямую плохо? Ну, например, мы можем не угадать с сигнатурой, тогда будут грустно.\\
    Но с ними нужно правильно работать. Например, нельзя делать \mintinline{c++}|#include "a.cpp"|. Почему? Потому что все определённые в \mintinline{console}|a.cpp| функции и переменные просочатся туда, куда вы его подключили. И если файл у вас один, то ещё ничего, а если больше, то в каждом, где написано \mintinline{c++}|#include "a.cpp"|, будет определение, а значит определение одного и того же объекта будет написано несколько раз. Аналогичной эффект будет, если писать определение сразу в заголовочном файле.
    \subparagraph{Предотвращение повторного включения.}
    Давайте поговорим про структуры. Что будет, если мы в заголовочном файле создадим \mintinline{c++}|struct|, и подключим этот файл? Да ничего. Абсолютно ничего. Сгенерированный ассемблерный код будет одинаковым. Поэтому у структур нет определения по сути, потому что они не генерируют код. Поэтому их пишут в заголовках. Но тут есть один нюанс. Рассмотрим вот что:
    \begin{minted}{c++}
        // a.cpp
        #include "c.h"
        #include "d.h"

        int main()
        {
        }

        // b.h
        struct x
        {
            int a;
            int b;
        };

        // c.h
        struct y
        {
            x p;
            x q;
        };

        // d.h
        struct y
        {
            x xx;
            int size;
        };
    \end{minted}
    Это не будет компилироваться, потому что после препроцессора мы подключим \mintinline{console}|b.h| два раза, а значит два раза определим структуру \mintinline{c++}|x|. Это уже не ошибка программиста, а именно что нюанс директивы \mintinline{c++}|#include|. Для этого есть такая штука:
    \begin{minted}{c++}
        // b.h
        #ifndef B_H
        #define B_H

        struct x
        {
            int a;
            int b;
        };

        #endif
    \end{minted}
    По сути тут происходит следующее~--- если мы ещё не заходили в \mintinline{console}|b.h|, то заходим и помечаем, что заходили. Иначе считаем содержимое этого файла пустым. Это называется include guard. У этого способа есть некоторые проблемы, поэтому все возможные компиляторы поддерживают \mintinline{c++}|#pragma once|. И на самом деле \mintinline{c++}|#pragma once| работает лучше, потому что не опирается на имя файла, например. Но он не стандартизирован, что грустно. Есть один нюанс с \mintinline{c++}|#pragma once|'ом. Если у вас есть две жёстких ссылки на один файл, то у него проблемы. Если у вас include guard, то интуитивно понятно, что такое разные файлы~--- когда макросы у них разные. А вот считать ли разными файлами две жёстких ссылки на одно и то же~--- вопрос сложный. Другое дело, что делать так, чтобы источники содержали жёсткие или символические ссылки, уже довольно странно.
    \paragraph{Forward-декларации.}
    С include guard'ом есть такая проблема:
    \begin{minted}{c++}
        // a.h
        #ifndef A_H
        #define A_H
        #include "b.h"
        
        struct a
        {
            b* bb;
        };
        
        #endif



        // b.h
        #ifndef B_H
        #define B_H
        #include "a.h"
        
        struct b
        {
            a* aa;
        };
        
        #endif



        // main.cpp
        #include "a.h"
        #include "b.h"
    \end{minted}
    Понятно, в чём проблема заключается. Мы подключаем \mintinline{console}|a.h|, в нём~--- \mintinline{console}|b.h|, в нём, поскольку мы уже зашли в \mintinline{console}|a.h|, include guard нам его блокирует, и мы сначала определяем структуру \mintinline{c++}|b|, а потом~--- \mintinline{c++}|a|. И при просмотре структуры \mintinline{c++}|b|, мы не будем знать, что такое \mintinline{c++}|a|. Для этого есть конструкция, называемая forward-декларацией. Она выглядит так:
    \begin{minted}{c++}
        // a.h
        #ifndef A_H
        #define A_H
        #include "b.h"

        struct b;

        struct a
        {
            b* bb;
        };

        #endif



        // b.h
        #ifndef B_H
        #define B_H
        #include "a.h"

        struct b
        {
            a* aa;
        };

        #endif
    \end{minted}
    Дело в том, что чтобы завести указатель, нам не надо знать содержимое структуры. Поэтому мы просто говорим, что \mintinline{c++}|b|~--- это некоторая структура, которую мы дальше определим. И кстати, нам даже \mintinline{c++}|#include| в каждом из заголовочных файлов делать не надо, можно просто написать
    \begin{minted}{c++}
        // a.h
        #ifndef A_H
        #define A_H

        struct b;

        struct a
        {
            b* bb;
        };
        
        #endif



        // b.h
        #ifndef B_H
        #define B_H

        struct a;

        struct b
        {
            a* aa;
        };
        
        #endif
    \end{minted}
    Вообще forward-декларация~--- штука полезная. Даже если она не необходима, то всё лучше использовать её вместо подключения других заголовочных файлов. Почему? Во-первых, из-за времени компиляции. Большое количество подключений в заголовочных файлах негативно влияет на него, потому что если вы меняете заголовок, который подключаете много где, то всё, где он подключается, тоже надо перекомпилировать. А с forward-декларацией это совершенно не обязательно. Второй момент~--- когда у нас цикл из заголовочных файлов, это всегда ошибка, даже если там нет проблем как в примере, потому что результат компиляции зависит от того, что вы подключаете первым.
    \paragraph{Правило единственного определения.}
    Что ещё делать никогда нельзя? Например, вот это
    \begin{minted}{c++}
        // a.cpp
        #include <iostream>

        struct x
        {
            int a;
            double b;
            int c;
            int d;
        };
        x f();

        int main()
        {
            x xx = f();
            std::cout << xx.a << " "
                      << xx.b << " "
                      << xx.c << " "
                      << xx.d << "\n";
        }



        // b.cpp
        struct x
        {
            int a;
            int b;
            int c;
            int d;
            int e;
        };

        x f()
        {
            x xx;
            xx.a = 1;
            xx.b = 2;
            xx.c = 3;
            xx.d = 4;
            xx.e = 5;
            return xx;
        }
    \end{minted}
    То есть в разных файлах мы определяем одну структуру различным образом. По стандарту это некорректно, но вообще так делать возможно. И тут понятно, что будет, данные поедут. А именно \mintinline{c++}|2| пропадёт из-за выравнивания \mintinline{c++}|double|, \mintinline{c++}|3| и \mintinline{c++}|4| запишутся в \mintinline{c++}|double|, \mintinline{c++}|5| будет на своём месте, а \mintinline{c++}|x::e| из файла \mintinline{console}|a.cpp| будет просто не проинициализирован. То же самое, если перетасовать имена полей.
    \paragraph{Inlining.}
    Посмотрим теперь вот на что:
    \begin{minted}{c++}
        int foo(int a, int b)
        {
            return a + b;
        }

        int bar(int a, int b)
        {
            return foo(a, b) - a;
        }
    \end{minted}
    Тогда если посмотреть на ассемблерный код для \mintinline{c++}|bar|, то там не будет вызова функции \mintinline{c++}|foo|, а будет по сути \mintinline{c++}|return b;|. Это называется inline'инг~--- когда мы берём тело одной функции и вставляем внутрь другой как оно есть. Это связано, например, со стилем программирования в текущем мире (много маленьких функций, которые делают маленькие вещи)~--- мы убираем все эти абстракции, сливаем функции в одну и потом оптимизируем что там есть.
    \subparagraph{Inlining и линковка.}
    Есть нюанс:
    \begin{minted}{c++}
        // a.c
        void say_hello();

        int main()
        {
            say_hello();
        }



        // b.c
        #include <cstdio>

        void say_hello()
        {
            printf("Hello, world!\n");
        }
    \end{minted}
    Тут никакого inline'инга не произойдёт, хотя, казалось бы, почему нет? Дело в том, что генерация ассемблерного кода происходит на этапе трансляции, а какую-то информацию о другой функции мы узнаём позже. У нас нет полноты информации, чтобы за'inline'ить. Хотя тут я умеренно умалчиваю следующий факт: всё же это не совсем так, ведь модель компиляции, которую мы обсуждаем~--- древняя и бородатая. Мы можем передать ключ \mintinline{console}|-flto| в компилятор, тогда всё будет за'inline'ено хорошо. Дело в том, что при включенном режиме linking time optimization, мы откладываем на потом генерацию кода и генерируем его на этапе линковки.
    \paragraph{Ключевое слово \texttt{inline}.}
    Хорошо, а как жить без LTO, если inline'ить очень хочется. Ну прям очень хочется. Мы можем написать в заголовочном файле тело, это поможет, но это, как мы знаем, нельзя. Но всё же для этого был создан модификатор \mintinline{c++}|inline|. Он нужен для того, чтобы линковщик не дал ошибку нарушения ODR. Модификатор \mintinline{c++}|inline| напрямую никак не влияет на то, что функции встраиваются. Если посмотреть на \mintinline{c++}|inline| через \mintinline{console}|nm|, то там увидим \mintinline{console}|W| (weak)~--- из нескольких функций можно выбрать любую.\\
    Кстати, а что будет, если мы всё же напишем две одинаковые \mintinline{c++}|inline|-функции с разным телом? Или разные две структуры с одинаковыми именами, как в примере выше? По стандарту это ill-formed, no diagnostic required. То есть программа некорректна, но никто не заставляет компилятор говорить, в чём ошибка. И вообще, что ошибка есть. Но несмотря на то, что компилятор может не указывать ошибку, он не обязан. Например, в примере со структурами можно написать \mintinline{console}|g++ -flto -Wodr|, и будет предупреждение о том, что нарушается One Definition Rule. Просто потому, что \mintinline{console}|g++| так может. Но имеет право не мочь. А касательно компиляции двух \mintinline{c++}|inline| функций~--- вот пример:
    \begin{minted}{c++}
        // a.cpp
        #include <cstdio>

        inline void f()
        {
            printf("Hello, a.cpp!\n");
        }
        void g();

        int main()
        {
            f();
            g();
        }

        // b.cpp
        inline void f()
        {
            printf("Hello, b.cpp!\n");
        }

        void g()
        {
            f();
        }
    \end{minted}
    Видно, что программа некорректна, не пишите так. Но всё же, что будет? А вот всё зависит от порядка файлов и ключей компиляции. Если скомпилировать с оптимизацией, обе функции \mintinline{c++}|f| будут за'inline'ены, и всё будет хорошо. Если без~--- то зависит от порядка файлов~--- \mintinline{console}|g++ a.cpp b.cpp| может вполне выдавать \mintinline{console}|Hello, a.cpp!| два раза, а \mintinline{console}|g++ b.cpp a.cpp|~--- \mintinline{console}|Hello, b.cpp!| два раза.
    \paragraph{Остальные команды препроцессора.}
    \mintinline{c++}|#include| обсудили уже вдоль и поперёк. Ещё есть директивы \mintinline{c++}|#if|, \mintinline{c++}|#ifdef|, \mintinline{c++}|#ifndef|, \mintinline{c++}|#else|, \mintinline{c++}|#elif|, \mintinline{c++}|#endif|, которые дают условную компиляцию. То есть если выполнено какое-то условие, можно выполнить один код, а иначе~--- другой. И ещё есть макросы: определить макрос \mintinline{c++}|#define| и разопределить макрос~--- \mintinline{c++}|#undef|. Самый простой макрос~--- object-like~--- \mintinline{c++}|#define MACRO something|, чуть более сложный~--- function-like~--- \mintinline{c++}|#define MACRO(x) some x thing|. Что нам нужно про это знать~--- макросы работают с токенами. Они не знают вообще ничего о том, что вы делаете. Вы можете написать
    \begin{minted}{c++}
        #include <cerrno>
        int main()
        {
            int errno = 42;
        }
    \end{minted}
    И получить отрешённое от реальности сообщение об ошибке. А дело всё в том, что это на этапе препроцессинга раскрывается, например, так:
    \begin{minted}{c++}
        int main()
        {
            int (*__errno_location()) = 42;
        }
    \end{minted}
    И тут компилятор видит не то, что вы назвали переменную как нельзя. Более страшные вещи получаются, когда пишется что-то такое:
    \begin{minted}{c++}
        #define mul(x, y) x * y
        int main()
        {
            int z = mul(2, 1 + 1);
        }
    \end{minted}
    То получится
    \begin{minted}{c++}
        #define mul(x, y) x * y
        int main()
        {
            int z = 2 * 1 + 1;
        }
    \end{minted}
    Это не то что вы хотите. Поэтому когда вы такое пишите, нужно во-первых, все аргументы запихивать в скобки, во-вторых~--- само выражение тоже, а в-третьих, это вас никак не спасёт от чего-то такого:
    \begin{minted}{c++}
        #define max(a, b) ((a) < (b) ? (a) : (b))

        int main()
        {
            int x = 1;
            int y = 2;
            int z = max(x++, ++y);
        }
    \end{minted}
    Поэтому перед написанием макросов три раза подумайте, нужно ли оно, а если нужно, будьте очень аккуратны. А ещё, если вы используете отладчик, то он ничего не знает про макросы, зачем ему знать. Поэтому в отладчике написать <<вызов макроса>> Вы обычно не можете.
    \paragraph{Константы.}
    Понадобилась нам, например, $\pi$. Традиционно в C это делалось через \mintinline{c++}|#define|. Но у препроцессора, как мы знаем, есть куча проблем. В случае с константой \mintinline{c++}|PI| ничего не случится, вряд ли кто-то будет называть переменную так, особенно большими буквами, но всё же.\\
    Именно поэтому в C++ появился \mintinline{c++}|const|. Но всё же, зачем он нужен, почему нельзя просто написать глобальную переменную \mintinline{c++}|double pi = 3.141592;|? Во-первых, константы могут быть оптимизированы компилятором. Если вы делаете обычную переменную, компилятор обязан её взять из памяти (или регистров), ведь в другом файле кто-то мог её поменять. А если вы напишете \mintinline{c++}|const|, то у вас не будет проблем ни с оптимизацией (ассемблер будет как при \mintinline{c++}|#define|), а с другой стороны все ошибки будут правильно выводиться. Во-вторых, вы как программист хотите удостовериться, что никто и нигде не сможет применить переменную. И в-третьих, она несёт документирующую функцию, когда вы пишете их с указателями. Если в заголовке функции написано \mintinline{c++}|const char*|, то вы точно знаете, что вы передаёте в неё строку, которая не меняется, а если \mintinline{c++}|char*|, то, скорее всего, меняется (то есть функция создана для того, чтобы менять). И в-четвёртых, имея \mintinline{c++}|const|, компилятор может вообще не создавать переменную, если мы напишем \mintinline{c++}|return PI * 2|, то там будет возвращаться константа, и никакого умножения на этапе исполнения.\\
    Кстати, как вообще взаимодействует \mintinline{c++}|const| с указателями? Посмотрим на такой пример:
    \begin{minted}{c++}
        int main()
        {
            const int MAGIC = 42;
            int* p = &MAGIC;
        }
    \end{minted}
    Так нельзя, это имеет фундаментальную проблему: вы можете потом записать \mintinline{c++}|*p = 3|, и это всё порушит. Поэтому вторая строка не компилируется, и её надо заменить на \mintinline{c++}|const int* p = &MAGIC;|. Но тут нужно вот на что посмотреть. У указателя в некотором смысле два понятия неизменяемости. Мы же можем сделать так:
    \begin{minted}{c++}
        int main()
        {
            const int MAGIC = 42;
            const int* p = &MAGIC;
            // ...
            p = nullptr;
        }
    \end{minted}
    Кто нам мешает так сделать? Да никто, нам нельзя менять содержимое \mintinline{c++}|p|, а не его самого. А если нельзя менять именно сам указатель, то это не \mintinline{c++}|const int*|/\mintinline{c++}|int const*|, а \mintinline{c++}|int* const|. Если вам нужно запретить оба варианта использования, то, что логично, \mintinline{c++}|const int* const| или \mintinline{c++}|int const* const|. То есть в коде
    \begin{minted}{c++}
        int* a;
        const int* b;
        int* const c;
        const int* const d;
    \end{minted}
    Можно делать что угодно с \mintinline{c++}|a|, \mintinline{c++}|b| можно перенаправлять на другие места памяти, но нельзя записывать данные туда, куда он указывает, с \mintinline{c++}|c|~--- наоборот, с \mintinline{c++}|d| нельзя ни то, ни другое.\\
    Теперь вот на что посмотрим:
    \begin{minted}{c++}
        int main()
        {
            int a = 3;
            const int b = 42;

            int* pa = &a;        // 1
            const int* pca = &a; // 2
            int* pb = &b;        // 3
            const int* pcb = &b; // 4
        }
    \end{minted}
    Где тут ошибка? Ну, в третьем точно ошибка, это мы уже обсудили. Также первое и четвёртое тоже корректно. А что со вторым? Ну, нарушает ли это чьи-то права? Ну, нет. Или как бы сказали на парадигмах программирования, никто не нарушает контракт, мы только его расширяем. Ну, так и работают неявные преобразования в C++, вы можете навешивать \mintinline{c++}|const| везде, куда хотите, но не можете его убирать.
    \section{Классы.}
    \paragraph{Методы.}
    Есть у нас, например, комплексные числа. Как бы мы их реализовали с нашими текущими знаниями?
    \begin{minted}{c++}
        struct complex
        {
            double re;
            double im;
        };

        void conjugate(complex* c)
        {
            c->im = -c->im;
        }
    \end{minted}
    Это корректный и хороший C'шный код. Но в C++ позволили писать функции внутри класса. Они, как в Java принимают неявный параметр \mintinline{c++}|this|, который указатель на <<себя>>. И в C++ то же самое было бы написано так:
    \begin{minted}{c++}
        struct complex
        {
            double re;
            double im;

            void conjugate()
            {
                this->im = -this->im;
            }
        };
    \end{minted}
    При этом \mintinline{c++}|this->| можно опустить везде, где он есть:
    \begin{minted}{c++}
        struct complex
        {
            double re;
            double im;
            
            void conjugate()
            {
                im = -im;
            }
        };
    \end{minted}
    При этом компилятор генерирует один и тот же код для программы в C'шном стиле и для программы в C++ стиле. При этом, когда вы хотите указать, что \mintinline{c++}|this| имеет тип \mintinline{c++}|const complex* const|, а не \mintinline{c++}|complex* const|, вы пишете \mintinline{c++}|const| после закрывающей скобки аргументов функции.
    \paragraph{Ещё немного про компиляцию.}
    Кстати. Можно написать сначала метод, а потом поля, это ни на что не влияет. Почему? В компиляторе это сделано так, что компилятор откладывает разбор тел функций на конец класса. Но тут же возникает вопрос, почему так не делали с обычными функциями? По историческим причинам, на самом деле. Когда у компьютеров было мало памяти, такие штуки компиляторы вообще никак не могли себе позволить. Поэтому по развитию GCC можно посмотреть, что сначала он оптимизировал только одну функцию за раз, потом только одну единицу трансляции, а теперь уже у нас есть \mintinline{console}|-flto|. Понятно, что если с \mintinline{console}|-flto| компилировать что-то огромное, вам нужно будет гигов этак двадцать. Второй аргумент~--- нельзя прекомпилировать заголовки. Прекомпиляция заголовков~--- это когда вы проходитесь по заголовку один раз, сохраняете состояние компилятора и потом загружаете его, чтобы не разбирать заголовок снова. И если бы заголовки зависели от того, что после них, такое было бы невозможно.
    \paragraph{Права доступа.}
    Хорошо, а в чём глобально разница между внешней функцией и методом? Ну, во внешнюю функцию можно передать \mintinline{c++}|nullptr|. Но это легко исправляется ссылками, они тоже не бывают \mintinline{c++}|nullptr|. А вот что действительно важно~--- права доступа. Как и в Java, вы можете показывать и скрывать поля и методы класса ключевыми словами \mintinline{c++}|public| и \mintinline{c++}|private| соответственно: к \mintinline{c++}|public|-полям и методам могут обращаться все вообще, а к \mintinline{c++}|private|~--- только методы того же класса. Иначе говоря такой код:
    \begin{minted}{c++}
        struct complex
        {
        private:
            double re;
            double im;

        public:
            void conjugate()
            {
                im = -im;
            }
        };
    \end{minted}
    Скомпилируется, а такой же с внешней функцией~--- нет.
    \subparagraph{Смысл инкапсуляции. Контракты класса.}
    Зачем вам вообще нужен бывает \mintinline{c++}|private|? Ну, пишете вы двоичное дерево, например:
    \begin{minted}{c++}
        struct node
        {
            node* left;
            node* right;
            node* parent;
            int value;
        };
    \end{minted}
    И теперь это Вы должны поддерживать инварианты дерева (что \mintinline{c++}|this->left->parent == this|, что слева все значения меньше, чем в текущем узле и прочее). Понятно, что произвольное изменение любого из этих четырёх полей может их испортить, и именно поэтому их ст\'{о}ит сделать \mintinline{c++}|private|.\\
    Контракты, кстати, не всегда очевидны и однозначны. Давайте, например, посмотрим на то, какой контракт у класса дроби:
    \begin{minted}{c++}
        struct rational
        {
            int32_t num;
            int32_t denom;
        };
    \end{minted}
    Ну, базовое требование~--- ненулевой знаменатель. Но имеет смысл добавить сюда \mintinline{c++}|denom > 0| и \mintinline{c++}|gcd(num, denom) == 1|, чтобы у вас не было дробей вида $\frac{-2}{-4}$. И что с этой добавкой, что без неё, оба варианта верны, на самом деле~--- в зависимости от этого изменятся реализации функций. Например, в случае только \mintinline{c++}|denom != 0| будет простое сложение, но сложное сравнение. И что грустно, зачастую понять инвариант вы можете только по коду (а код ещё и ошибки может содержать).\\
    Поэтому полезно бывает в отладочных целях писать метод \mintinline{c++}|void check_invariant() const|, после чего на тестировании вставлять его до и после каждого публичного метода. Была даже история о том, как чуваки взяли много проектов по красно-чёрным деревьям из GitHub, повставляли в них проверку инварианта и нашли кучу ошибок. А единственные проекты, где не нашли, уже содержали проверку. Дело было в том, что красно-чёрное дерево может не сломаться полностью, если допустить в нём ошибку~--- вы можете ошибиться так, что оно всё ещё будет деревом поиска, всё ещё сможет добавлять и удалять элементы, но оно будет работать медленнее, чем должно теоретически, потому что будет неправильно покрашено. И в этом случае вам проверка инварианта и поможет.\\
    Вопрос: а всегда ли мы можем проверить инвариант? А вот нет. Скажем, мы пишем контейнер, у него должны быть \mintinline{c++}|capacity| выделенных байт, первые \mintinline{c++}|size| из которых проинициализированы. Ну, один хрен мы это проверим. Мы можем теоретически написать какой-то умный аллокатор, который имеет проверку первого, а разломав компилятор сможем проверить второе. Но это никто делать не будет, увы(. Поэтому тут вы ничего сделать не можете.\\
    Теперь знания про инварианты класса можно применить к нашему классы \mintinline{c++}|complex|, который мы писали. Ну, да, сначала надо что-то сделать с бесконечностями и NaN'ами, но сейчас не о них. Итак, можем ли мы делать в классе \mintinline{c++}|complex| поля доступными? Есть аргумент против этого такого рода: мы же можем хранить числа в полярной форме, а вещественную и мнимую часть считать, но это кринж, на самом деле, люди будут не очень рады такому исходу. Есть аргумент получше: в компилятор GCC, например, имеет встроенные комплексные числа через ключевое слово \mintinline{c++}|__complex__|. И использует в реализации \mintinline{c++}|std::complex| он именно их, а не два \mintinline{c++}|double|'а. Поэтому тут уже ст\'{о}ит сделать их \mintinline{c++}|private|~--- мы даём себе простор для модификации.
    \paragraph{Конструкторы.}
    Мы уже говорили о разных классах со сложными инвариантами. Все его операции должны основываться на том, что инвариант выполнен до вызова. Поэтому когда мы создаём новый объект, хотелось бы, чтобы они выполнялись с начала. Поэтому есть специальные методы~--- конструкторы. Вот пример синтаксиса:
    \begin{minted}{c++}
        struct string
        {
            char* data;
            size_t size;
            size_t capacity;

            string()
            {
                data = nullptr;
                size = capacity = 0;
            }
        };
    \end{minted}
    То есть вместо имени вы пишете имя класса, а тип возвращаемого значения не пишется. Конструктор без аргументов называется \textit{конструктором по умолчанию}. Конструкторы вызываются компилятором (и только им) всегда, когда вы создаёте объект. Как указать, какой вызывать? Вот так:
    \begin{minted}{c++}
        struct complex
        {
        private:
            double re;
            double im;

        public:
            complex()
            {
                re = im = 0;
            }
            complex(double re, double im)
            {
                this->re = re;
                this->im = im;
            }
        };

        void main()
        {
            complex a1;
            complex a2();
            complex a3 = complex();
            complex a4{};

            complex b1(1, 2);
            complex b2 = complex(1, 2);
            complex b3{1, 2};
        }
    \end{minted}
    Первые 4 варианта и последние три эквивалентны. Кстати, выражение вида \mintinline{c++}|complex(1, 2)| может как оно есть в функцию передаваться~--- тогда создастся временный объект и передастся. Этот временный объект, кстати, является rvalue. Теперь давайте внимательнее посмотрим на \mintinline{c++}|a3| и \mintinline{c++}|b2|. Там мы вроде как сначала создаём объект, а потом присваиваем его куда-то. Так вот да, но нет. У компилятора есть такое понятие как избегание копирования: если правый аргумент~--- rvalue, то он ничего не копирует, а просто вызывает конструктор на \mintinline{c++}|a3|/\mintinline{c++}|b2|.\\
    Ещё ст\'{о}ит сказать про неявные конструкторы:
    \begin{minted}{c++}
        struct complex
        {
        private:
            double re;
            double im;
            
        public:
            complex() {...}
            complex(double re, double im) {...}
            complex(double re)
            {
                this->re = re;
                this->im = 0;
            }
        };

        void foo(complex) {...}

        void main()
        {
            foo(42.0);

            complex a = 42;
        }
    \end{minted}
    Такой код неявно преобразует \mintinline{c++}|42.0| в \mintinline{c++}|complex| и вызывает от него функцию. В случае с \mintinline{c++}|complex| это оправдано, но если у вас контейнер инициализируется количеством элементов, то так неявно делать странно. Поэтому если вы такого не хотите, напишите перед конструктором слово \mintinline{c++}|explicit|. Тогда вы запретите ещё \mintinline{c++}|complex a = 42|, можно только \mintinline{c++}|complex a(42)|.
    \paragraph{Деструкторы.}
    Ну, хорошо, вы написали свой контейнер. Он выделяет память при создании. А когда вы её освободите-то? А вот для конструкторов есть парные функции~--- деструкторы, которые автоматически вызываются, когда объект уничтожается. Он пишется как конструктор по умолчанию, но с тильдой в начале. Когда происходит уничтожение? Обычные переменные умирают когда наступает фигурная скобка блока, где вы объявили переменную. Совершенно не важно, каким образом вы покидаете блок, \mintinline{c++}|return| у вас, \mintinline{c++}|break|, \mintinline{c++}|throw| или даже \mintinline{c++}|goto|. Только если \mintinline{c++}|longjmp| вы используете, тогда вы не знаете, вызовутся деструкторы или нет. Мораль~--- не используйте \mintinline{c++}|longjmp|, потому что он всё равно корректно работает только вверх по стеку, а вверх по стеку можно заменить на \mintinline{c++}|throw|-\mintinline{c++}|catch|. Временные объекты умирают по концу выражения, где они созданы. Для глобальных переменных конструктор вызывается до \mintinline{c++}|main|, а деструктор~--- после него. Для полей конструктор вызывается во время конструктора внешнего класса, а деструктор~--- после его деструктора. При этом деструкторы объектов одного блока вызываются в порядке, обратном порядку конструкторов.
    \paragraph{Перегрузка операторов.}
    Для класса \mintinline{c++}|complex| очень хочется иметь арифметические операции. Чтобы так можно было, в C++ есть ключевое слово \mintinline{c++}|operator|. Они пишутся как обычные функции, только называются как \mintinline{c++}|operator+|, \mintinline{c++}|operator-| и тому подобное. Кстати, надо сразу рассказать, как перегружать \mintinline{c++}|++| и \mintinline{c++}|--|, ведь у вас два таких. Тут синтаксический костыль~--- постфиксные операторы принимают второй аргумент \mintinline{c++}|int|, который не используется.\\
    Также как и обычные функции операторы могут быть внешними или внутренними:
    \begin{minted}{c++}
        complex operator+(complex a, complex b)
        {
            return complex(a.real() + b.real(), a.imag() + b.imag());
        }
    \end{minted}
    Или
    \begin{minted}{c++}
        class complex
        {
            // ...
            complex operator+(complex other) const
            {
                return complex(re + other.re, im + other.im);
            }
        };
    \end{minted}
    Работают они как совершенно обычные функции, поэтому сказать про них можно немногое.
    \subparagraph{Оператор \texttt{->}.}
    Особо нужно посмотреть на \mintinline{c++}|->|. Его обычно перегружают, когда пишут какие-то свои указатели. И выглядят это вот так:
    \begin{minted}{c++}
        struct my_ptr
        {
            // Что-то.

            complex* operator->()
            {
                return /* Что-то */;
            }
        };
    \end{minted}
    Можно было бы подумать, что \mintinline{c++}|->|~--- это бинарный оператор (у него есть то, у чего мы берём поле/метод и имя этого самого поля/метода). Но правая штука~--- это не выражение. В C++ нет рефлексии. Поэтому \mintinline{c++}|->|~--- это унарный оператор. Если вы возьмёте \mintinline{c++}|my_ptr x| и вызовете \mintinline{c++}|x->im|, то это преобразуется в \mintinline{c++}|(x.operator->())->im|. Поскольку \mintinline{c++}|operator->| возвращает \mintinline{c++}|complex*|, к нему нормально можно применить \mintinline{c++}|->|. А ещё можно из оператора \mintinline{c++}|->| вернуть что-то другое, к чему применим оператор \mintinline{c++}|->|. И тогда они будут вызываться по цепочке, пока не дойдём до обычного указателя.
    \paragraph{Ссылки.}
    Вопрос~--- что делать с \mintinline{c++}|+=| и им подобными? Уж совершенно точно не это
    \begin{minted}{c++}
        void operator+=(complex a, complex b)
        {
            a.set_real(a.real() + b.real());
            a.set_imag(a.imag() + b.imag());
        }
    \end{minted}
    Потому что \mintinline{c++}|a| копируется. Есть идеологически неверное, но всё же рабочее решение:
    \begin{minted}{c++}
        void operator+=(complex* a, complex b)
        {
            a->set_real(a->real() + b.real());
            a->set_imag(a->imag() + b.imag());
        }
    
        int main()
        {
            complex x, y;
            &x += y;
        }
    \end{minted}
    Но это выглядит странно и некрасиво. Специально для этой вещи в C++ введены ссылки. В первом приближении о них можно думать как об указателях, но со специальным синтаксисом. Вот что можно написать для ссылок:
    \begin{minted}{c++}
        T a;

        T& r = a;
        foo(r);
        r.bar;
    \end{minted}
    И это будет <<примерно равносильно>> вот такому на указателях:
    \begin{minted}{c++}
        T a;

        T* const r = &a;
        foo(*r);
        r->bar;
    \end{minted}
    При этом ссылка не бывает \mintinline{c++}|nullptr| (ну, правда, зачем вам константный указатель на \mintinline{c++}|nullptr|). И со ссылками можно писать вот такое:
    \begin{minted}{c++}
        void operator+=(complex& a, complex b)
        {
            a.set_real(a.real() + b.real());
            a.set_imag(a.imag() + b.imag());
        }
    \end{minted}
    И, кстати, по канону (то есть чтобы было как во встроенных типах) \mintinline{c++}|+=| возвращает lvalue~--- левый аргумент, а значит \mintinline{c++}|complex&|. Если бы мы возвращали просто \mintinline{c++}|complex|, то во-первых, получили бы лишнее копирование, а во-вторых, мы не смогли бы написать \mintinline{c++}|(a += b) += c|.
    \paragraph{Немного best practices (until C++23).}
    Ст\'{о}ит посмотреть, что делать, если вы реализуете свою строку. Вам хочется оператор \mintinline{c++}|[]|. По-хорошему он выглядит так:
    \begin{minted}{c++}
        struct string
        {
            char* data;
            size_t size;
            size_t capacity;

            // ...

            char& operator[](size_t index)
            {
                return data[index];
            }
        };
    \end{minted}
    Но на самом деле вы хотите вызывать этот оператор на неизменяемой строке тоже, а от неё указанный оператор не вызывается (нельзя кастовать \mintinline{c++}|const string* this| в просто \mintinline{c++}|string* this|). Поэтому вам придётся написать ещё один вариант этого же оператора:
    \begin{minted}{c++}
        const char& operator[](size_t index) const
        {
            return data[index];
        }
    \end{minted}
    Почему \mintinline{c++}|const char&|, а не \mintinline{c++}|char|? Чтобы от константности строки не зависело, lvalue у вас или rvalue. А \mintinline{c++}|const char&|~--- это lvalue, у него есть адрес.
    \paragraph{Проблемы с внутренними операторами.}
    Теперь про то, где писать операторы, внутри или вовне? Можно было бы подумать, что правила те же, что и с обычными функциями, но это не правда. Посмотрим вот на что:
    \begin{minted}{c++}
        struct complex
        {
            // ...
            
            /* implicit */ complex(double re)
            {
                // ...
            }
        };

        complex operator+(complex a, complex b)
        {
            return complex(a.real() + b.real(), a.imag() + b.imag());
        }

        void main()
        {
            complex a;
            a + 42; // 1
            42 + a; // 2
        }
    \end{minted}
    Оба варианта хорошо работают. А вот в таком написании:
    \begin{minted}{c++}
        struct complex
        {
            // ...
            
            /* implicit */ complex(double re)
            {
                // ...
            }

            complex operator+(complex b) const
            {
                return complex(re + b.real(), im + b.imag());
            }
        };

        void main()
        {
            complex a;
            a + 42; // 1
            42 + a; // 2
        }
    \end{minted}
    Тут уже последняя строка \mintinline{c++}|main|'а не компилируется, потому что компилятор преобразует её в \mintinline{c++}|42.operator+(a)|, что не верно, ведь левый аргумент точки не преобразуется никуда.\\
    Другой момент вот какой:
    \begin{minted}{c++}
        struct mytype
        {};

        mytype& operator++(mytype& a)
        {
            return a;
        }

        mytype foo()
        {
            // ...
        }

        void main()
        {
            ++foo();
        }
    \end{minted}
    Не компилируется, потому что \mintinline{c++}|foo| возвращает rvalue, а мы хотим lvalue. И это хорошо, а с внутренним же оператором всё работает, несмотря на бессмысленность.\\
    Поэтому всегда пишите операторы вовне. Если вы очень хотите иметь доступ к приватным полям/методам, то можно написать вот такую штуку:
    \begin{minted}{c++}
        struct complex
        {
            // ...

            friend complex operator+=(complex a, complex b)
            {
                return complex(a.re + b.re, a.im + b.im);
            }
        };
    \end{minted}
    То есть тут по сути внешняя функция, но пишется внутри класса и имеет доступ ко всему.\\
    Вообще, в C++11 вторую проблему особым образом пофиксили:
    \begin{minted}{c++}
        struct mytype
        {
            mytype& operator++() &
            {
                return *this;
            }
        }
        
        mytype foo()
        {
            // ...
        }
        
        void main()
        {
            ++foo();
        }
    \end{minted}
    Это гарантирует вам, что вызывать метод можно только на lvalue. Проблему с конверсиями же не исправить никак.
    \paragraph{Копирование и присваивание.}
    \begin{minted}{c++}
        int main()
        {
            string s = "Hello";
            string t = s;
        }
    \end{minted}
    Что это за странная вторая строка? А тут вот что. Компилятор умеет копировать все данные по умолчанию~--- всё что можно копируется покомпонентно. В случае с \mintinline{c++}|complex| всё хорошо работает, а тут мы скопируем указатель на данные, который потом освободим два раза. Ошибка, понятно, в том, что каждая строка должна иметь свой указатель на данные, раз уж мы всегда их освобождаем. Потому нам нужно какое-то кастомное копирование~--- копирующий конструктор. Он пишется вот так:
    \begin{minted}{c++}
        struct string
        {
            char* data;
            size_t size;
            size_t capacity;

            // ...

            string(const string& other)
            {
                size = other.size;
                capacity = other.capacity;
                data = (char*)malloc(capacity);

                memcpy(data, other.data, size);
            }
        };
    \end{minted}
    Но это не единственная проблема. Ведь мы можем написать вот что:
    \begin{minted}{c++}
        int main()
        {
            string s = "Hello";
            string t;

            t = s;
        }
    \end{minted}
    Всё изменилось! (Нет.) Тут надо прописать оператор присваивания, он выглядит почти также, только надо ещё освободить те данные, которые были до присваивания.
    \begin{minted}{c++}
        struct string
        {
            char* data;
            size_t size;
            size_t capacity;
            
            // ...
            
            string& operator=(const string& other)
            {
                free(data);

                size = other.size;
                capacity = other.capacity;
                data = (char*)malloc(capacity);
                
                memcpy(data, other.data, size);
            }
        };
    \end{minted}
    Одна лишь проблема~--- можно написать \mintinline{c++}|t = t|, но это исправляется при помощи \mintinline{c++}|if (this == &other)|.
    \paragraph{Специальные функции-члены класса.}
    Итого мы имеем четыре специальных метода, которые компилятор может генерировать за программиста: конструктор по-умолчанию, конструктор копирования, оператор присваивания и деструктор. Последние три генерируются, если вы их явно не написали, а конструктор по-умолчанию генерируется, если не написали ни один другой.
    \paragraph{Списки инициализации.}
    Посмотрим вот на что:
    \begin{minted}{c++}
        struct string
        {
            // ...

            string()
            {
                data = strdup("");
                size = capacity = 0;
            }
        
            string(const char* str)
            {
                // ...
            }

            string(const string& other)
            {
                // ...
            }

            string& operator=(const string& other)
            {
                // ...
            }

            ~string()
            {
                free(data);
            }
        };
        
        struct person
        {
            string name;
            string surname;

            person()
            {
                name = "Eric";
                surname = "Adams";
            }
        };

        int main()
        {
            person p;
        }
    \end{minted}
    Сколько тут будет аллокаций и деаллокаций памяти? В смысле сколько, \mintinline{c++}|malloc|'ов и \mintinline{c++}|free|? А вот 6. Почему? Давайте аккуратно считать.
    \begin{itemize}
        \item[0.] Мы вызываем конструктор класса \mintinline{c++}|person|.
        \item[2.] У двух \mintinline{c++}|string|'ов вызывается конструктор по умолчанию, каждый из которых выделает память.
        \item[4.] Неявно вызываются конструкторы \mintinline{c++}|string("Eric")| и \mintinline{c++}|string("Adams")|, которые тоже выделяют память.
        \item[6.] Два раза выполняется присваивание, которые также выделяют память.
    \end{itemize}
    Можно ли это оптимизировать? Компилятор теоретически может, конечно, но срабатывают эти оптимизации настолько редко и ненадёжно, что надеятся на них нельзя. Как это оптимизировать программисту? При помощи списков инициализации~--- хочется указать, что мы сразу вызываем конструктор \mintinline{c++}|name| и \mintinline{c++}|surname| от строки, а не по-умолчанию. Это делается при помощи такого синтаксиса:
    \begin{minted}{c++}
        struct person
        {
            string name;
            string surname;
            
            person() : name("Eric"), surname("Adams")
            {}
        };
        
        int main()
        {
            person p;
        }
    \end{minted}
    И тут аллокаций будет 2, как и ожидается. Кстати, если есть объект, который не имеет конструктора по-умолчанию (потому что логически не существует состояния по-умолчанию), то без списков инициализации просто невозможно.\\
    Что ст\'{о}ит сказать про это? А то что списки инициализации~--- это не только (и не столько) оптимизация, сколько по смыслу не то же самое, что мы написали сначала. Только для встроенных типов разницы особой нет, но вообще списки инициализации обычно и для них используются, потому что это гораздо более идиоматический код. А ещё ст\'{о}ит сказать, что если в списке инициализации не написано ничего для некоторого поля, то для него используется конструктор по-умолчанию.\\
    Поскольку деструктор у нас один, разрушаются поля в определённом порядке. А в конструкторе вы, в вроде как, можете в разном написать. Так вот нет, потому что список инициализации всегда вызывает конструкторы в порядке расположения полей структуры. И лучше бы вам писать список инициализации в этом же порядке, чтобы не путать людей. И, кстати, в инициализации некоторого поля можно использовать то, что было создано ранее. Аналогично с использованием \mintinline{c++}|this| в списке инициализации~--- можно, но осторожно, надо понимать, что конструктор \mintinline{c++}|this| ещё недовыполнился. Аналогично осторожным быть надо в деструкторе по той же причине.
    \paragraph{\texttt{= delete} и \texttt{= default}.}
    Помните <<Специальные функции-члены класса>>? А что если копирование не имеет смысла? То есть копировать либо нельзя, либо слишком трудоёмко. И в языке есть специальный синтаксис для этого:
    \begin{minted}{c++}
        string(const string& other) = delete;
    \end{minted}
    Начиная с некоторого C++, кстати, автогенерация конструктора копирования является deprecated. А если вы хотите явно прописать, что вам нужен стандартный сгенерированный конструктор, то вы можете написать
    \begin{minted}{c++}
        complex(const complex& other) = default;
    \end{minted}
    Для деструктора, конструктора копирования и оператора присваивания эта строка ничего не изменит, но вы можете захотеть явно сгенерировать конструктор по-умолчанию (напомню, он не генерируется, если есть другие конструкторы), то \mintinline{c++}|= default;|~--- ваш бро.
    \paragraph{\texttt{new} и \texttt{delete}.}
    Итак, мы знаем, что объекты создаются при заходе в блок, а удаляются при выходе. А если Вы хотите вызывать их в произвольный момент? Тогда есть \mintinline{c++}|new| и \mintinline{c++}|delete|. Вы пишете \mintinline{c++}|Type* p = new Type(...);|~--- это конструирует вам объект в куче, а \mintinline{c++}|delete p;| разрушает вам этот объект. Разница между ними и \mintinline{c}|malloc|---\mintinline{c}|free| (упрощённо) в том, что второй вариант пришёл к нам из C, где конструкторов и деструкторов не бывает, поэтому их он и не вызывает. Выделение на куче, кстати, немного дороже, чем на стеке.
    \paragraph{Ещё немного best practices.}
    Давайте вот ещё на что посмотрим. Наш класс \mintinline{c++}|string| вызывает в конструкторе аллокацию памяти. Так вот, вообще считается, что это кринж, так делать не надо. А ещё при присваивании C-строки в нашу строку мы сначала конструируем, а потом присваивает~--- давайте вместо этого явно пропишем \mintinline{c++}|operator=(const char*)|, и будет также 2 аллокации.
    \section{Исключения.}
    Вообще обычно сначала рассказывают про наследование и прочий кал, а потом про исключения. Это логично, потому что исключения требуют некоторых фактов из наследования. Но тогда исключения будут очень поздно, а домашки давать надо. Поэтому мы обсудим исключения, не вдаваясь в глубокие подробности о наследовании, а уже потом в конце дополним наш рассказ.
    \paragraph{Мотивация.}
    В коде ядра Linux и связанного с ним можно найти несколько функций, которые возвращают \mintinline{c++}|int| и выглядят так:
    \begin{minted}{c}
        int err;
        
        err = function(...);
        if (err)
            return err;
    \end{minted}
    И так много раз~--- вызвать тысячу функций, после каждой прочекать ошибку и вернуть, если есть. \textit{Очень красиво выглядит}. А если у нас есть что-то более сложное, чем последовательное выполнение, то было бы ещё более некрасиво и совсем непонятно. Вообще больше мотивации по исключениям можно посмотреть в лекциях по Java. И специально, чтобы такой херни не было, и придумали исключения. Пишется это так:
    \begin{minted}{c++}
        try
        {
            // Делаем что-то, что может завершиться с ошибкой.
            ...
            ...
            // Завершиться с ошибкой~--- это вот так:
            throw something;
            ...
            ...
        }
        // Что делать, если ошибка.
        catch (const error_type& e)
        {
            // Обрабатываем ошибку.
        }
        catch (const another_error_type& e)
        {
            // Обрабатываем другую ошибку.
        }
    \end{minted}
    Тогда всё до происхождения ошибки будет выполнено, а всё что после~--- нет. Как это взаимодействует с деструкторами? Ведь мы могли инициализировать локальные переменные до или после \mintinline{c++}|throw|, как с ними жить? Ну, то что проинициализировали~--- разрушаем, то что нет~--- не трогаем. Что, собственно, логично, точно то же самое делает \mintinline{c++}|return|, \mintinline{c++}|break| и всё остальное. Тут, кстати, как в Java есть наследование исключений, и если вы кидаете исключение наследуемого типа, вы можете поймать его как базового. И в стандартной библиотеке есть дерево наследования, наследующееся от \mintinline{c++}|std::exception|. Хотя вообще кидать вы можете всё что угодно~--- любой копируемый тип.
    \paragraph{\texttt{catch (...)} и \texttt{throw;}.}
    Ещё есть специальный тип \mintinline{c++}|catch|'а~--- \mintinline{c++}|catch (...)|, который ловит вообще всё что угодно. Но, как в известном анекдоте, есть один нюанс: \mintinline{c++}|catch (...)| ловит не обязательно исключения C++. В Windows, например, исключения C++~--- это частный случай исключений, встроенных в Windows. И эти встроенные исключения также ловятся при помощи \mintinline{c++}|catch (...)|, что вы хотите явно не всегда. Системные исключения вообще не надо ловить, если взять POSIX'ивое исключение \mintinline{c++}|abi::__forced_unwind| и съесть его, то \href{https://udrepper.livejournal.com/21541.html}{может быть всё очень плохо}. Ещё более интересный момент есть в GCC. Там исключения поддерживаются не только плюсовые, а и другие разные, которые работают не так. Куча языков реализуют исключения так, что \mintinline{c++}|catch| может либо прервать, либо продолжить работу. В C++ такого нет, но ABI такое поддерживает. И такое уж точно вы не хотите ловить. Но вообще \mintinline{c++}|catch (...)| имеет идиоматическое использование:
    \begin{minted}{c++}
        catch (...)
        {
            // Что-то почистим.
            throw;
        }
    \end{minted}
    \mintinline{c++}|throw;| просто берёт то, что поймал и кидает его же. Без копирования. Поэтому подобный синтаксис даже в обычных \mintinline{c++}|catch| бывает полезен, так как он лучше, чем
    \begin{minted}{c++}
        catch (const type& e)
        {
            throw e;
        }
    \end{minted}
    В варианте выше есть лишнее копирование с \hyperref[par:slicing]{slicing} (сейчас не важно, что это). А \mintinline{c++}|throw;| не имеет копирования.
    \paragraph{Best practices и worst practices.}
    Совет~--- всегда ловите исключение по константной ссылке. Если Вы, конечно, не хотите исключение менять, тогда просто по ссылке (может, даже rvalue ссылке...).\\
    Ещё советы. Не кидайте указатель на исключение (то есть не пишите \mintinline{c++}|throw new error_type(...);|). Если вы так сделаете, ловить вам надо будет \mintinline{c++}|catch (error_type*)|, и тогда надо не забыть сделать \mintinline{c++}|delete|. И понятно, что нельзя делать \mintinline{c++}|catch (...)|, потому что тут вы никак не сделаете \mintinline{c++}|delete|.
    \paragraph{Цена исключений.}
    Если открыть что-то в интернете, вам скажут, что исключения~--- это бесконечно дорого. Чтобы говорить об этом серьёзно, то сначала надо понять, какую операцию мы измеряем по времени. Как работает \mintinline{c++}|try|? Есть две стратегии реализации.
    \begin{enumerate}
        \item Поддерживать связный список на стеке, по которому в случае чего мы и идём.\\
        Проблема тут в том, что каждый вход в \mintinline{c++}|try| (даже если исключения не происходит) жрёт время и память. А исключения у вас должны происходить редко. Поэтому сейчас эту реализацию не используют.
        \item Zero-cost исключения. Компилятор для каждой инструкции записывает, куда идти в случае исключения.\\
        Тогда вход в блок \mintinline{c++}|try| не генерирует абсолютно никакой код. И тут у нас при \mintinline{c++}|throw| никакого оверхеда от исключений почти нет. Почему <<почти>>? Потому что в общем случае код может быть не совсем одним и тем же. Если мы делаем какие-то операции с памятью, например. Мы должны видеть все эффекты до \mintinline{c++}|throw| и не видеть ни одного после. Поэтому компилятор может меньше переупорядочивать код в таком случае. И если написать бенчмарк для тестировки этого, то результат будет в том, что замедление будет небольшим.
    \end{enumerate}
    Есть заморочки с конкретными реализациями (в Itanium ABI, как уже обсуждалось, есть мем с продолжением выполнения после \mintinline{c++}|throw|). Поэтому Itanium ABI раскручивает стек два раза~--- чтобы проверить, надо ли прерываться и чтобы потом вызвать деструкторы.
    \paragraph{\texttt{noexcept}. \texttt{std::terminate}.}
    Что будет, если кинуть исключение из деструктора при обработке исключения? То есть мы получили исключение, вызываем деструкторы, и получаем исключение там. По стандарту, это ошибка в программе, считается, что при двух исключениях происходит что-то непоправимо ужасное, и в программе вызывается \mintinline{c++}|std::terminate|~--- экстренное завершение программы. Более простой способ получить \mintinline{c++}|std::terminate|~--- выкинуть исключение в \mintinline{c++}|main|. Кстати, поскольку деструкторы не должны бросать исключение, такие функции как \mintinline{c++}|free| явно в языке помечены как неспособные бросать исключения.\\
    Ещё один нюанс при бросании исключения~--- функции можно пометить как \mintinline{c++}|noexcept| (после круглых скобок), чтобы указать, что функция не бросает исключений. Бросание исключений из таких функций также приводит к \mintinline{c++}|std::terminate|. Ещё помимо \mintinline{c++}|noexcept| можно указать \mintinline{c++}|noexcept(/* булевое выражение */)|. Это нужно, если вы шаблонный код пишете, и у вас функция может в зависимости от шаблона либо быть \mintinline{c++}|noexcept|, либо нет. И вот что важно знать~--- деструкторы по-умолчанию \mintinline{c++}|noexcept|. Если вам нужно это исправить~--- \mintinline{c++}|noexcept(false)| вам в помощь. Тогда при обычном бросании исключения в деструкторе всё будет хорошо, а при обработке исключений~--- \mintinline{c++}|std::terminate|.
    \paragraph{RAII.}
    Вот на что посмотрим:
    \begin{minted}{c++}
        int* p = new int(1);
        int* q = new int(2);

        // ...

        delete p;
        delete q;
    \end{minted}
    Тут с исключениями есть проблемы. Если у нас второй конструктор кинет исключение (или память не выделится), то мы не освободим первый объект. Или если у нас что-то после этого бросит исключение, то мы вообще ничего не освободим. Поэтому долгое время ходило мнение, что исключения нельзя использовать без сборщика мусора. Но потом было показано, что это вообще не только про память, но и про открытие файлов тоже, например. Если написать так:
    \begin{minted}{c++}
        FILE* my_fopen(const char* name, const char* mode)
        {
            FILE* result = fopen(name, mode);
            if (result == nullptr)
                throw std::runtime_error("No such file.");
            return result;
        }

        int main()
        {
            FILE* p = my_fopen("1.txt", "r");
            FILE* q = my_fopen("2.txt", "r");

            // ...
        }
    \end{minted}
    Проблема будет такой же. Но, например, в такой ситуации никаких проблем нет
    \begin{minted}{c++}
        int main()
        {
            std::string p = "Hello";
            std::string q = "World";
            
            // ...
        }
    \end{minted}
    Почему тут нет проблем? Потому что у строк есть деструктор, которых их освободит. Про классы, которые в конструкторе что-то выделяют, а в деструкторе~--- освобождают говорят, что они удовлетворяют идиоме RAII (resource acquisition is initialization). То есть на конструкторе мы захватываем ресурс, а на деструкторе освобождаем его. И в стандартной библиотеке всё так и есть. Хотя вообще данная идиома не очень хорошо названа, потому что выделять-то мы не обязаны в конструкторе, мы можем вызвать \mintinline{c++}|std::istream::open|, чтобы не при конструкторе файл открыть, а потом. Но в деструкторе мы всё равно закроем файл, если открывали.
    \subparagraph{Умные указатели.}
    Так вот, в стандартной библиотеке есть набор классов, которые называют <<умными указателями>>, которые  по сути и являются указателями, но по RAII. Самый простой из них~--- \mintinline{c++}|std::unique_ptr<T>|. Давайте напишем его сами:
    \begin{minted}{c++}
        template <class T> // Пока не смотрите на эту строку слишком внимательно.
        class unique_ptr
        {
        private:
            T* ptr;

        public:
            unique_ptr() : ptr(nullptr)
            {}

            unique_ptr(T* ptr) : ptr(ptr)
            {}

            unique_ptr(const unique_ptr&) = delete;
            unique_ptr& operator=(const unique_ptr&) = delete;

            ~unique_ptr()
            {
                delete ptr;
            }

            T& operator*() const
            {
                return *ptr;
            }

            T* operator->() const
            {
                return ptr;
            }

            T* get() const
            {
                return ptr;
            }

            void reset(T* new_ptr = nullptr)
            {
                delete ptr;
                ptr = new_ptr;
            }

            T* release()
            {
                T* result = ptr;
                ptr = nullptr;
                return result
            }
        };
    \end{minted}
    Вообще функции типа \mintinline{c++}|release| использовать опасно, потому что они убирают RAII'шную обёртку над указателем, и надо следить, чтобы в момент исключения он не оказался сырым.\\
    Кстати, подобные RAII'шные классы полезны, даже если мы не пользуемся исключениями. Если мы в C открываем три файла, то писать придётся так:
    \begin{minted}{c}
        FILE* f1 = fopen("1.txt", "r");
        if (f1 == NULL)
            return -1;

        FILE* f2 = fopen("2.txt", "r");
        if (f2 == NULL)
        {
            fclose(f1);
            return -1;
        }

        FILE* f3 = fopen("3.txt", "r");
        if (f3 == NULL)
        {
            fclose(f2);
            fclose(f1);
            return -1;
        }

        // ...

        fclose(f3);
        fclose(f2);
        fclose(f1);

        return 0;
    \end{minted}
    Это выглядит некрасиво, и забыть что-то можно очень легко. Как это делают в C, где нет деструкторов? Так:
    \begin{minted}{c}
        res = 0;

        FILE* f1 = fopen("1.txt", "r");
        if (f1 == NULL)
            return -1;
        
        FILE* f2 = fopen("2.txt", "r");
        if (f2 == NULL)
        {
            res = -1;
            goto close_f1;
        }
        
        FILE* f3 = fopen("3.txt", "r");
        if (f3 == NULL)
        {
            res = -1;
            goto close_f2_and_f1;
        }
        
        // ...
        
        fclose(f3);
close_f2_and_f1:
        fclose(f2);
close_f1:
        fclose(f1);

        return res;
    \end{minted}
    \paragraph{\texttt{operator new} и \texttt{operator delete}.}
    Давайте теперь подумаем, что делать с нашим классом \mintinline{c++}|string|. Он весь некорректный, ведь мы вызываем \mintinline{c++}|malloc|, где память нам могут не дать. Поэтому надо взять некий аналог \mintinline{c++}|malloc|, который бросает исключение в случае нехватки памяти. И, о чудо, он такой есть в стандартной библиотеке. Он называется \mintinline{c++}|operator new|. И ещё есть \mintinline{c++}|operator delete| как парный к нему. Это не то же самое, что и \mintinline{c++}|new|---\mintinline{c++}|delete|, это именно что своя штука. И \mintinline{c++}|operator new| отличается от \mintinline{c++}|malloc| только тем, что исключение кидает. Но это всё равно не позволяет вам выделять память при помощи \mintinline{c++}|operator new|, а освобождать при помощи \mintinline{c++}|free|.\\
    Теперь найдите ошибку тут:
    \begin{minted}{c++}
        struct string
        {
            // ...

            string& operator=(const string&)
            {
                if (this == &other)
                    return;

                operator delete(data);

                size = other.size;
                capacity = other.capacity;
                data = (char*)operator new(size + 1);

                memcpy(data, other.data, size + 1);

                return *this;
            }
        };
    \end{minted}
    \paragraph{Exception safety.}
    Тут есть большая проблема~--- соглашения об исключениях. Есть у нас обломается \mintinline{c++}|operator new|, то вы останетесь в некорректном состоянии (ненулевые \mintinline{c++}|size| и \mintinline{c++}|capacity|, но неверный \mintinline{c++}|data|). Более того, эту строку даже удалить будет нельзя, потому что у неё \mintinline{c++}|data| указывает на некоторые данные, которые мы уже удалили, и будет double-\mintinline{c++}|free|. Поэтому правильно будет написать всё как-то так:
    \begin{minted}{c++}
        string& operator=(const string&)
        {
            if (this == &other)
               return;

            char* tmp;
            if (other.size != 0)
            {
                tmp = (char*)operator new(size + 1);
                memcpy(tmp, other.data, size + 1);
            }
            else
                tmp = nullptr;

            operator delete(data);
            
            size = other.size;
            capacity = other.capacity;
            data = tmp;

            return *this;
        }
    \end{minted}
    Мораль~--- если у вас есть исключения, наивно писать код нельзя. А вообще есть научное название для этого~--- exception-safe код. Выделяют различные гарантии в случае происхождения исключения.
    \begin{enumerate}
        \item Nothrow. Исключения не бросаются.
        \item Strong. Если в процессе выполнения операции происходит исключение, объект возвращается в состояние до операции. (Именно так работает присваивание выше.)
        \item Basic. У наших данных сохраняются все инварианты, но в каком конкретно состоянии мы останемся~--- неизвестно. (Используется, если нельзя предоставить строгую гарантию. Если мы уже отправили ракету на Марс, вернуть её обратно мы не можем так легко.)
    \end{enumerate}
    Какие-то более слабые гарантии~--- не exception-safe, это ошибка в программе. Общее правило, как жить с исключениями, выглядит так: для каждой строки надо задать вопрос, что будет, если в ней произойдёт исключение. Если так проверить всё, то функция ОК.\\
    Давайте немного пофантазируем на тему \mintinline{c++}|std::vector|. Какие его методы каким гарантиям удовлетворяют? Понятно, какие-нибудь \mintinline{c++}|size|, \mintinline{c++}|capacity|, \mintinline{c++}|empty| или \mintinline{c++}|begin| и \mintinline{c++}|end| не бросают исключений, с чего бы им. А вот что можно сказать про \mintinline{c++}|pop_back|? Ну, вроде как кидать там нечего, но ведь деструктор элемента может теоретически и бросать... А вот нет~--- все стандартные контейнеры накладывают некоторые условия на принимаемые ими типы. И абсолютно все из них требуют \mintinline{c++}|noexcept|-деструктора. Хорошо, то есть \mintinline{c++}|pop_back|~--- это nothrow? А что будет, если мы удалим элемент из пустого вектора? А undefined behaviour. То есть мы можем спокойно вернуть \mintinline{c++}|*nullptr| и ничего не бросать в таком случае. Поэтому если нам хочется, мы вполне можем написать \mintinline{c++}|vector|, который имеет \mintinline{c++}|noexcept|-\mintinline{c++}|pop_back|. А какие функции имеют базовые гарантии? \mintinline{c++}|insert| и \mintinline{c++}|erase|. Вообще их можно сделать так, чтобы гарантии были строгими, но они базовые, чтобы можно было их выполнять через \mintinline{c++}|swap|'ы. Обычно \mintinline{c++}|swap|'ы не бросают исключение, но вообще могут делать это. И вообще мы по сути получаем тут, что есть \mintinline{c++}|swap| не бросает, то гарантии у нас строгие, а иначе~--- базовые.
    \paragraph{Swap-trick.}
    Рассмотрим \mintinline{c++}|std::vector| с \mintinline{c++}|erase|, у которого базовые гарантии. А теперь следите за руками:
    \begin{minted}{c++}
        void erase_strong(vector& v, iterator where)
        {
            vector copy = v;
            copy.erase(where);
            copy.swap(v);
        }
    \end{minted}
    И лёгким движением руки базовая гарантия превращается в строгую. Это называется swap-trick. При помощи него же можно и внутри своего кода давать строгие гарантии там, где вы не хотите думать. Например, мы писали сложный оператор присваивания для наших строк, который ещё и на конструктор копирования очень сильно был похож. Оп:
    \begin{minted}{c++}
        string& operator=(const string& other) &
        {
            string copy = other;
            std::swap(copy, *this);
            return *this;
        }
    \end{minted}
    И код становится элегантнее. Можно даже ещё проще:
    \begin{minted}{c++}
        string& operator=(string other) &
        {
            std::swap(other, *this);
            return *this;
        }
    \end{minted}
    Теперь вам даже явно руками копию делать не надо.
    \paragraph{RAII вокруг объекта, кидающего исключение при закрытии.}
    Давайте теперь рассмотрим POSIX, в котором мы файлы открываем.
    \begin{minted}{c++}
        struct file_descriptor
        {
        public:          
            file_descriptor(const char* filename)
                : fd(open(filename, O_RDONLY))
            {}

            ~file_descriptor()
            {
                close(fd);
            }
        private:
            int fd;
        };
    \end{minted}
    В чём тут проблема? В том, что на \mintinline{console}|man| написано, что \mintinline{c++}|close| имеет возвращаемое значение, в нём может произойти ошибка. И с \mintinline{c++}|close| был полный треш. В POSIX долгие операции могли быть прерваны, и \mintinline{c++}|close| был таковым. Причём никто не знает, почему. Единственное объяснение~--- при работе с магнитными лентами он перематывал их на начало.\\
    Так вот \mintinline{c++}|close| выполняет две операции~--- дозаписывает данные до конца, чтобы закрыть файл и возвращает файловый дескриптор операционной системе. Поэтому в идеальном мире мы бы разбили его на две~--- какой-нибудь \mintinline{c++}|flush|, который дозаписывает данные и именно что \mintinline{c++}|close|. И примерно такого поведения мы и хотим, а кидать исключение в случае провала \mintinline{c++}|close| не хотим, потому что двойное исключение. Давайте напишем всё вот так:
    \begin{minted}{c++}
        struct file_descriptor
        {
        public:          
            file_descriptor(const char* filename)
            : fd(open(filename, O_RDONLY))
            {}
            
            void flush()
            {
                int result = close(fd);
                if (result != 0)
                    throw std::runtime_exception("File closing failed.");
                fd = -1;
            }
            
            ~file_descriptor()
            {
                if (fd != -1)
                    close(fd);
            }
        private:
            int fd;
        };
    \end{minted}
    Теперь из деструктора мы ничего не бросаем. Но теперь мы обязаны явно извне вызывать \mintinline{c++}|flush|, если заинтересованы в получении ошибок при закрытии.
    \section{Лирические отступление про оптимизации.}
    Это скорее практика, а не теория, потому что в следующей домашке надо нужны будут некоторые оптимизации. И без предварительного пояснения люди не справляются с их написанием. В добавок к этому существует некоторый контекст~--- надо понимать, зачем мы делаем то что делаем в этом самом ДЗ.
    \paragraph{Оптимизация аллокаций.}
    Мы уже обсуждали, что самое низкоуровневое API для выделения и освобождения памяти~--- \mintinline{c++}|mmap| и \mintinline{c++}|munmap|. Нам же никто не мешает самим написать обёртку над ними, чтобы у нас были свои \mintinline{c++}|malloc| и \mintinline{c++}|free|? Возьмём наивнейшую реализацию~--- \mintinline{c++}|malloc| просто вызывает \mintinline{c++}|mmap| (с некоторыми проверками). Если провести эксперимент, можно увидеть, что такая реализация будет капец медленной. Более того, она и памяти будет есть в 15 раз больше, чем стандартные \mintinline{c++}|malloc| и \mintinline{c++}|free|. У нас ведь были тесты \mintinline{c++}|mmap|'а (где мы обращались к памяти после выделения), если также протестировать \mintinline{c++}|malloc|, то получим, что за одну секунду мы можем сделать 45000000 \mintinline{c++}|malloc|'ов (стандартных, не наших новых) и \mintinline{c++}|free|, но 200000 \mintinline{c++}|mmap|'ов и \mintinline{c++}|munmap|'ов.\\
    Следовательно стандартные аллокаторы делают что-то умное. Если посмотреть на то, что именно, то выяснится, что у них разные правила для больших и маленьких объектов. Причём с маленькими объектами все взаимодействуют одинаково, а с большими~--- по-разному. Почему? Потому что 99\% аллокаций~--- аллокации маленьких кусочков памяти. И для таких ситуаций уже придумали, как оптимально жить. Давайте простоты ради ограничимся объектами размера 32 байта. У нас есть большой кусок данных и нам надо где-то хранить, какие его части заняты, а какие~--- свободны. И уметь быстро доставать случайный свободный и быстро освобождать. Это можно сделать односвязными списком~--- список хранит незанятые данные, причём именно в этих данных и хранится указатель на следующий свободный кусок. И это в целом рабочая идея. Именно что идея, потому что нужно уметь возвращать данные операционной системе, а со списком это сложно. Как легко поправить стратегию, когда объекты разного размера? Сделать несколько блоков под разные размеры, и округлять вверх до существующего размера.
    \paragraph{Copy-on-write.}
    Мы имели нашу строку. Вопрос~--- а зачем мы всегда копируем строку при копировании? Можем ли мы сказать, что новая строка ссылается на те же данные? Ну, можем, просто иногда придётся копировать при изменении. Всё что для этого нужно~--- сделать счётчик ссылок на данный объект, если он 1~--- то просто меняем, иначе копируем и меняем. Это называется copy-on-write. При этом если строка пустая, то она является ссылкой на одну <<the пустую строку>>.
    \paragraph{Small-object.}
    Одна лишь проблема~--- copy-on-write оптимизирует нам большие строки, а нам хочется как-то оптимизировать маленькие, маленькие чаще встречаются. Для этого есть следующий трюк: У нас есть \mintinline{c++}|size|, \mintinline{c++}|capacity| и \mintinline{c++}|data|. Это 24 байта. Так а давайте для маленьких строк вместо \mintinline{c++}|data| и \mintinline{c++}|capacity| хранить маленькую строку. То есть теперь наши строки выглядят как
    \begin{minted}{c++}
        struct string
        {
            size_t size;
            union
            {
                dynamic_buffer dynamic_storage;
                char static_storage[sizeof(dynamic_buffer)];
            }
        };
    \end{minted}
    И если у нас \mintinline{c++}|size <= sizeof(dynamic_buffer)|, то мы использует \mintinline{c++}|static_storage|, а иначе \mintinline{c++}|dynamic_storage|.
    Это small-object оптимизация. Конкретно в такой реализации она работает не очень хорошо, но можно оптимизировать:
    \begin{figure}[H]
        \begin{tikzpicture}
            \draw[fill=cyan!50!white] (11.7,1) rectangle (8,0) rectangle (4,1) rectangle (0,0);
            \draw[fill=orange] (11.7,1) rectangle (12,0);
            \node[scale=1.5] at (11.85,.5) {1};
            \node[scale=1.5] at (2,.5) {data};
            \node[scale=1.5] at (6,.5) {size};
            \node[scale=1.5] at (9.85,.5) {capacity};
        \end{tikzpicture}\vspace{1cm}
        \begin{tikzpicture}
            \draw[fill=green] (12,1) grid (0,0) rectangle (11.7,1);
            \draw[fill=orange] (11.7,1) rectangle (12,0);
            \node[scale=1.5] at (11.85,.5) {0};
            \node[scale=1.5] at (11.35,.5) {3};
            \newcounter{tmp}
            \setcounter{tmp}{0}
            \foreach\l in {S,m,a,l,l, ,s,t,\textbackslash0}
            {
                \node[scale=1.5] at (\value{tmp}+.5,.5) {\l};
                \addtocounter{tmp}{1}
            }
        \end{tikzpicture}\deletecounter{tmp}
        \begin{tikzpicture}
            \draw[fill=green] (12,1) grid (0,0) rectangle (11.7,1);
            \draw[fill=orange] (11.7,1) rectangle (12,0);
            \node[scale=1.5] at (11.85,.5) {0};
            \node[scale=1.5] at (11.35,.5) {2};
            
            \newcounter{tmp}
            \setcounter{tmp}{0}
            \foreach\l in {S,m,a,l,l, ,s,t,r,\textbackslash0}
            {
                \node[scale=1.5] at (\value{tmp}+.5,.5) {\l};
                \addtocounter{tmp}{1}
            }
        \end{tikzpicture}\deletecounter{tmp}
        \begin{tikzpicture}
            \draw[fill=green] (12,1) grid (0,0) rectangle (11.7,1);
            \draw[fill=orange] (11.7,1) rectangle (12,0);
            \node[scale=1.5] at (11.85,.5) {0};
            \node[scale=1.5] at (11.35,.5) {1};
            \newcounter{tmp}
            \setcounter{tmp}{0}
            \foreach\l in {S,m,a,l,l, ,s,t,r,i,\textbackslash0}
            {
                \node[scale=1.5] at (\value{tmp}+.5,.5) {\l};
                \addtocounter{tmp}{1}
            }
        \end{tikzpicture}\deletecounter{tmp}
        \begin{tikzpicture}
            \draw[fill=green] (12,1) grid (0,0) rectangle (11.7,1);
            \draw[fill=orange] (11.7,1) rectangle (12,0);
            \node[scale=1.5] at (11.85,.5) {0};
            \node[scale=1.5] at (11.35,.5) {\textbackslash0};
            \newcounter{tmp}
            \setcounter{tmp}{0}
            \foreach\l in {S,m,a,l,l, ,s,t,r,i,n}
            {
                \node[scale=1.5] at (\value{tmp}+.5,.5) {\l};
                \addtocounter{tmp}{1}
            }
        \end{tikzpicture}
    \end{figure}\deletecounter{tmp}\noindent
    Давайте отводить старший бит последнего байта структуры под флаг, короткая строка или длинная. При этом сам последний байт (для короткого объекта) хранит количество оставшихся символов. При записывании нового символа в конец мы уменьшаем это число, и когда память в маленьком объекте кончается совсем, там получается \mintinline{c++}|0|, а \mintinline{c++}|0|~--- это то же самое что \mintinline{c++}|'\0'|. Примерно так работает строка в реализации Facebook'а.\\
    Теперь вопрос, в каком порядке применять copy-on-write и small-object? Ну, объективно вовне надо пихать small-object, а внутрь~--- copy-on-write. Почему? Ну, посмотрим что будет, если наоборот. У нас будет указатель, по которому \mintinline{c++}|ref_count| и наш \mintinline{c++}|union|. То есть для маленьких строк мы всё равно будем хранить \mintinline{c++}|ref_counter| (который нам не сдался) и всё равно будет indirection. Это строго хуже даже глупой реализации.
    \section{Undefined behaviour.}
    Если просто дать определение этой штуки, возникнет вопрос, на кой она нужна. Поэтому начнём мы с истории из жизни компиляторов.
    \paragraph{Aliasing. \texttt{restrict}.}
    Напишем вот что:
    \begin{minted}{c++}
        void sum(float* res, float const* in, size_t n)
        {
            for (size_t i = 0; i < n; i++)
                *res += in[i];
        }
    \end{minted}
    Компилятор же умеет оптимизировать код, почему бы ему не завести регистр, где он будет накапливать чиселки, после чего запишет их в \mintinline{c++}|*res|. И он действительно заведёт регистр \mintinline{nasm}|XMM0|. Но почему-то он будет записывать результат в \mintinline{c++}|*res| на каждой итерации цикла, а не после него. Почему? Потому что может так оказаться, что указатели \mintinline{c++}|in| и \mintinline{c++}|res| ссылаются в одно и то же место. И тогда нам бы надо прибавить корректное значение. У компилятора нигде не написано, что такого быть не может, хотя ни один адекватный человек так делать не будет. Научным языком ситуация с двумя ссылками на одно место называется aliasing.\\
    Ещё один пример на ту же тему:
    \begin{minted}{c++}
        void memcopy(char* dst, char* src, size_t count)
        {
            for (size_t i = 0; i < n; i++)
                dst[i] = src[i];
        }
    \end{minted}
    Тут проблема та же самая~--- это должно быть копирование, но если его вызвать от пересекающихся массивов, будет не оно. Так что для компилятора наличие aliasing'а~--- это причина, почему он не может применять многие оптимизации. Поэтому разработчики компиляторов пытались найти какие-нибудь правила, которым помогли бы им в оптимизации. И нашли они вот что. Мы говорили о том, что нельзя в общем случае предполагать размеры \mintinline{c++}|int|'а и \mintinline{c++}|short|'а. Поэтому разработчики компиляторов нагло этим воспользовались:
    \begin{minted}{c++}
        int foo(int* a, int* b)
        {
            *a = 1;
            *b = 2;
            return *a;
        }
    \end{minted}
    Тут нельзя оптимизировать \mintinline{c++}|return *a| в \mintinline{c++}|return 1|. Зато тут:
    \begin{minted}{c++}
        int foo(int* a, short* b)
        {
            *a = 1;
            *b = 2;
            return *a;
        }
    \end{minted}
    Вполне можно, ведь некорректно одним указателем ссылаться на \mintinline{c++}|int| и \mintinline{c++}|short|. Это strict aliasing rule~--- вы не можете ссылаться на одни и те же данные разными типами. У него есть два исключения. Первое: \mintinline{c++}|int| и \mintinline{c++}|unsigned| (или любые другие данные, отличающиеся только знаковостью). Второе: \mintinline{c++}|char|, \mintinline{c++}|unsigned char| и \mintinline{c++}|std::byte|, которые могут alias'ить всё что угодно. В C \mintinline{c++}|signed char| тоже может, в C++ (по стандарту)~--- нет. Это может привести к интересным эффектам. Если мы попытаемся заполнить \mintinline{c++}|std::vector<char>| нулями, то компилятор будет перечитывать \mintinline{c++}|data| и \mintinline{c++}|size|, а то вдруг данные вашего вектора alias'ятся с его полями. Такую же проблему, но в меньших масштабах, имеем с \mintinline{c++}|std::vector<size_t>|, поскольку у нас \mintinline{c++}|size|~--- это \mintinline{c++}|size_t|.\\
    Такая проблема приводила к тому, что всякие численные методы не писались на C, а писались на Fortran'е, в силу специфики которого компилятор имеет право предполагать, что его аргументы на alias'ятся. Чтобы как-то жить с alias'ингом в C в стандарте C99 даже добавили ключевое слово \mintinline{c}|restrict|, которое показывает, что данный указатель не alias'ится ни с одним другим. В C++ его нет, но многими компиляторами поддерживается как расширение и пишется как \mintinline{c++}|__restrict|. И если написать
    \begin{minted}{c++}
        void sum(float* __restrict res, float const* in, size_t n)
        {
            for (size_t i = 0; i < n; i++)
            *res += in[i];
        }
    \end{minted}
    То компилятор не только вытащит запись в \mintinline{c++}|*res| вне цикла, но начнёт ещё и векторизацию использовать, что ускорит код в 4 раза.\\
    Хорошо, мы написали функцию, на которую мы повесили \mintinline{c++}|__restrict|. Вопрос~--- что произойдёт, если мы-таки передадим туда что-то, что alias'ится? Да хрен его знает, честно говоря. В зависимости от компилятора код может быть оптимизирован, а может быть не. Вы не можете заставить компилятор оптимизировать код по стандарту, а значит не можете заставить сделать что-то конкретное~--- произойдёт то, что произойдёт. Тут вы по сути вступаете в контракт с компилятором~--- Вы не передаёте какой-то кал, а компилятор включает оптимизации. Если вы нарушите свои условия, ваш код может сделать всё что угодно. Только тут пример показателен, потому что вы сами кровью подписали контракт, написав \mintinline{c++}|__restrict|.
    \paragraph{Сдвиги.}
    А вот если вы сделаете
    \begin{minted}{c++}
        int shift(int a, int b)
        {
            return a << b;
        }
    \end{minted}
    То непонятно, что произойдёт, если вы передадите \mintinline{c++}|b| или отрицательное, или большее 32. На разных платформах сдвиги работают по разному. На x86 вот, вообще 32- и 64-битные числа сдвигаются по модулю битности, а 16-битные~--- не по модулю 16 бит, а тоже 32. Поэтому конкретно прописать, что произойдёт, нельзя, на каких-то платформах нужно будет \mintinline{c++}|if|'ать. Поэтому это тоже UB. Но в данном примере ничего кровью не подписывали. Впрочем, данный пример имеет ещё одну особенность~--- можно определить, что под каждую конкретную платформу имеем конкретное поведение. А есть случай, когда мы и так делать не можем.
    \paragraph{Разыменование нулевого указателя и обращение вне массива.}
    Почему нельзя его разыменовывать, ведь согласно страничной адресации какое-то значение мы получим. Ну, во-первых, страничная адресация есть не везде, увы, вы проиграли. Во-вторых, даже если у вас страничная адресация, то разные ОС сообщают о обращении к \mintinline{c++}|nullptr| по-разному, и это сложно стандартизировать. Хотя на самом деле есть более важный аргумент. Ну, хорошо, пусть у вас есть какой-то обработчик обращения к \mintinline{c++}|nullptr|. Тогда компилятор не может удалить обращение к неиспользуемой переменной (вдруг там \mintinline{c++}|nullptr|, это же надо обработать), не может переупорядочивать обращения к памяти (в обработчике надо видеть все обращения, произошедшие до, но не видеть все после). В ту же степь идут обращения за край массива: если это проверять и обрабатывать, нельзя будет переупорядочить обращения к памяти.
    \paragraph{Переполнение типов.}
    \begin{minted}{c++}
        bool is_maximal_int(int a)
        {
            return a + 1 < a;
        }
    \end{minted}
    Этот код будет оптимизирован компилятором в \mintinline{c++}|return false|. Почему? Ну, смотрите, если \mintinline{c++}|a|~--- это не максимальный \mintinline{c++}|int|, то возвращаем \mintinline{c++}|false|, иначе по стандарту UB, значит можно вернуть что угодно, например тоже \mintinline{c++}|false|. По стандарту в \textbf{знаковых} числах (и только в них) если результат операции \mintinline{c++}|+|, \mintinline{c++}|-| или \mintinline{c++}|*| не представим в вашем типе, то это UB.
    \paragraph{\texttt{const}.}
    Ещё весёлая ситуация есть с \mintinline{c++}|const|'ами.
    \begin{minted}{c++}
        int const PI = 3;
        int length(int r)
        {
            return 2 * PI * r;
        }
    \end{minted}
    Так вот, это оптимизируется в умножение на \mintinline{c++}|6|. Несмотря на то, что технически никто не мешает вам снять \mintinline{c++}|const| при помощи \mintinline{c++}|const_cast| и записать что-то другое в \mintinline{c++}|PI|. Потому что когда вы снимаете \mintinline{c++}|const|, а потом что-то записываете~--- UB.
    \paragraph{Намеренное неопределённое поведение.}
    В GCC есть прекрасная функция, которая называется \mintinline{c++}|__builtin_unreachable|. Всё что она делает~--- делает UB. Нахуя, а главное зачем? Чтобы компилятор мог как ему вздумается оптимизировать то, что вы и ваши коллеги считаете недостижимым. Например, если у вас есть \mintinline{c++}|switch|, где вы перебрали все случаи, то в \mintinline{c++}|default| можно написать эту функцию, и тогда компилятор не будет проверять, что вы попадёте в один из \mintinline{c++}|case|'ов.
    \paragraph{Best practices.}
    Хорошо, а как делать надо?
    \begin{itemize}
        \item Снимать \mintinline{c++}|const| всегда плохо, просто так не делайте.
        \item Если вам нужна операция с переполнением, в GCC есть \mintinline{c++}|__builtin_add_overflow|, который точно и без UB делает то, что вам нужно.
        \item Если вы хотите кастить указатели друг в друга, то вам нужен \mintinline{c++}|memcpy|. Причём \mintinline{c++}|memcpy| компилятор нормально оптимизирует, получается как каст, только по стандарту. В случае \mintinline{c++}|memcpy| вы получите всё так, как на текущей архитектуре работает (т.е. LE либо BE), а если вы хотите конкретный порядок байт вне зависимости от системы, напишите что-то вида
        \begin{minted}{c++}
            ptr[3] | ptr[2] << 8 | ptr[1] << 16 | ptr[0] << 24
        \end{minted}
        Это даже медленно не будет, потому что компилятор просекает такие паттерны и оптимизирует их.
    \end{itemize}
    \paragraph{Способы неправильно воспринимать UB.}
    Люди иногда считают, что компилятор может портить при оптимизации программы, содержащие UB. На самом деле это некорректно, потому что компилятор портит не программу целиком, а только на тех входных данных, которые к UB приводят. Пока вы подаёте программе те данные, на которых нет UB, она обязана работать корректно, даже если в каком-то месте, в каком-то другом случае может быть UB. Например,
    \begin{minted}{c++}
        struct tun_struct *tun = ...;
        struct sock *sk = tun->sk;
        if (!tun)
            return POLLER;
    \end{minted}
    Традиционно это код из ядра Linux, содержащий UB. Но \mintinline{c++}|sk| не использовалось, поэтому к ошибкам не приводило. А когда GCC начал всё оптимизировать сильнее, он нафиг убрал переменную \mintinline{c++}|sk|. Но поскольку вы обращаетесь к \mintinline{c++}|tun|, можно нафиг убрать и проверку его на \mintinline{c++}|NULL|. Тем не менее, ваша программа останется корректной при любом не'\mintinline{c++}|NULL|'овом значении \mintinline{c++}|tun|.\\
    Другое неправильное понимание UB~--- вот:
    \begin{minted}{c++}
        bool test(int a)
        {
            return a + 1 < a;
        }
    \end{minted}
    И вопрос в том, почему это переводится в \mintinline{c++}|return false|. Но человек смотрит на то, что в процессоре это совершенно чётко работают, и не понимает, почему в C++ не работает. А дело в том, что опасно при изучении того, как работает код, смотреть на инструкции процессора. Нельзя так, сложение в процессоре и сложение в языке могут различаться. Похожая очень грустная ситуация с многопоточностью, где инструкции есть у процессора, есть команды в C++, и они совсем разные.\\
    А ещё неправильно обращаться к разработчикам компиляторов, которые в новой версии сломали ваш код. Раньше компиляторы оптимизировали всё очень слабо, и исполняли всё так, как написано (соответственно, UB почти не портилось). А потом новые оптимизации, которые всё сильнее и сильнее ломают ваш код, содержащий UB.
    \section{Валидация программы}
    Отчасти источником проблем с UB является стандарт, который написан на бумаге, в связи с чем программист не знает, то что он вообще пишет, это UB или нет. Впрочем, на текущий момент с этой ситуацией живётся намного проще.
    \paragraph{Ключ компиляции \texttt{-fsanitize}.}
    У компиляторов есть ключи, которые вставляют дополнительные проверки. Например, \mintinline{console}|-fsanitize=undefined|. Если его поставить, то при запуске на этапе вызова \mintinline{c++}|test(std::numeric_limits<int>::max())| вам в stderr напишут, что у вас \mintinline{console}|integer overflow|. Почему это происходит на этапе исполнения? Потому что все предупреждения стоят определённую цену из времени компиляции. Скорее всего, у GCC есть ключ, который включает статический анализатор, но тогда программа будет компилироваться бесконечно долго.\\
    Другой хороший пример:
    \begin{minted}{c++}
        int* p = new int(42);
        delete p;
        *p = 43;
    \end{minted}
    Если вы скомпилируете это с \mintinline{console}|-fsanitize=address|, то при исполнении вам выдадут, что в третьей строке вы пишете туда, куда писать нельзя. А именно, что во второй строке вы это освобождали, а в первой~--- выделяли. Т.е. компилятор вставил в программу необходимые проверки, чтобы это ловить. Работает ключ \mintinline{console}|-fsanitize=address| следующим образом: создаётся табличка, в которой указано, какие байты где выделены, когда освобождены и т.п. При этом, когда вы обращаетесь к памяти, в эту табличку смотрят и проверяют, легально ли вы сделали. Это табличка называется shadow-байтами. Более того, когда вы что-то освободили, в после этого снова выделяете, обычно аллокатор даёт вам то, что вы только что освободили (пока оно в кэше). А при \mintinline{console}|-fsanitize=address| эта память находится в карантине и только потом переиспользуется, чтобы отлавливать ситуации вида
    \begin{minted}{c++}
        int* p = new int(42);
        delete p;
        int* q = new int(43); // Standard allocator will put *q at the place *p was.
        *p = 44;
    \end{minted}
    Вдобавок вокруг аллоцированных блоков памяти вставляется красная зона, чтобы если вы \textbf{чуть-чуть} промахнулись по адресу, вы не попали куда-то, где могут быть корректные данные, а попали чётко туда, куда нельзя. Ещё \mintinline{console}|-fsanitize=address| включает в себя проверку на утечки памяти~--- когда вы что-то выделяете и не освобождаете.\\
    \mintinline{console}|-fsanitize=address| и \mintinline{console}|-fsanitize=undefined| можно использовать совершенно свободно. Ещё есть memory- и thread-sanitizer'ы. Первый находит неинициализированную память, второй~--- состояние гонки. Их использовать гораздо труднее. Почему? В случае address-sanitizer'ов можно скомпилировать часть программы с ним, а часть~--- без. В случае с memory же, у вас могут быть ложные срабатывания, ведь в shadow-памяти не будет записей из той части программы, которая скомпилирована без sanitizer'а. А этой частью может быть, ну, например, стандартная библиотека. И аналогично с thread-sanitizer'ами~--- они также тречат записи и чтения.
    \paragraph{\texttt{valgrind}.}
    Ещё можно использовать утилиту \mintinline{console}|valgrind|, который проверяет программы пост-фактум. Она умеет находить почти те же самые ошибки (address, memory), и при этом не требует компилировать программу со специальными ключами. За счёт чего она работает? А она содержит JIT-декомпилятор x86. Понятно, что работает это капец медленно (20 раз против 2 для ключей), но зато нет никаких проблем с memory-sanitizer'ом. Только не забудьте компилировать вашу программу с ключом \mintinline{console}|-g|, чтобы вы видели, на каких строках кода ошибки. При этом если вы не хотите давать пользователю дебажные символы, просто отправьте их в отдельный файл. И на сервер залейте. Подробнее об этом~--- ниже.\\
    \mintinline{console}|valgrind|, к сожалению, немного меньше ошибок видит просто потому, что, например, не может добавить песочка между выделенными данными. И поэтому же \mintinline{console}|valgrind| не может проверять undefined и thread. В случае undefined он, например, не знает, из какого языка взялась инструкция \mintinline{nasm}|ADD|, и обладает ли она неопределённым поведением в нём, а в случае thread~--- не знает, многопоточная ли та инструкция \mintinline{nasm}|MOV|, которую он видит, или нет.
    \paragraph{Проверка предусловий стандартной библиотеки.}
    \mintinline{console}|valgrind| и sanitizer'ы~--- это не единственное, что вы можете. И, что более важно, они не всегда вам помогут. Рассмотрим вот что:
    \begin{minted}{c++}
        std::list<int> lst;
        lst.push_back(1);
        auto it = lst.end();
        it++;
        std::cout << *it << std::endl;
    \end{minted}
    На большинстве реализаций стандартной библиотеки тут вы получите \mintinline{console}|1|, потому что в большинстве реализаций \mintinline{c++}|std::list|~--- кольцевой список. При этом с указателями всё хорошо, вы обращаетесь к корректной памяти, а значит sanitizer'ы не найдут ошибок. Но видно же, что программа некорректна. Чтобы такое тоже проверять, есть флаг \mintinline{console}|-D_GLIBCXX_DEBUG|, который как раз проверяет инвалидацию итераторов, разыменование и инкремент past-to-end и все остальные нарушения контрактов. Понятно, что это даже асимптотически очень медленно~--- например, бинарный поиск работает за линейное время (потому что проверяет, является ли переданный ему массив отсортированным)~--- однако очень полезно.
    \paragraph{\texttt{assert}.}
    Мы уже можем проверять корректность на двух уровнях~--- уровне указателей и уровне контрактов. А есть уровень ещё выше. Например, мы пишем свой целочисленный квадратный корень. И мы хотим, чтобы пользователь не полагался на какое-то конкретное поведение, если передать отрицательное значение. Поэтому есть \mintinline{c++}|assert|. Это такая функция из заголовка \mintinline{c++}|<cassert>|, которая в зависимости от настроек может делать ничего или писать вам ошибку в программе в случае невыполнения какого-то условия. Очень советуется её писать \textbf{везде}, где вы полагаетесь на какие-то условия у себя в голове. Если вы полагаетесь на то, что \mintinline{c++}|next->prev == this|, напишите на это \mintinline{c++}|assert|. Если вы полагаетесь на \mintinline{c++}|m >= n|, напишите \mintinline{c++}|assert|. Понятно, особого фанатизма не требуется, но тем не менее делайте это, иначе вы где-то можете получить мусор из-за бага, передать этот мусор в функцию, получить мусор там, в результате чего потратить на отладку 3 дня вместо нескольких минут.\\
    Неправильные практики использования \mintinline{c++}|assert|:
    \begin{minted}{c++}
        FILE* f = fopen("1.txt", "r");
        assert(f != NULL);
    \end{minted}
    Это вполне штатная ситуация, если файл не открылся, не надо проверять при помощи \mintinline{c++}|assert| что-то штатное.\\
    Второе:
    \begin{minted}{c++}
        assert(fclose(f) == 0);
    \end{minted}
    Тут ещё хуже~--- когда вы отключите \mintinline{c++}|assert|'ы, они отключатся полностью, и \mintinline{c++}|fclose| не выполнится.\\
    То, во что раскрывается \mintinline{c++}|assert|, зависит от макроса \mintinline{c++}|NDEBUG|. Если он задан, то \mintinline{c++}|assert|'ы исчезают, иначе~--- проверяются. Поэтому, если вам нужно написать проверку чего-то сложного (скажем, вы хотите проверить, что значение, посчитанное разными способами, одинаковое), то напишите \mintinline{c++}|#ifndef NDEBUG| и ехайте проверять всё, что вашей душе угодно.\\
    Cт\'{о}ит ли давать программу с \mintinline{c++}|assert|'ами пользователю? Если вы задались этим вопросом, скорее всего у вас недостаточно \mintinline{c++}|assert|'ов в программе, ведь когда их достаточно, программа замедляется раза в 2.
    \section{Статические и динамические библиотеки.}
    Начнём с повторения того, что мы уже знаем. Каждый исходный файл транслируется в объектный файл, после чего все объектные файлы линкуются в программу. Но иногда бывает кусок кода, который хочется переиспользовать. Мы могли бы оттранслировать объектные файлы этого куска один раз, после чего сразу с ними компилировать. Но так оказалось, что уже существует механизм сгруппировать объектные файлы вместе, после чего отдать их линковщику.
    \paragraph{Статические библиотеки.}
    Пусть у нас есть
    \begin{minted}{c++}
        // sum.cpp
        int sum(int x, int y)
        {
            return x + y;
        }

        // main.cpp
        #include <iostream>

        int sum(int x, int y);

        int main()
        {
            std::cout << sum(2, 2) << std::endl;
        }
    \end{minted}
    И мы зачем-то пытаемся вычленить \mintinline{console}|sum.cpp| как библиотеку. Тогда нам нужно написать \mintinline{console}|ar rcs libsum.a sum.o|. \mintinline{console}|ar|~--- это сокращение от <<archive>>, \mintinline{console}|rcs|~--- это некоторая магия (читайте \mintinline{console}|man|), \mintinline{console}|libsum.a|~--- название библиотеки. Тогда для компиляции с этой библиотекой надо дописать \mintinline{console}|-L. -lsum| в опции компилятора. \mintinline{console}|-L.| говорит, что нужно искать библиотеки в текущем каталоге, \mintinline{console}|-lsum| говорит, что нужно к строке <<\mintinline{console}|sum|>> приписать спереди <<\mintinline{console}|lib|>>, а сзади~--- <<\mintinline{console}|.a|>>, после чего искать библиотеку с полученным именем. Эта библиотека называется статической и по сути не очень отличается от объектного файла.
    \paragraph{Динамические библиотеки.}
    Статические библиотеки достаточно хороши, но у них есть следующий недочёт: пусть у вас есть библиотека, которая используется везде вообще. Например, libc. И тогда реально в каждой программе есть функции из неё. А значит в каждой программе они занимают место и на диске, и в памяти. И чтобы переиспользовать и то, и другое, придумали динамические библиотеки. Идея динамических библиотек состоит в следующем: мы ссылаемся как-то на внешнюю библиотечку, а потом \textbf{на этапе исполнения} грузим по надобности её части. Как в нашем же примере сделать динамическую библиотеку вместо статической? Нужно скомпилировать \mintinline{console}|sum.cpp| как \mintinline{console}|gcc -c -fpic sum.cpp|, потом превратить его в разделяемую библиотеку при помощи \mintinline{console}|g++ -shared -o libsum.so sum.o|, а \mintinline{console}|main.cpp| скомпилировать также, как и в случае со статической библиотекой. Но при попытке это запустить, мы получим ошибку~--- не могу найти \mintinline{console}|libsum.so|. Потому что в текущем каталоге (под Linux) библиотеки не ищутся. Чтобы это проверить мы можем запустить \mintinline{console}|ldd ./a.out|, и он покажет, какие библиотеки ему нужны. И в частности покажет, что ему нужна \mintinline{console}|libsum.so|, которую он не нашёл. Есть два способа это исправить. Первый~--- \mintinline{console}|LD_LIBRARY_PATH=. ./a.out|. Мы тупо руками прописали, где ищутся библиотеки. А второй вот как. В самой программе есть место, в котором написано, где она ищет библиотеки (можно посмотреть при помощи \mintinline{console}|objdump| в секции \mintinline{console}|Dynamic Section:|). Давайте туда допишем что надо. Делается это так: \mintinline{console}|gcc -Wl,-rpath=<путь_до_библиотеки> main.cpp -L. -lsum|. \mintinline{console}|-Wl| говорит, что опцию (а данном случае опцию \mintinline{console}|-rpath|) надо передать линковщику, а линковщик, увидев эту опцию, запишет в список путей то, что вы захотели. Если вам нужно сразу несколько путей, кстати, то разделяйте их двоеточиями. Но есть одна проблема~--- в \mintinline{console}|-rpath| вы так просто не можете написать относительные пути (ведь откуда вы знаете путь до исполняемого файла). Но на самом деле знаете~--- есть специальный псевдо-путь \mintinline{console}|$ORIGIN|, который и является путём до исполняемого файла. Используя его Вы можете свободно написать что-нибудь по типу \mintinline{console}|-rpath='$ORIGIN/../lib/'|.\\
    В Windows, кстати, это работает немного по-другому. Во-первых, DLL-ки сразу же ищутся в текущем каталоге. Во-вторых, чтобы понять, что вы ссылаетесь на динамическую библиотеку, в Linux вы пишете \mintinline{console}|-L. -lsum|. В Windows же компиляция DLL создаёт вам специальный \mintinline{console}|.lib|-файл, который называется import-библиотекой. С ним вы компилируете вашу программу, чтобы она сама поняла, откуда какие функции брать.
    \subparagraph{Причины иной компиляции динамических библиотек.}
    Хорошо, а что значат все эти магические слова (\mintinline{console}|-fpic| и \mintinline{console}|-shared|)? Зачем на как-то особенно компилировать динамические библиотеки? А дело вот в чём~--- при запуске программы, она первая загружается в адресное пространство, и она сама может выбрать, куда её хочется. Динамические библиотеки такого же по понятным причинам позволить себе не могут. Возникает вопрос~--- и что теперь? А то, что при наличии глобальных переменных, мы не можем прописать им адреса. Надо куда-то обращаться. Есть путь, которым пошли разработчики архитектуры PowerPC: адреса динамической библиотеки считаются относительно некоторого регистра. И тут жить можно, разве что вам нужно правильно задавать этот регистр, когда обращаетесь к разным библиотекам, и не менять его, если обращаетесь к библиотечной функции из другой функции той же библиотеки. Сложно, но жить можно. Самый простой способ жить с динамическими библиотеками была у Microsoft на 32-битной Windows. У каждой библиотеки был base-address~--- то куда библиотеке хочется загрузиться. Если там свободно~--- туда она и загружается, а если нет, то библиотеку загружают туда, где есть место, а в специальной отдельной секции (.reloc) хранится список адресов, которые надо исправить. Разумеется, в случае релокаций умирает переиспользование библиотеки, но Windows вам же полностью предоставляют, там можно расположить системные библиотеки так, как хочется, поэтому в проприетарных системах всё будет хорошо. В Linux же это реализовано по-другому. Смотрите как можем:
    \begin{minted}{nasm}
        CALL next
next:
        POP ABX
        LEA EAX, [EBX + (myvar - next)]
    \end{minted}
    Тут идея в том, что мы записываем адрес текущей команды на стек, потом берём его со стека, а дальше вместо того, чтобы писать абсолютный адрес переменной \mintinline{c++}|myvar|, пишем относительный. Относительный адрес позволяет нам обращаться к ней, если мы не знаем, в какое место памяти будет загружена библиотека, что нам и надо. Вообще мы не очень хорошо написали (процессор не любит непарные \mintinline{nasm}|CALL| и \mintinline{nasm}|POP|), поэтому обычно это выглядит так:
    \begin{minted}{nasm}
get_pc:
        MOV EBX, [ESP]
        RET

get_variable:
        CALL get_pc
next:
        LEA EAX, [EBX + (myvar - next)]
    \end{minted}
    Этот код называется position-independent code, и ключ \mintinline{console}|-fpic| именно генерацией такого кода и занимается. Вопрос~--- почему для этого не сделали специальную инструкцию? А вот сделали, но в 64-битном режиме. Всё что с квадратными скобками стало уметь обращаться в память начиная со смещения текущей инструкции. И называется это RIP-relative positioning.
    \subparagraph{GOT/IAT. PLT.}
    В итоге мы имеем кусок данных, который можно загрузить и исполнять. Но на самом деле библиотека~--- это же не сферический код в вакууме, она хочет вызывать какие-то функции. Например, библиотека для работы с JSON хочет делать \mintinline{c++}|fopen|. То есть нужно подружить библиотеки друг с другом. Самый простой вариант~--- когда мы делаем \mintinline{nasm}|CALL|, в файл мы кладём нулевой адрес, а в секцию релокаций записываем, что вместо него нужно положить \mintinline{c++}|fopen|, после чего при запуске динамический загрузчик всё разложит по местам. То есть то же самое, что с линковщиком. Почему так не делают? Потому что мы от'\mintinline{c++}|mmap|'или нашу библиотеку, а в ней дырки. И во все места дырок нужно что-то подставить. И опять вы не можете записать библиотеку в память один раз, что вам очень хочется. Поэтому вместо этого просто заводят табличку со смещениями, и теперь все \mintinline{nasm}|CALL|'ы обращаются туда, и туда же динамический загрузчик подставляет истинные адреса функций. Эта таблица в Linux называется global offset table, а в Windows~--- import address table.\\
    Но на самом деле есть ещё проблема. Давайте посмотрим, что происходит, когда мы делаем
    \begin{minted}{c++}
        void foo();

        void test()
        {
            foo();
        }
    \end{minted}
    Как мы обсуждали, тут будет \mintinline{nasm}|CALL| пустой адрес (до линковки пустой). А что будет, если \mintinline{c++}|foo|~--- это внешняя функция из какой-то библиотеки? Тогда надо бы вместо простого \mintinline{nasm}|CALL|'а сначала \mintinline{c++}|tmp = MEM[got_foo]|, а потом уже вызов по \mintinline{c++}|tmp| (то есть там будет написано \mintinline{nasm}|CALL qword [got_foo]|). Но есть проблема~--- мы узнаём, откуда эта функция только на этапе линковки, а компилировать надо раньше. Поэтому компилятор генерирует первый вариант (\mintinline{nasm}|CALL foo|), а потом, если это было неправильно, просто создаёт свою функцию \mintinline{c++}|foo|, которая является прослойкой для \mintinline{nasm}|JMP qword [got_foo]|. Такие заглушки, которые просто совершают безусловный переход по глобальной таблице смещений имеют название. В Linux их называют PLT (procedure linkage table), а в Windows как-то по-другому. Но в Linux PLT используется ещё для одной цели. Рассмотрим, скажем, LibreOffice, в котором сотни динамических библиотек с тысячами функций в каждой. Поэтому заполнение GOT~--- это долго. И нам не хочется смотреть, где лежит каждая функция, после чего записывать её в таблицу. Поэтому эту операцию сделали ленивой: GOT заполняется специальными заглушками, которые динамически ищут в хэш-таблице настоящий адрес функции, после чего записывают его в GOT вместо себя, и вызывают эту функцию, чтобы она отработала. В Microsoft по-умолчанию отложенная загрузка не используется, но его можно включить (delayed DLL loading или как-то так называется). Это фича загрузчика, а не самой Windows, и делает эта фича примерно то же самое. Однако есть разница. В Linux отсутствие библиотеки не позволяет запустить программу. в Windows же библиотека подгружается при первом вызове функции оттуда, что, по их словам, сделано чтобы вы могли за'\mintinline{c++}|if|'ать ситуацию, когда библиотеки нет. Почему эта фича не включена по-умолчанию? Потому что в Windows в библиотеках существенно меньше функций (ещё обсудим, почему именно), поэтому там проблема с GOT'ом (точнее, IAT'ом) так остро не стоит.
    \subparagraph{Офф-топ на тему <<Как страшно жить>>.}
    Теперь поговорим про изменение \mintinline{console}|so|-файлов. Давайте возьмём и во время работы программы поменяем библиотечку на диске, втупую вписав туда другой текст. Результат поразителен~---- работа программы также изменится. Почему? Мы же, вроде как, исполняем библиотеку из оперативки, а не с диска. А дело в том, как работает copy-on-write в операционных системах. Когда вы пишете в некоторую страницу, вам копируют её. Но когда кто-то извне её пишет, вам не дают копию старых данных. С исполняемым файлом такое не прокатывает, кстати. Это потому, что вашу программу загружает ядро, и оно может запретить изменять бинарники, а библиотеку загружает ваша программа, которая такого механизма не имеет. Кстати, изменение \mintinline{console}|so| и перекомпиляция \mintinline{console}|so|~--- разные вещи. И если вы во время работы программы перекомпилируете библиотеку, она не обновится. Связано это с тем, что перекомпилированная библиотека~--- это новый файл, а не старый. По сути вы удалили старую библиотеку и создали новую, вместо того, чтобы библиотеку изменить. А в Linux пока кто-то имеет доступ к файлу, файл не удаляется до конца. И поэтому в вашей программе всё ещё есть та самая библиотека, которую вы загружали (а не новая).
    \subparagraph{Детали работы со статическими библиотеками в Windows.}
    Никто не удивиться, что набор из \mintinline{nasm}|CALL foo@PLT| и \mintinline{nasm}|foo@PLT: JMP qword [got_foo]| не очень эффективен (три обращения в память вместо одного). Поэтому в Windows есть спецификатор \mintinline{c++}|__declspec(dllimport)|, который сразу вместо \mintinline{nasm}|CALL foo@PLT| вставляет \mintinline{nasm}|CALL qword [got_foo]|.\\
    Ещё в Windows есть такая штука как \mintinline{console}|.def|-файл~--- линковщик экспортирует из вашей DLL-ки только то, что нужно, и в \mintinline{console}|.def|-файле указывается, что именно. Это хорошо работает в C, где имена символов и имена функций совпадают, но не очень хорошо в C++, где вам придётся писать сложные декорируемые имена. Поэтому есть второй вариант~--- написать на самой функции \mintinline{c++}|__declspec(dllexport)|. И вроде бы всё хорошо, мы метите функции, которые экспортируете как \mintinline{c++}|__declspec(dllexport)|, которые импортируете~--- как \mintinline{c++}|__declspec(dllimport)| и всё классно работает. Но есть проблема. Вы и в библиотеке, и в коде, который её использует подключаете один заголовочный файл, где объявлена функция. И непонятно, что там писать: \mintinline{c++}|__declspec(dllexport)| или \mintinline{c++}|__declspec(dllimport)|. Для этого заводится специальный макрос под каждую библиотеку, которым отличают, DLL вы компилируете или нет.\\
    Есть ещё одна проблема. Пусть вы берёте адрес функции. Если это ваша функция, то вы просто берёте IP-адресацию. Если это функция библиотеки, то вам нужно лезть в GOT. Правда, оттуда вы заглушку возьмёте, а не саму функцию, если не напишете \mintinline{c++}|__declspec(dllimport)|. Впрочем, это может быть и не такая ужасная проблема, не так часто вы что-то делаете с адресами функций. Однако если вдруг, то \mintinline{c++}|__declspec(dllimport)|~--- ваш бро.\\
    А ещё непонятно, что делать с глобальными переменными. Там проблема ещё более страшная: вы сначала читаете адрес переменной из GOT, а потом по полученному адресу обращаетесь. Тут уже никакую функцию-прослойку не написать, увы. Поэтому если вы не пометите глобальную переменную как \mintinline{c++}|__declspec(dllimport)|, тот тут вы уже точно совсем проиграете, у вас линковка не получится.\\
    А ещё реализация DLL в Windows нарушает правила языка, если вы напишете \mintinline{c++}|inline|-функцию в заголовочном файле. Она просто откопируется в каждую библиотеку, где вы этот заголовок подключился. Поэтому тут вы просто проиграли.\\
    Что ещё есть в Windows. Компилятор вашей программы лет на пять новее Windows. Поэтому вам нужно куда-то деть новую версию стандартной библиотеки. И тут вы либо статически линкуетесь с ней, либо динамически. И в своё время было модно первое, но это лютейший кринж, потому что в каждой библиотеке свой \mintinline{c++}|printf|, например. Что хуже, там свой \mintinline{c++}|errno| и даже свой аллокатор памяти. Поэтому, например, вы не можете передать из одной библиотеки в другую \mintinline{c++}|std::string| (точнее, не можете безопасно его изменить), ведь при перевыделении памяти вы освободите то, что не выделяли.
    \subparagraph{Детали работы со статическими библиотеками в Linux.}
    Помните мы делали свой \mintinline{c++}|malloc| и \mintinline{c++}|free|, делали библиотеку и подменяли стандартные аллокаторы памяти при помощи \mintinline{console}|LD_PRELOAD|. То что мы сделали, называется interposition и имеет кучу преколов. Посмотрим на
    \begin{minted}{c++}
        int sum(int a, int b)
        {
            return a + b;
        }
        int test(int x, int y)
        {
            return sum(x, y) - x;
        }
    \end{minted}
    Тут при обычной компиляции вторая функция просто вернёт свой второй аргумент. А при компиляции с \mintinline{console}|-fpic|, то вы же можете подменить \mintinline{c++}|sum|, а значит оптимизации не будет. Чтобы это пофиксить, можно пометить \mintinline{c++}|sum| как \mintinline{c++}|static| (тогда эта функция будет у вас только внутри файла, а значит его не поменять извне) или как \mintinline{c++}|inline| (потому что \mintinline{c++}|inline| полагается на ODR, а значит функция должна быть везде одинаковой). Но есть ещё способ. Linux по-умолчанию считает, что все функции торчат наружу (т.е. как \mintinline{c++}|__declspec(dllexport)| в Windows). А можно их пометить, как не торчащие наружу, а нужные только для текущей компилируемой программы/библиотеки: \mintinline{c++}|__attribute__((visibility("hidden")))|.\\
    На самом деле атрибут \mintinline{c++}|visibility| может принимать несколько различных значений (\mintinline{c++}|"default"|, \mintinline{c++}|"hidden"|, \mintinline{c++}|"internal"|, \mintinline{c++}|"protected"|), где пользоваться ст\'{о}ит только вторым, потому что первый и так по-умолчанию, третий заставляет ехать все адреса, а четвёртый добавляет дополнительные аллокации. Впрочем, \mintinline{c++}|hidden| тоже пользоваться опасно. При этом также есть различные ключи компиляции (типа \mintinline{console}|-B symbolic|), которые тем или иным образом немного меняют поведение, и пояснить разницу между ними всеми вам могут только избранные. И каждый из них может поменять вам поведение так, что вы можете легко выстрелить себе в ногу. То есть глобально в Linux поведение по умолчанию делаем вам хорошо, но, возможно, немного неоптимизированно, а когда вы начинаете использовать опции, вы погружаетесь в такую бездну, что ускорение заставляет вас очень много думать. Причём замедление от динамических библиотек может быть достаточно сильным: если взять компилятор clang-LLVM и компилировать при помощи его ядро Linux'а, то в зависимости от того, сложен ли clang-LLVM в один большой файл или разбит по библиотечкам, время компиляции отличается на треть. Поэтому ключи использовать придётся. Один из самых безопасных из них~--- \mintinline{console}|-fno-semantic-interposition|. Это не то же самое, что и \mintinline{console}|-fno-interposition| потому, что бинарнику всё равно можно дать interposition, однако в нашем случае функция \mintinline{c++}|test| будет оптимизирована. Ещё один полезный ключ~--- \mintinline{console}|-fno-plt|. Он по сути вешает оптимизацию такую же, как \mintinline{c++}|__declspec(dllimport)|, но на весь файл, поэтому функции, написанные в нём же, замедляются. Чтобы не замедлялись~--- \mintinline{c++}|visibility("hidden")|. Вообще всё это детально и подробно рассказано не будет, если вам интересно, то, во-первых, вы~--- извращенец, во-вторых, гуглите и читайте/смотрите по теме. Впрочем, все \mintinline{console}|-fno-plt| и прочие штуки нужны нам тогда и только тогда, когда мы не включили linking-time оптимизации. В GCC все наборы ключей нафиг не нужны, если включить \mintinline{console}|-flto|. Так что в перспективе \mintinline{console}|-flto| и \mintinline{console}|-fno-semantic-interposition|~--- это единственное, что вам может быть нужно. Но только в перспективе.
    \paragraph{Выбор между статическими и динамическими библиотеками.}
    Хорошо, но что же всё-таки использовать: статические или динамические библиотеки?    \begin{center}
        \begin{tabular}{|m{0.5\textwidth}|m{0.5\textwidth}|}
            \hline
            Преимущества статических библиотек. & Преимущества динамических библиотек.\\
            \hline
            Обычно занимают больше памяти. Впрочем, не всегда~--- если из стандартной библиотеки вы используете только \mintinline{c++}|printf|, то вам только его и дают. И люди, сидящие на операционной система Plan 9, вообще отрицают, что статические библиотеки занимают больше памяти. & Обычно дольше работают.\\
            \hline
            Статическая компиляция с библиотеками даёт вам возможность очень просто перенести вашу программу куда угодно. Если вы хотите поднять ваш бинарник на другом сервере, то со статическими библиотеками вам не нужно заниматься сексом с версиями. В частности, если у вас есть программа времён Windows 98, если она скомпилирована статически, то вы сразу можете её запустить, иначе вы проиграли. & Дистрибутивы Linux почти всегда пользуются динамическими библиотеками, потому что когда вы делаете маленький багфикс, вы не хотите перекомпилировать вообще все зависимости, а хотите только поставить пользователю именно этот багфикс.\\
            \hline
            Ещё одно преимущество статических библиотек~--- не нужно бесконечное количество времени их загружать в память. Поэтому консольные утилиты лучше поставлять статическими библиотеками, чтобы скрипты на Shell работали быстро (в скриптах на Shell каждая строка~--- вызов новой программы). & Динамические библиотеки (только на Linux, правда) поддерживают interposition, что бывает полезно, если вы хотите подсунуть свой аллокатор памяти, потестить что-то или ещё чего.\\
            \hline
            & При помощи статических библиотек не реализовать кастомные плагины, а при помощи динамических~--- как нефиг.\\
            \hline
        \end{tabular}
    \end{center}
    \section{Введение в шаблоны.}
    Зачем это нужно, что это такое? Ну, мотивация проста. Мы делаем контейнер стандартной библиотеки, который хранит всё что захочется пользователю. И тогда мы пишем: <<хочется вектор целых чисел>>: \mintinline{c++}|std::vector<int>|. Это основная мотивация появления шаблонов в языке.
    \paragraph{Способы жить без шаблонов.}
    Прежде чем говорить, почему шаблоны такие, какие есть, надо понять, как жить без них. Например, как жить в C.
    \subparagraph{\texttt{void*}.}
    В C живут с \mintinline{c++}|void*|~--- тип указателя, который (в C, не C++) неявно преобразуется куда угодно и откуда угодно. И тогда всё выглядело бы так:
    \begin{minted}{c++}
        struct vector
        {
            void push_back(void*);
            void*& operator[](size_t index);
            const void*& operator[](size_t index) const;
        }

        int main()
        {
            point* p;
            vector v;
            v.push_back(p);
            static_cast<point*>(v[0]);
        }
    \end{minted}
    Это не выглядит типобезопасно. Мы можем достать из вектора не то, что туда положили. И компилятор ничего не скажет. А если мы можем выявить ошибку на этапе компиляции, ст\'{о}ит это делать.\\
    Вторая проблема~--- количество аллокаций. Если мы хотим хранить целые числа, а не указатели, например, то в \mintinline{c++}|std::vector<int>| мы тупо выделяем большой блок памяти, а в нашем \mintinline{c++}|vector|'е мы сначала выделяем большой блок под указатели, а потом выделяем память под каждый. К тому же подобную штуку не получится prefetch'ить, потому что память под каждый объект выделена в разных местах, а значит лишний indirection.\\
    А ещё есть совсем плохая проблема:
    \begin{minted}{c++}
        vector u;
        u.push_back(new point());
    \end{minted}
    Этот код не exception-safe, потому что вы никак не освободите память, если произойдёт ошибка при \mintinline{c++}|push_back|.
    \subparagraph{Макросы.}
    Много можно было бы рассуждать о том, насколько отвратительно решение через \mintinline{c++}|void*|, но нам уже этого достаточно. А пока посмотрим на второй способ жизни без шаблонов: макросы!
    \begin{minted}{c++}
    #define DEFINE_VECTOR(type)                         \
        struct vector_##type                            \
        {                                               \
            void push_back(type const&);                \
            type& operator[](size_t index);             \
            type const& operator[](size_t index) const; \
        };
    \end{minted}
    Тут уже явно лучше, можно написать это типобезопасно, без проблем с памятью, но тоже имеются проблемы. Например, вот:
    \begin{minted}{c++}
    DEFINE_VECTOR(int);
    DEFINE_VECTOR(int32_t);

    int main()
    {
        vector_int v;
        vector_int32_t u;
    }
    \end{minted}
    И теперь мы имеем две одинаковые структуры, а хотелось бы одну.\\
    Второе~--- когда мы имеем \mintinline{c++}|DEFINE_VECTOR(int)| в двух разных местах. Потому что вам и какому-то человеку из Австралии понадобилось одно и то же. А потом кто-то подключает и то, и другое, и он проиграл. Ещё одна проблема~--- \mintinline{c++}|#DEFINE_VECTOR(unsigned short)|. Компилятор видит это как \mintinline{c++}|struct vector_unsigned short|, и не компилирует.
    \paragraph{Шаблоны наконец-то.}
    Хорошо, теперь как это делать нормально? Мы пишем \mintinline{c++}|template <typename T>| либо \mintinline{c++}|template <class T>|, и после этого везде пишем, чего же мы хотим, в уже описанном синтаксисе (\mintinline{c++}|vector<int>|). И тут нет ни одной из описанных проблем. Причём \mintinline{c++}|template| можно навесить на что угодно. На функцию можно:
    \begin{minted}{c++}
        template <typename T>
        void swap(T& x, T& y)
        {
            T tmp = x;
            x = y;
            y = tmp;
        }
    \end{minted}
    При этом для функций вы не обязаны писать \mintinline{c++}|swap<int>(a, b)|, а можете написать просто \mintinline{c++}|swap(a, b)|, если переменные \mintinline{c++}|a| и \mintinline{c++}|b| уже имеют тип \mintinline{c++}|int|. При этом если вы подставите в эту функцию \mintinline{c++}|long long| и \mintinline{c++}|int|, вам явно напишут, что нельзя так. Более того:
    \begin{minted}{c++}
        template <typename Dst, typename Src>
        Dst my_cast(Src s)
        {
            return static_cast<Dst>(s);
        }

        int main()
        {
            int x = 42;
            my_cast(x);        // Непонятно, чему равно Dst, ошибка.
            my_cast<float>(x); // Dst указан явно, Src можно вывести, зная тип x.
        }
    \end{minted}
    \paragraph{Специализация.}
    У нас есть \mintinline{c++}|std::vector<T>|. Но мы хотим сделать \mintinline{c++}|std::vector<bool>| немного другим. И тогда мы можем явно сказать, что у нас есть \mintinline{c++}|vector<T>| для всех классов, а потом написать 
    \begin{minted}{c++}
        template <>
        struct vector<bool>
        {
            void push_back(bool);
            // ...
        };
    \end{minted}
    И у вас для всех типов, кроме \mintinline{c++}|bool| будет то, что вы написали изначально, а для \mintinline{c++}|bool|~--- специализация. При этом когда вы пишете специализацию, вы \textbf{целиком} пишете новый класс.\\
    \mintinline{c++}|std::vector<T>| называется primary template, \mintinline{c++}|std::vector<bool>|~--- explicit specialization. А ещё есть partial specialization~--- специализировать не обязательно все параметры. И ещё можно особым образом специализировать. Например, мы решили, что мы можем каким-то особым образом хранить указатели. И тогда мы бы написали
    \begin{minted}{c++}
        template <typename U>
        struct vector<U*>
        {
            // ...
        };
    \end{minted}
    То есть partial specialization~--- это специализация, сама являющаяся шаблоном. Теперь, когда вы напишете \mintinline{c++}|vector<int*>|, вам дадут специализацию \mintinline{c++}|vector<U*>|. Вот ещё пример:
    \begin{minted}{c++}
        template <typename A, template B>
        struct my_type {}; // 1

        template <typename A>
        struct my_type<A, int> {}; // 2

        template <typename B>
        struct my_type<int, B> {}; // 3

        int main()
        {
            my_type<float, double> fd; // Выбирается 1.
            my_type<float, int> fi;    // Выбирается 2.
            my_type<int, double> id;   // Выбирается 3.
            my_type<int, int> ii;      // Компилятор не может выбрать между 2 и 3. Не компилируется.
        }
    \end{minted}
    Хорошо, а как определяется, какая специализация лучше? Давайте вот какой пример:
    \begin{minted}{c++}
        template <typename T>
        struct bar {}; // Произвольный тип.
        
        template <typename U>
        struct bar<U*> {}; // Указатель на что-то.
        
        template <typename R, typename A, typename B>
        struct my_type<R (*)(A, B)> {}; // Указатель на функцию.
    \end{minted}
    Здесь есть <<указатель на что-то>> и <<указатель на функцию>>. Кажется, что второе более специализированно. Но как бы это формализовать? Да легко! Является ли произвольный указатель на функцию указателем? Да. А является ли произвольный указатель указателем на функцию? Нет. То есть если мы \textbf{всегда} можем \textbf{корректно} подставить одну специализацию в другую, но не наоборот, то первая более специализированна. Вопрос: что делать, если шаблон от нескольких параметров зависит? Тут первая специализация более специализированна, чем вторая, если хотя бы по одному параметру она строго более специализированна, а по остальным~--- не менее.\\
    Примечание: в шаблоны вы можете передавать всё что угодно (хоть \mintinline{c++}|void|, хоть \mintinline{c++}|int(int, int)| (функцию, даже не указатель на неё), хоть \mintinline{c++}|char[]|). Но не любой класс обязан корректно работать с любым классом. Если в хотите в своих классах что-то явно ограничить~--- подождите, и будет вам счастье.\\
    \subparagraph{Специализация функций.}
    Со специализацией функций есть детали. Во-первых, у функций просто нет partial специализаций. Вообще. Во-вторых, с explicit специализациями есть детали, поскольку существуют перегрузки: вместо \mintinline{c++}|template<>|\\\mintinline{c++}|void foo<int>(int)| пишут \mintinline{c++}|foo(int)|. Но вообще есть разница. Итак:
    \begin{minted}{c++}
        template <typename T>
        void baz(T*) {}

    #if ENABLE_TEMPLATE
        template <>
        void baz<int>(int*) {}
    #else
        void baz(int*) {}
    #endif
    \end{minted}
    В приведённом примере если включить шаблонную версию \mintinline{c++}|baz|, то код \mintinline{c++}|baz(nullptr)| не скомпилируется, а если не-шаблонную, то скомпилируется вполне. Почему, хочется спросить? А вот почему.\\
    Есть перегрузки функции. Мы их проходили, и одну видим тут: \mintinline{c++}|void baz(int*)|. Так вот, шаблон (весь целиком) считается ещё одной перегрузкой. При этом, когда вы вызываете функцию вам сначала пытаются подставить не-шаблонные специализации, а если не получится~--- шаблонную, для которой после этого выбирается специализация по уже обсуждённым правилам.\\
    В данном случае посмотрим на \mintinline{c++}|baz(nullptr)|. В случае включённого шаблона имеем всего одну перегрузку~--- \mintinline{c++}|baz<T>| (одну перегрузку, но со специализацией). Можем ли мы подставить в неё \mintinline{c++}|nullptr|? Объективно, нет, \mintinline{c++}|nullptr| не является указателем, нельзя понять, чему равно \mintinline{c++}|T|. А значит не компилируется. В случае с выключенным \mintinline{c++}|ENABLE_TEMPLATE| имеем две перегрузки: шаблонную и обычную. Можем ли мы подставить \mintinline{c++}|nullptr| в \mintinline{c++}|void baz(int*)|? Ну, да, кто нам мешает, \mintinline{c++}|nullptr_t| неявно преобразуется в любой указатель, значит в \mintinline{c++}|int*| тоже преобразуется. Шаблон даже проверять не надо, но он, как мы видим, не подойдёт.\\
    Кстати, можно немного изменить работу с перегрузками. Можно вызывать функции не как \mintinline{c++}|foo(...)|, а как \mintinline{c++}|foo<>(...)|. В таком случае вы явно отбросите всё, что не является шаблоном, а значит выбирать сможете только из специализаций.
    \paragraph{Non-type template parameter.}
    Помимо типов в шаблоны можно пихать чиселки. В стандартной библиотеке есть \mintinline{c++}|std::array|, который имеет два параметра~--- сколько хранить и что хранить. И вот сколько хранить~--- это \mintinline{c++}|size_t|. Выглядит это как-то так:
    \begin{minted}{c++}
        template <typename T, size_t N>
        array
        {
            // ...
        };
    \end{minted}
    Их всё так же можно специализировать (например, \mintinline{c++}|std::array| имеет специализацию от нулевой длины, потому что в С++ нельзя написать \mintinline{c++}|int[0]|). Точно то же самое можно написать и для функций:
    \begin{minted}{c++}
        template <typename T, size_t N>
        size_t size(T (&)[N])
        {
            return N;
        }
    \end{minted}
    Что ещё можно сказать про non-type template параметры? То что это самое число \mintinline{c++}|N| обязано быть известно на этапе компиляции. Потому что только на этапе компиляции существуют типы, а значит только на этапе компиляции существуют шаблонные типы.
    \paragraph{Template template parameter.}
    Хочется обёртку над контейнером. Зачем-то.
    \begin{minted}{c++}
        template </* container */ V>
        struct container_wrapper
        {
            V<int> container;
        }

        container_wrapper<vector> wrapper;
    \end{minted}
    Это пишется вот так:
    \begin{minted}{c++}
        template <template <typename> class V>
        struct container_wrapper
        {
            V<int> container;
        }
        
        container_wrapper<vector> wrapper;
    \end{minted}
    Используется, понятно, очень редко. Правила те же самые, что и обычно.
    \paragraph{Зависимые имена.}
    Начнём немного издалека: если вы видели шаблонный код, то вам может показаться, что в случайных местах по нему раскиданы \mintinline{c++}|typename| и \mintinline{c++}|template|. Например, вот в таких примерах:
    \begin{minted}{c++}
        typename std::vector<T>::iterator it;
        // Вместо std::vector<T>::iterator it;
        typename foo<T>::template bar<int> y;
        // Что это за хрень вообще?
        // foo<T>::bar<int> y, если интересно.
    \end{minted}
    Так вот зачем это. Пусть мы где-то в пустоте увидели строку кода \mintinline{c++}|(a)-b|. Что это? Разность \mintinline{c++}|a| и \mintinline{c++}|b| либо каст значения \mintinline{c++}|-b| к типу \mintinline{c++}|a|. Или увидели \mintinline{c++}|int b(a)|. Это либо вызов конструктора \mintinline{c++}|int|'а, либо функция \mintinline{c++}|b|, которая принимает на вход значение типа \mintinline{c++}|a| и возвращает \mintinline{c++}|int|. Ещё страшнее: \mintinline{c++}|a < b && c > d|. Это либо логическое выражение, либо \mintinline{c++}|a|~--- это шаблон с non-type параметром типа \mintinline{c++}|bool|, \mintinline{c++}|b| и \mintinline{c++}|c|~--- какие-то логические выражения, а \mintinline{c++}|d|~--- имя. И тогда это \mintinline{c++}|a<b && c> d|~--- создание переменной \mintinline{c++}|d| типа \mintinline{c++}|a<b && c>|. Как компилятор читает подобные двоякие примеры? Ну, если \mintinline{c++}|a|~--- это тип, то одно, если не тип~--- то другое. И обычно компилятор это знает. Проблема в том, что в шаблонах мы можем сделать что-то такое:
    \begin{minted}{c++}
        template <typename T>
        void foo(int x)
        {
            (T::nested) - x;
        }
    \end{minted}
    И один хрен вы знаете, что такое \mintinline{c++}|nested| до подстановки. А очень хотите это знать, чтобы отлавливать ошибки раньше, чем подстановка (например, написав \mintinline{c++}|(T::nested) - y|, вы не получили бы ошибку о том, что не существует \mintinline{c++}|y|, сразу). Поэтому вы можете явно указать, что происходит.
    \begin{minted}{c++}
        template <typename T>
        void foo(int x)
        {
            (T::nested) - x;        // Вычитание.
            (typename T::nested)-x; // Каст.
        }
    \end{minted}
    Аналогично
    \begin{minted}{c++}
        template <typename T>
        void foo(int x)
        {
            int b(T::nested);          // Конструктор переменной.
            int b(typename T::nested); // Объявление функции.
        }
    \end{minted}
    И
    \begin{minted}{c++}
        template <typename T>
        void foo(int x)
        {
            T::nested < b && c > d;       // Логическое выражение.
            T::template nested<b && c> d; // Переменная шаблонного типа.
        }
    \end{minted}
    При этом когда у вас есть что-то внешнее, что \textbf{не зависит от шаблона}, и имеет в себе \mintinline{c++}|nested|, там писать всё это не обязательно, компилятор сам определит. То что зависит от шаблона, называется dependent. И вот в dependent-штуках обязательно писать \mintinline{c++}|typename|'ы и \mintinline{c++}|template|'ы, а independent~--- нет. MSVC, кстати, долгое время делал не так (а полностью разбирал шаблонную функцию при подстановке), за что его загнобили, и больше он так не делает, а делает как все: разбирает dependent-выражения при подстановке, а independent~--- сразу. Это называется <<two-phase name lookup>>.
    \paragraph{Incomplete type.}
    \begin{minted}{c++}
        template <typename D>
        struct base
        {
            typename D::type x;
        };

        struct derived
        {
            base<derived> y;
            typedef int type;
        };
    \end{minted}
    Компилироваться это не будет. Почему? Потому что мы в тот момент, когда мы имеем по сути \mintinline{c++}|type y|, у нас \mintinline{c++}|type| ещё не определён. Когда содержимое какого-то класса не полностью определено, говорят, что этот класс~--- incomplete type. Приведённый выше пример не очень впечатляющий, более впечатляющий нам пока не доступен, но выглядит он так:
    \begin{minted}{c++}
        template <typename D>
        struct base
        {
            typename D::type x;
        };

        struct derived : base<derived>
        {
            typedef int type;
        };
    \end{minted}
    Мораль~--- шаблоны подставляются по порядку, а не сразу везде.\\
    Ещё про incomplete-типы:
    \begin{minted}{c++}
        struct nested; // Объявлен где-то не здесь.

        struct my_type
        {
            std::unique_ptr<nested> p;
        };
    \end{minted}
    Это не компилируется, говорят, что у \mintinline{c++}|nested| не видно деструктора, а \mintinline{c++}|unique_ptr| его вызывает. Фиксится это так:
    \begin{minted}{c++}
        struct my_type
        {
            ~my_type();

            std::unique_ptr<nested> p;
        };
    \end{minted}
    При этом деструктор \mintinline{c++}|~my_type| должен находиться там, где структура \mintinline{c++}|nested| полностью определена.
    \paragraph{Декларации шаблонных типов.}
    \begin{minted}{c++}
        // foo.h
        template <typename T>
        void foo();

        // foo.cpp
        #include "foo.h"

        template <typename T>
        void foo()
        {}

        // main.cpp
        #include "foo.h"

        int main()
        {
            foo<int>();
        }
    \end{minted}
    Это не компилируется, потому что \mintinline{console}|main.cpp| не может сгенерировать \mintinline{c++}|foo<int>|, а \mintinline{console}|foo.cpp| не знает, что нужно сгенерировать. Поэтому шаблонные функции пишутся в заголовочных файлах, к ним неявно для вас приписывается \mintinline{c++}|inline|, и всё работает как с \mintinline{c++}|inline|.\\
    Но вообще есть ещё и явное инстанцирование: прямая просьба сгенерировать шаблон от некоторого параметра. Пишется так: \mintinline{c++}|template void foo<int>();| Ещё в C++11 есть вот такая штука:\\\mintinline{c++}|extern template void foo<int>();|. Это говорит, что инстанцировать \mintinline{c++}|foo<int>| не надо, ведь его уже инстанцирует кто-то другой. Используется это, например, в \mintinline{c++}|std::string|. \mintinline{c++}|std::string| на самом деле является специализацией \mintinline{c++}|std::basic_string<char>|, и если каждый будет его инстанцировать, ничего хорошего не произойдёт. Поэтому он помечен именно как \mintinline{c++}|extern template|, чтобы его один раз инстанцировал кто-то один (а кто~--- написано где-то, где вас не касается). При этом все прочие инстанции \mintinline{c++}|std::basic_string| спокойно будут подставляться во всех единицах трансляции.
    \section{Инструменты, которые могут помочь жить.}
    Мы поговорим о каких-то мелких вещах, которые помогут вам в некоторых ситуациях, если в о них знаете.
    \subsection{Отладчики.}
    Первое: \mintinline{console}|-g|. Иначе вы проиграли. Второе~--- \mintinline{console}|-O0|. Если дебажить код с оптимизациями, то вам могут убрать переменные, переупорядочить инструкции и подобное. Ещё в GCC есть ключ \mintinline{console}|-Og|, который включает некоторые слабые оптимизации, которые не должны сильно влиять на отладку. Но на самом деле это не очень правда, если вы не разрабатываете игры и не имеете таймаутов, то лучше использовать \mintinline{console}|-O0|. Вообще в GCC есть много ключей, которые тем или иным образом включают/выключают оптимизацию, от которой зависит отладка, но тут ищите их сами.\\
    Ещё: не обязательно запускать программу под отладчиком, можно присоединиться отладчиком к уже работающей программе. С Windows вообще проблем нет, в Linux по-умолчанию так делать нельзя (по соображениям безопасности), сами погуглите, как отключить эту опцию. Ещё полезная опция~--- когда ваша программа аварийно завершается, все Linux'ы умеют сбрасывать на диск память. Куда конкретно~--- смотрите (или изменяйте) файл \mintinline{console}|/proc/sys/kernel/core_pattern|. И потом эту штуку можно в отладчике открыть и посмотреть. Если файл у вас не создаётся~--- проблемы с \mintinline{console}|ulimit -c|. Есть ограничения на максимальный размер core dump'а, вот вам надо поставить на unlimited.\\
    Теперь поговорим про сервер дебажных символов. Как мы знаем, дебажные символы заливают в один файл, который отправляют на сервер. И с не так давних времён, любой дистрибутив этот сервер имеет. И вы можете скачать оттуда дебажные символы и исходники (да ещё и нужной версии), чтобы поотлаживать что-то в дистрибутиве.
    \paragraph{Продвинутые breakpoint'ы.}
    Представим, что у вас есть программа, которая работает, а потом падает. И вы знаете условие, когда падает (например, когда переменная достигла определённого значения). И отладчики дают вам такую возможность: conditional breakpoint называется. Останавливается в каком-то конкретном случае. В GDB это пишется как \mintinline{console}|if i == 41| после указания breakpoint'а, например.\\
    Ещё если вы хотите отлаживать \mintinline{c++}|printf|'ами, вам не обязательно их явно писать и перекомпилировать программу. Вы можете написать breakpoint, который не останавливается, а что-то выводит. В GDB это \mintinline{console}|commands printf "abacaba" end|.\\
    Ещё есть такая штука как watch point'ы. Вы можете поставить слежение за определённой переменной/полем/выражением. Для этого вы (в \mintinline{console}|gdb|) так и пишете: \mintinline{console}|watch <expression>|. Ещё watch point можно на адрес поставить при помощи \mintinline{console}|-l|. За счёт чего это работает? А watch point'ы в процессоре есть. Но вообще это и программно можно эмулировать (помечаем память как то, куда нельзя писать, процессор при записи делает прерывание, которое и передаётся отладчику).
    \paragraph{Визуализаторы структур данных.}
    Что отладчик из Visual Studio, что GDB, что LLDB поддерживают возможность красиво напечатать встроенные структуры данных. Чаще всего вы не хотите видеть дерево, когда смотрите на \mintinline{c++}|std::set| или хэш-таблицу в \mintinline{c++}|std::unordered_set|, а хотите видеть лишь элементы внутри. И вам дают такую возможность. При этом три отладчика позволяют написать свои способы красиво что-то напечатать. В отладчике из VS~--- это XML-ки, в GDB и LLDB~--- Python'овские скрипты. Причём в VS визуализатор можно в проект добавить, и VS его подхватит.
    \paragraph{Reversible-отладчики.}
    Reversible-отладчики~--- отладчики, которые позволяют ходить не только вперёд, но и назад. Если вы под Linux, то вам нужен UndoDB, имеющий тот же интерфейс, что и GDB. Проблема~--- он проприетарный и платный (притом недешёвый). Но это в целом круто, работает как магия, но всё ещё дорого. Поэтому у нас есть только инструмент для бедных, созданный людьми из Firefox'а. Но он имеет немного другую специализацию. У них была такая проблема: были тесты, которые спонтанно ломались. И хочется куда-то записать всё что было. Для этого есть \mintinline{console}|rr| (record-replay). Вы можете куда-то записать, как программа работает (\mintinline{console}|rr record|), она запишет вам всё, что было, а по \mintinline{console}|rr replay| вы можете ходить по этой записи. Нужные вам команды~--- \mintinline{console}|reverse-finish| (reverse-<<выйти из функции>>), \mintinline{console}|reverse-next| (reverse-<<следующая строка кода>>) и всё остальное, что начинается с \mintinline{console}|reverse-|.
    \subparagraph{Как работает эта чёрная магия.}
    Вариант <<запоминать всё вообще>> не подходит (слишком много памяти). Кстати, такое есть и в GDB (он тоже поддерживает обратный ход, но жрёт бесконечность памяти). А какой вариант подходит? Давайте запомним начало программы и будем эмулировать получение данных из внешнего мира. А чтобы не работало бесконечно долго (чтобы при шаге назад не запускалась вся программа полностью с начала), сделаем несколько snapshot'ов в разных местах программы, и будем запускаться от них.\\
    А как остановиться в определённом месте? Ну, у нас есть счётчики в процессоре (см. ниже в разделе про отладчики), только тут мы не профилируем что-то, а задаём счётчик и говорим <<исполни N инструкций>>. Есть проблема с этим, кстати. Поскольку процессор работает спекулятивно, посчитать N инструкций процессора~--- это не совсем то, что вы хотите. Для сэмплирования разницы никакой, а тут \mintinline{console}|rr| долгое время с трудом работал на AMD, потому что там не могли найти детерминированный счётчик.\\
    Ещё проблема~--- недетерминированные инструкции. Скажем <<сколько времени прошло с некоторого момента>> или генерация случайных чисел. Но вообще на процессорах есть возможность и на этих инструкциях тоже прерваться.\\
    Ещё проблема есть с shared-памятью. Если вы отлаживаете программу, а кто-то извне пишет в её память, вы проиграли. Чтобы с этим справится, UndoDB делает нечто похожее на механизмы \mintinline{console}|valgrind|.
    \subsection{Профилировщики.}
    Программы, которые помогают вам ответить на вопрос, где больше всего времени проводит программа. Понятно, что вам нужны дебажные символы (\mintinline{console}|-g|), иначе вам максимум машинные инструкции покажут, а не строки программы. Из самых известных~--- \mintinline{console}|perf|, встроенный в ядро Linux, в Visual Studio есть профилировщик, использующий встроенные в Windows механизмы. Самый навороченный и крутой~--- Intel VTune Amplifier. Долгое время он был платный (причём достаточно дорогой), сейчас, кажется, есть какие-то варианты, но это всё сами включите VPN и посмотрите. При этом всё, что мы расскажем, в основном относится с CPU-профилированию (C++, хуле), но вообще \mintinline{console}|perf|, например, может и записи на диск профилировать, работу с сетью да и вообще кучу разных событий, которую можно сэмплировать.
    \paragraph{Базовые возможности \texttt{perf}.}
    В профилировщике Visual Studio разберётесь сами, а мы проговорим о том, что умеет \mintinline{console}|perf|. Он запускается командой \mintinline{console}|perf| и дальше имеет кучу опций. Самая простая~--- \mintinline{console}|perf stat|, с этой опцией показывается не только время, но и всякая другая фигня (branch-miss'ы, cpu-миграции, разные другие штуки). Что-то из этого поставляется ОС, что-то~--- процессором. Если вы хотите посмотреть список доступных событий~--- \mintinline{console}|perf list|. Чем дальше вниз прокручивать этот список~--- тем более редко используемые параметры там будут. Окей, это всё хорошо, но хочется понять, на какую функцию грешить, если долго работает. Это делается при помощи \mintinline{console}|perf record|+\mintinline{console}|perf report|. Первый собирает статистику о функциях, второй~--- показывает её вам. Причём статистика~--- не обязательно время. Можно написать \mintinline{console}|perf record -e cache-misses <программа>|, и тогда вам будут давать статистику по промахам в кэше. Чтобы самому узнать какие-то опции инструкций~--- \mintinline{console}|perf help <инструкция>|.\\
    Каким образом работает \mintinline{console}|perf|? Зависит от процессора, на самом деле. Процессор предоставляет возможность, скажем, каждый тысячный заход в команду давать прерывание (по которому \mintinline{console}|perf| будет что-то считать). Кстати, есть проблема: процессор имеет ограниченное количество счётчиков, и в таком случае \mintinline{console}|perf| будет сначала сэмплировать один набор, потом другой, затем третий, чтобы собрать статистику.
    \paragraph{General exploration.}
    Хорошо, вот нашли вы долго работающее место, но совершенно не знаете, в чём там проблема. Тут уже \mintinline{console}|perf| вам не поможет, но может помочь VTune. У него есть режим <<general exploration>>. Он базируется на упрощённой модели, что инструкция сначала передаётся в какую-то front-end-часть процессора, а потом~--- в back-end. И потом в зависимости от того, поступают ли инструкции из front'а в back и простаивают ли front и back, вам говорят, где проблема (собственно, во front'е ли, в back'е ли, восстанавливаетесь ли вы от branch miss'а или что). И вот в VTune эту идею довели до ума, в связи с чем вам говорят не только тормозите ли вы на front'е или back'е, но и упираетесь ли вы в память, а если да, то в L1, L2, L3 или RAM. Так что VTune сразу говорит вам, в каких функциях какие проблемы. В \mintinline{console}|perf|'е это только в зачаточном состоянии есть.
    \paragraph{Сбор стека вызовов.}
    Следующая возможность \mintinline{console}|perf|'а. Вот выяснили вы, что долго работает. А кто вызывает то, что долго работает? \mintinline{console}|perf record -g --call-graph dwarf|. Тогда вам будут показывать стеки вызовов, что довольно полезно. Опция \mintinline{console}|-g| их сборкой и занимается, а опция \mintinline{console}|--call-graph| задаёт то, каком образом они собираются. Чтобы не сильно замедляться при сборке стека, \mintinline{console}|perf| работает в ядре. Но чтобы ядро очень долго не работало, собираются верхушки стеков, а \mintinline{console}|perf report| пытается их раскрутить. Это и есть режим \mintinline{console}|--call-graph dwarf|. Ещё есть режим \mintinline{console}|--call-graph fp|, который собирает стек вызовов по frame-pointer'ам, что делается быстро и честно, но тогда совершенно всю программу надо собрать с ключом \mintinline{console}|-fno-omit-frame-pointer|, а стандартная библиотека с ним не собрана.\\
    Ещё \mintinline{console}|perf| можно натравливать на уже работающие программы при помощи \mintinline{console}|perf -p <pid>|. Более того, \mintinline{console}|perf| может профилировать больше одной программы. Хоть вообще всё (\mintinline{console}|sudo perf record -a|).
    \paragraph{Альтернативные методы профилирования.}
    Ст\'{о}ит сказать, что профилировщики (\mintinline{console}|perf|, VS profiler, VTune) полагаются на процессор. А ещё есть tracing-профилировщики, работающие на базе компиляторов. Они вставляют инструкции на моменте входа и выхода из функции. Примером таковых является gprof. Они имеют преимущества и недостатки. Преимущество~--- могут показать число вызовов функции (честно, а не по количество сэмплов), что бывает полезно, чтобы увидеть, что вы могли посадить где-то квадратичную сложность. Недостаток~--- tracing-профилировщики врут, увеличивая время работы маленьких функций. В связи с этим они используются очень редко.\\
    Что ещё ст\'{о}ит упомянуть~--- \mintinline{console}|valgrind| имеет встроенный профилировщик. Он в целом адекватный, но у него просмотрщик не очень. Так вот, \mintinline{console}|valgrind|~--- это набор инструментов. Если вы не пишете ничего, запускается инструмент \mintinline{console}|memcheck|. А когда вы используете инструмент \mintinline{console}|cachegrind|, то \mintinline{console}|valgrind| эмулирует работу процессора (сколько времени он бы исполнял заданную инструкцию). С виду вообще бред какой-то (все системные вызовы, например, занимают 0 времени, что это вообще), но и тут есть свои ништяки. Есть история про библиотеку SQLite для работы с базами данных. В один момент её решили оптимизировать и микрооптимизациями ускорили её на 61\%. В качестве профилировщика они использовали \mintinline{console}|cachegrind|, который даёт вам воспроизводимые данные без шума. И если вы сделали микрооптимизацию, вы увидите ускорение на 0.1\%, и его не съест шум.
    \subsection{Проверка покрытия.}
    Если тесты не заходят в некоторую функцию или на определённую строку надо, значит на тех местах может быть написан полный бред. Поэтому следует проверить, что тесты проходят в вашей программе вообще везде. Это называется coverage, и запускать его так. Сначала надо скомпилировать программу с ключом \mintinline{console}|--coverage|. Тогда при запуске создадутся файлы расширения \mintinline{console}|.gcda| и \mintinline{console}|.gcno|. Чтобы их посмотреть, вам нужна программа \mintinline{console}|gcov| с ключиками, это сами разберётесь.
    \subsection{Полезные ключи компиляции.}
    \paragraph{LTO.}
    Linking-time optimizations~--- \mintinline{console}|-flto| (ключ передаётся компилятору и линковщику). Это мы уже обсуждали. Не обсуждали, как работает. А работает так: компилятор откладывает генерацию кода до этапа линковки, а в файл записывает что-то промежуточное. Это промежуточное представление даже глазами читать можно, это просто какой-то императивный код. В Clang'е это представление~--- LLVM-IR, в GCC~--- gimple. Второй вообще похож на C. Какие плюсы и минусы у LTO? С одной стороны, бенчмарки говорят, что ускорение на несколько процентов. С другой, на бенчмарках и так всё сильно оптимизировано, даже то, что LTO мог бы ускорить. Ещё LTO сильно уменьшает размер программы. Там, параметры в функцию передаются всегда одинаковые, или \mintinline{c++}|if| всегда в одну сторону. Это позволяет компилятору (если он видит программу целиком), уменьшить размер. Ещё LTO хорошо с шаблонами взаимодействует. Поскольку шаблоны подставляются в каждой единице трансляции, если вы сгенерировали что-то здоровенное, то без LTO оптимизироваться это будет везде, а с LTO~--- только один раз. И самое интересное~--- LTO может показать вам ODR, что в C++ очень круто. Недостатки~--- LTO убивает возможность пересобрать один файл, самое долгое время занимает линковка, вне зависимости от того, один файл вы изменили или все.
    \paragraph{PGO.}
    Profile-guided optimizations. Идея в следующем. Иногда изменение компилятора даёт эффект только в некотором случае. Если у нас есть цикл, мы можем за'\mintinline{c++}|if|'ать случай aliasing'а, использовать SIMD, сделать кучу ещё разных интересных вещей. Но есть всё это мы будем делать с каждым циклом, мы проиграем, потому что нужно это отнюдь не всегда, а если мы всё применим, увеличится размер программы, а значит будет хуже работать программный кэш, что может даже к замедлению привести. Или с \mintinline{c++}|if|'ами процессору хочется знать, какая ветка более вероятна. Так вот, вы можете запустить компиляцию с ключом \mintinline{console}|--profile-generate|, запустить программу, после чего заново скомпилировать с \mintinline{console}|--profile-use|. Это также даёт ускорение, а из минусов~--- вам нужно иметь репрезентативный набор тестов. Впрочем, иметь набор тестов и так очень полезно, о каком ускорении можно говорить, если тестов нет.\\
    Кстати, в случае с GCC то, что не попало в профиль, считается <<холодным кодом>> и оптимизируется на размер, а не на скорость. Поэтому в GCC, если у вас не репрезентативный профиль, вы можете проиграть. В Clang такого нет.
    \subparagraph{BOLT.}
    BOLT~--- это не ключ компилятора, это инструмент, которому вы даёте уже скомпилированный бинарник и профиль, после чего оптимизирует. Есть статистика, согласно которой, BOLT работает лучше чем PGO на 15\%. Дело в том, что он группирует горячие данные вместе, тем самым эффективно используя кэш для инструкций. Почему это не используется в PGO~--- непонятно. LLVM пытались создать свой аналог (названный LLVM-propeller), но он \underline{\textbf{не взлетел}}. Поэтому теперь сам BOLT есть внутри LLVM четырнадцатой версии.
    \subsection{Статические анализаторы.}
    Это компьютерный сеньор, пользующийся методом пристального взгляда.
    \begin{minted}{c++}
        char* s = static_cast<char*>(malloc(N));
        // ...
        delete[] s;
    \end{minted}
    Статический анализатор от Microsoft скажет вам, что вы дурак. Почему так не делают все компиляторы? Потому что чисто по математическим причинам нельзя в Тьюринг-полном языке проверить, достижима ли строка или нет, а значит тем более нельзя гарантированно найти все ошибки (не имея ложных срабатываний). Впрочем, иногда ошибки статического анализатора переезжали в предупреждения компилятора. Например, код
    \begin{minted}{c++}
        printf("%p\n", 42);
    \end{minted}
    В VS2017 давал ошибку статического анализатора, VS2019~--- предупреждение.
    \paragraph{GCC PR18501.}\mbox{}\\
    \begin{multicols}{2}
    \begin{minted}{c++}
        void f()
        {
            bool first;

            for (; !finish;)
            {
                if (!first)
                something();
                first = false;
            }
        }
    \end{minted}
    \columnbreak
    \begin{minted}{c++}
        void g()
        {
            int value;
            if (flag)
                value = 42;

            something();

            if (flag)
                consume(value);
        }
    \end{minted}
    \end{multicols}\noindent
    Пользователям хочется, чтобы первый пример был некорректным, второй~--- корректным. Но есть проблема. Статический анализатор можно запускать сразу, а можно после некоторых оптимизаций. Если мы статически анализируем в самом начале, мы не можем во втором примере узнать, что \mintinline{c++}|if (flag)| два раза~--- это одно и то же, нужно узнать, что \mintinline{c++}|something| его не меняет. Если оптимизировать, то после оптимизации мы не увидим ошибки во втором случае, но не увидим и в первом, так как утратим информацию о том, что \mintinline{c++}|first| не был проинициализирован. Поэтому GCC пытается минимизировать ложные срабатывания, а Clang максимизировать истинные. А чтобы сделать всё хорошо, нужно иметь другую логику, нежели имеют компиляторы.
    \paragraph{SAL-аннотации.}
    Хорошо, статические анализаторы GCC и Clang междпроцедурные и даже могут смотреть сквозь единицы трансляции. В Visual Studio, увы, не так, поэтому вот такой код:
    \begin{minted}{c++}
        void f(int* val)
        {
            printf("%d", *val);
        }
    \end{minted}
    Непонятно, корректный ли. Хочется знать, какой у функции контракт. Можно ли передавать туда указатель на неинициализированную память, можно ли \mintinline{c++}|NULL| и т.д. Поэтому есть SAL-аннотации. Например~--- \mintinline{c++}|_Out_| говорит, что вы передаёте туда выделенную, но не обязательно проинициализированную память. Или \mintinline{c++}|_Out_writes_bytes_(size * sizeof(int))| говорит, что вы передали указатель, в котором можно записать \mintinline{c++}|size * sizeof(int)| байт.\\
    У Clang есть то же самое (например, \mintinline{c++}|int a __attribute__((guarded_by(m)));|). В этом примере при попытке записать в переменную не заблокировав \mintinline{c++}|m|, вам дадут предупреждение.\\
    Несмотря на свою привлекательность, статические анализаторы не очень популярны из-за того, что баланс между ложными срабатываниями и ложными не-срабатываниями не такой, как люди хотят видеть.
    \section{Пространства имён.}
    А что там вообще говорить? Да, но что-то проговорить надо.\\
    Что это такое и на кой оно надо? Есть библиотека cairo для векторной графики. И если полазить по её страницам, то можно заметить, что все функции называются как-то вида \mintinline{c++}|cairo_mesh_pattern_begin_patch|, \mintinline{c++}|cairo_mesh_pattern_move_to|, \mintinline{c++}|cairo_mesh_pattern_curve_to| и подобные бесконечно длинные названия? Чтобы не было коллизий. Вот назовёте вы функцию \mintinline{c++}|move_to|, а кто-то другой из другой библиотеки назовёт также свою функцию с совершенно другой семантикой. Проблемы. Поэтому в C все типы, функции и вообще всё имеет префикс по названию библиотеки, названию чего-нибудь ещё, и вот так появляются бесконечно длинные названия. В GNOME таких префиксов штуки по 3. В C++ чтобы подобных префиксов не было, были созданы пространства имён, где вы пишете что-то такое:
    \begin{minted}{c++}
        namespace cairo
        {
            namespace mesh
            {
                namespace pattern
                {
                    void curve_to();
                }
            }
        }
        // ...
        cairo::mesh::pattern::curve_to();
    \end{minted}
    Что мы выигрываем от этого? А то что находясь внутри пространства имён, мы можем вызывать свои функции без этих длинных префиксов:
    \begin{minted}{c++}
        namespace cairo
        {
            namespace mesh
            {
                namespace pattern
                {
                    void curve_to();

                    void test()
                    {
                        curve_to();
                    }
                }

                void test()
                {
                    pattern::curve_to();
                }
            }

            void test()
            {
                mesh::pattern::curve_to();
            }
        }
    \end{minted}
    Кстати, если вам интересно, чем отличаются функции \mintinline{c++}|test| с точки зрения линковщика, то в имена декорированных символов просто вписываются особым образом эти самые пространства имён.\\
    Всё что мы пишем вне любых пространств имён, считается лежащим в <<глобальном пространстве имён>>. Чтобы обратиться явно к чему-то в нём, напишите в начале имени просто двойное двоеточие.
    \paragraph{Способы не писать длинные названия извне.}
    Первый~--- namespace alias. Есть в стандартной библиотеке пространство имён \mintinline{c++}|std::filesystem|. Если мы не хотим писать долгое имя класса\\\mintinline{c++}|std::filesystem::path|, мы пишем \mintinline{c++}|namespace fs = std::filesystem|, и теперь можем писать \mintinline{c++}|fs::path|.\\
    Второй способ~--- using-declaration: \mintinline{c++}|using std::filesystem::path|. Теперь вы можете писать просто \mintinline{c++}|path|, и это будет синонимом \mintinline{c++}|std::filesystem::path|. Так можно делать с любыми сущностями, кроме других пространств имён. Надо понимать, что \mintinline{c++}|using|'и объявляют вам тип именно там, где он написан. Если вы напишете \mintinline{c++}|using| внутри другого пространства имён, то там он и останется. То есть
    \begin{minted}{c++}
        #include <filesystem>

        namespace f
        {
            using std::filesystem::path;
        }

        path p; // Некорректно.
        f::path p; // Корректно.
    \end{minted}
    Нечто похожее, но немного другое~--- using-directive: да возликует Рябчун, \mintinline{c++}|using namespace std|. Можно было бы подумать, что она делает \mintinline{c++}|using| всего, что в пространстве имён есть. Но это не так:
    \begin{minted}{c++}
        namespace n1
        {
            class mytype {};
            void foo();
        }

        namespace n2
        {
            class mytype {};
            void bar();
        }

        // ...
        using n1::mytype;
        using n2::mytype; // Ошибка.

        // ...
        using namespace n1;
        using namespace n2; // Нет ошибки.
        mytype a; // Тут есть ошибка "mytype is ambiguous".
    \end{minted}
    \mintinline{c++}|using namespace| не декларирует всё, что есть, а просто помечает, что в текущем пространстве имён используется другое. И компилятор просто берёт, и всегда когда ищет что-то в одном пространстве имён, также ищем это и во втором. Это даёт такого рода эффекты:
    \begin{minted}{c++}
        namespace n
        {}

        using namespace n;

        namespace n
        {
            class mytype {};
        }

        // ...
        mytype a;
    \end{minted}
    Такая штука вполне компилируется и делает то, что вы предполагаете. Понятно, что на той же строке вместо \mintinline{c++}|using namespace n| написать \mintinline{c++}|using n::mytype| нельзя.
    \paragraph{Приоритеты пространств имён.}
    Обычно если мы идём по уровням вверх в глобальное пространство, если в каком-то месте нашли имя, то оно нам и нужно. Если нашли два, то ambiguous. Если нашли два на разных уровнях, выбирается то, что ближе. Но вопрос~--- как со всем этим взаимодействуют \mintinline{c++}|using|'и.
    \begin{minted}{c++}
        namespace n1
        {
            int const foo = 1;
        }

        namespace n2
        {
            int const foo = 2;

            namespace n2_nested
            {
                using n1::foo;

                int test()
                {
                    return foo;
                }
            }
        }
    \end{minted}
    Так программа выводит единицу. Мы не нашли имя в \mintinline{c++}|test|, зато нашли в \mintinline{c++}|n2_nested|, притом одно. Смысл искать выше?
    \begin{minted}{c++}
        namespace n1
        {
            int const foo = 1;
        }

        namespace n2
        {
            int const foo = 2;

            namespace n2_nested
            {
                using namespace n1;

                int test()
                {
                    return foo;
                }
            }
        }
    \end{minted}
    Так программа выводит двойку. Дело в том, что имя \mintinline{c++}|foo| видно для нас как будто оно находится в наименьшем общем предке того, где мы находимся (\mintinline{c++}|test|) и \mintinline{c++}|n1|. Поэтому мы найдём \mintinline{c++}|n2::foo| на уровень ближе, чем \mintinline{c++}|n1::foo|, и используем его. И из этого вот такой пример:
    \begin{minted}{c++}
        namespace n1
        {
            int const foo = 1;
        }

        int const foo = 100;

        namespace n2
        {
            namespace n2_nested
            {
                using namespace n1;

                int test()
                {
                    return foo;
                }
            }
        }
    \end{minted}
    Не компилируется, потому что мы видим \mintinline{c++}|n1::foo| и \mintinline{c++}|::foo| на одном и том же уровне.
    \paragraph{Argument-dependent lookup.}
    \begin{minted}{c++}
        namespace mylib
        {
            class big_integer
            {};

            big_integer operator+(big_integer const& a, big_integer const& b);
            void swap(big_integer& a, big_integer& b);
        }

        int main()
        {
            mylib::big_integer a, b;
            a + b; // Мы не видим оператор + ни в main, ни в глобальном пространстве имён.
                   // Но почему-то работает.
        }
    \end{minted}
    ADL (argument-dependent lookup). Когда мы вызываем оператор, он ищется не как описано выше, а учитывает типы параметров. Точнее, смотрит в то пространство имён, где написаны аргументы оператора. Для каждого аргумента ищет в его пространстве имён. Причём только в его пространстве имён, не выше.\\
    То же самое работает вообще для любых функций, не только для операторов, кстати. Для \mintinline{c++}|swap| тоже. Со \mintinline{c++}|swap| вообще интересная тема. Мы хотим для каких-то шаблонных классов \mintinline{c++}|swap|'нуть их. Как? Вот так:
    \begin{minted}{c++}
        template <class T>
        void foo(T a, T b)
        {
            // ...

            using std::swap;
            swap(a, b);

            // ...
        }
    \end{minted}
    Теперь что получается? У нас получается шаблонный \mintinline{c++}|std::swap| и, возможно, не-шаблонный ADL. Если у нас есть ADL, выбирается он, потому что из шаблонного и не-шаблонного выбирается второй. Если нет ADL, то есть только \mintinline{c++}|std::swap|, и он вызывается. Если не сделать \mintinline{c++}|using std::swap|, то функция не будет работать для, скажем, \mintinline{c++}|int|'ов.
    В контексте шаблонов надо сказать, что ADL работает на этапе подстановки шаблона, в то время как поиск имени по дереву вверх~--- на этапе парсинга.
    \paragraph{Безымянные пространства имён.}
    Есть вот такая штука:
    \begin{minted}{c++}
        namespace
        {
            // ...
        }
    \end{minted}
    Она по определению эквивалентна
    \begin{minted}{c++}
        namespace some_unique_identifier
        {
            // ...
        }

        using namespace some_unique_identifier;
    \end{minted}
    На кой это? Вот зачем. В C было ключевое слово \mintinline{c++}|static| под переменные, функции, но не типы. Потому что типы не генерируют код, они и так локальные на единицу трансляции. Но в C++ они (из-за наличия специальных функций-членов класса) его генерируют. Если у нас есть два нетривиально-разрушаемых типа \mintinline{c++}|mytype| в разных единицах трансляции, у него будет конфликт деструкторов. Более того, тут есть ещё более интересный пример:
    \begin{minted}{c++}
        // a.cpp
        struct my_type
        {
            int a;
        };
    
        void foo()
        {
            std::vector<mytype> v;
            v.push_back(/*...*/);
        }

        // b.cpp
        struct my_type
        {
            int a, b;
        };
        
        void bar()
        {
            std::vector<mytype> v;
            v.push_back(/*...*/);
        }
    \end{minted}
    Тут сами классы тривиально делают вообще всё (создаются, копируются и разрушаются), значит с ними нет нарушения. Но есть нарушение ODR в \mintinline{c++}|std::vector<mytype>::push_back|, он делает разные вещи для разных \mintinline{c++}|mytype|.\\
    И тут приходит прекрасный фикс проблемы \mintinline{c++}|static| на типы: анонимные пространства имён, которые (как несложно заметить), делают именно то, что вам нужно. Более того, теперь можно вообще нигде не писать \mintinline{c++}|static|, а писать анонимные пространства имён (собственно, поэтому \mintinline{c++}|static| на самом деле deprecated). И анонимные пространства имён даже лучше:
    \begin{minted}{c++}
        template <int*>
        struct foo
        {};

        int x, y;

        int main()
        {
            foo<&x> a;
            foo<&y> a;
        }
    \end{minted}
    С \mintinline{c++}|foo<&x>| мы, вроде, понимаем, что на этапе компиляции мы знаем адрес переменной, вот и хорошо. А когда мы напишем
    \begin{minted}{c++}
        template <int*>
        struct foo
        {};

        static int x, y;

        int main()
        {
            foo<&x> a;
            foo<&y> b;
        }
    \end{minted}
    В C++03 возникнет проблема, потому что теперь \mintinline{c++}|x|~--- больше не уникальное имя. А это проблема, поскольку \mintinline{c++}|foo<&x>|~--- это декорированное имя \mintinline{c++}|foo|, в который встроили адрес переменной \mintinline{c++}|x|. А когда мы имеем \mintinline{c++}|static|, из-за не уникальности строки \mintinline{c++}|&x| в разных единицах трансляции, уникально задекорировать \mintinline{c++}|foo<&x>| не получится.\\
    Итак, \mintinline{c++}|static| сделали deprecated в C++03, но в C++11 сказали, что если человек пишет <<\mintinline{c++}|static|>>, он имеет ввиду безымянное пространство имён.
    \section{Type-based dispatch.}
    В языке существует и иногда необходимо узнавать какое-то свойство у типа. Если мы пишем обобщённое возведение в степень, нужно спрашивать, что считается единицей. Или есть мы пишем операции с числами, хочется взять максимум данного типа. Очень много из такого делает стандартная библиотека: например, есть \mintinline{c++}|std::advance|~--- функция, которая делает итератору \mintinline{c++}|+=|, даже если он так не умеет, а умеет только \mintinline{c++}|++|. И тут мы либо делаем \mintinline{c++}|+=|, либо \mintinline{c++}|++| много раз, в зависимости от типа. Надо спросить, умеет ли он так.\\
    Часть запросов к типу предоставляет стандартная библиотека, например, в заголовочном файле \mintinline{c++}|type_traits|, где есть бесконечное количество шаблонных констант \mintinline{c++}|is_trivially_destructible_v|, \mintinline{c++}|is_empty_v|, и прочих других. Какие-то из встроены в компилятор, какие-то вы можете реализовать сами (\mintinline{c++}|is_signed_v|, например, можете запросто). Или можете сами реализовать полностью \mintinline{c++}|std::numeric_limits|~--- класс с миллионом статических полей, который для целочисленных типов и типов с плавающей точкой даёт информацию о минимуме, максимуме или чём-то ещё.\\
    Как работают штуки из \mintinline{c++}|type_traits|? И почему оканчиваются на \mintinline{c++}|_v|? Дело в том, что до C++14 у вас не было шаблонных переменных (а по сути \mintinline{c++}|is_empty_v|~--- шаблонная переменная и есть). Поэтому создали шаблонный класс \mintinline{c++}|is_empty| со статическим полем \mintinline{c++}|value|, в котором то, что вам нужно. А когда в С++14 такое появилось, вы смогли писать \mintinline{c++}|is_empty_v|, и это уже реальная \mintinline{c++}|bool|'евая константа, которую можно использовать.
    \paragraph{Наивный способ диспатчить что-то исходя из типа. \textit{Constexpr if statement}.}
    Пример использования \mintinline{c++}|type_traits|: хотим мы вызвать деструкторы всех элементов на отрезке:
    \begin{minted}{c++}
        template <class T>
        void destroy(T* first, T* last)
        {
            for (T* p = first, p != last; p++)
                p->~T();
        }
    \end{minted}
    Для некоторых классов это можно реализовать иначе. Например, для типов, которые тривиально разрушаются, можно ничего не делать:
    \begin{minted}{c++}
        #include <type_traits>
        
        template <class T>
        void destroy(T* first, T* last)
        {
            if (!std::is_trivially_destructible_v<T>)
                for (T* p = first, p != last; p++)
                    p->~T();
        }
    \end{minted}
    Но тут есть проблема. Давайте аналогичным образом напишем свой \mintinline{c++}|std::advance|.
    \begin{minted}{c++}
        #include <type_traits>
        #include <iterator_traits>

        template <class It>
        void advance(It& it, ptrdiff_t n)
        {
            using category = typename std::iterator_traits<It>::iterator_category;
            if (std::is_base_of_v<std::random_access_iterator_tag, category>)
            {
                it += n;
            }
            else
            {
                while (n > 0)
                {
                    --n;
                    ++it;
                }
                while (n < 0)
                {
                    ++n;
                    --it;
                }
            }
        }
    \end{minted}
    Тут когда вы запустите это от \mintinline{c++}|std::list<T>::iterator|, ваш код не скомпилируется. Потому что компилируются всё равно обе ветки, в частности компилируется \mintinline{c++}|+=|, а для итератора списка оно не компилируется. В C++17 есть простое решение этой проблемы: \mintinline{c++}|if constexpr|~--- работает как \mintinline{c++}|if|, но только с compile-time константами, и при этом компилируется только нужная ветка. Но так сделать у вас есть возможность не всегда.
    \paragraph{Iterator dispatch.}
    В нашем случае можно переписать так:
    \begin{minted}{c++}
        #include <iterator_traits>

        template <class It>
        void advance_impl(It& it, ptrdiff_t n, std::random_access_iterator_tag)
        {
            it += n;
        }

        template <class It>
        void advance_impl(It& it, ptrdiff_t n, std::input_iterator_tag)
        {
            while (n > 0)
            {
                --n;
                ++it;
            }
            while (n < 0)
            {
                ++n;
                --it;
            }
        }

        template <class It>
        void advance(It& it, ptrdiff_t n)
        {
            using category = typename std::iterator_traits<It>::iterator_category;
            advance_impl(it, n, category());
        }
    \end{minted}
    Это называется iterator dispatch, и работает также хорошо, как и \mintinline{c++}|if constexpr|, несмотря на передачу лишнего параметра (этот параметр~--- пустая структура, его на самом деле никто не передаёт).
    \paragraph{\texttt{std::conditional}.}
    Ну, хорошо, но тут у нас уже есть теги. А если их нет? Например, если мы хотим таким же образом переписать \mintinline{c++}|destroy|? Тогда создадим эти теги сами.
    \begin{minted}{c++}
        struct trivially_destructible_tag
        {};

        struct not_trivially_destructible_tag
        {};

        template <class T>
        void destroy_impl(T* first, T* last, trivially_destructible_tag)
        {}

        template <class T>
        void destroy_impl(T* first, T* last, not_trivially_destructible_tag)
        {
            if (!std::is_trivially_destructible_v<T>)
                for (T* p = first; p != last; p++)
                    p->~T();
        }
    
        template <class T>
        void destroy(T* first, T* last)
        {
            // Хочется как-то выбрать одну структуру из двух на этапе компиляции.
        }
    \end{minted}
    Хочется как-то выбрать одну структуру из двух на этапе компиляции. Как? Вот так:
    \begin{minted}{c++}
        template <bool Cond, typename IfTrue, typename IfFalse>
        struct conditional
        {
            using type = IfFalse;
        };

        template <typename IfTrue, typename IfFalse>
        struct conditional<true, IfTrue, IfFalse>
        {
            using type = IfTrue;
        };

        template <class T>
        void destroy(T* first, T* last)
        {
            using tag = typename conditional<is_trivially_destructible_v<T>,
                                    trivially_destructible_tag,
                                    not_trivially_destructible_tag>::type;
            destroy_impl(first, last, tag());
        }
    \end{minted}
    Барабанная дробь, такое уже есть, и называется \mintinline{c++}|std::conditional|. А \mintinline{c++}|typename std::conditional</*...*/>::type| также сокращается до \mintinline{c++}|std::conditional_t|. Итого наш пример выглядит так:
    \begin{minted}{c++}
        #include <type_traits>

        struct trivially_destructible_tag
        {};

        struct not_trivially_destructible_tag
        {};

        template <class T>
        void destroy_impl(T* first, T* last, trivially_destructible_tag)
        {}

        template <class T>
        void destroy_impl(T* first, T* last, not_trivially_destructible_tag)
        {
            if (!std::is_trivially_destructible_v<T>)
                for (T* p = first; p != last; p++)
                    p->~T();
        }

        template <class T>
        void destroy(T* first, T* last)
        {
            using tag = std::conditional_t<is_trivially_destructible_v<T>,
                                           trivially_destructible_tag,
                                           not_trivially_destructible_tag>;
            destroy_impl(first, last, tag());
        }
    \end{minted}
    Это кайф, но у этого есть проблема. Когда у нас функции были как перегрузки, мы могли свободно добавлять в список перегрузок новые классы с новыми свойствами. А когда мы делаем это \mintinline{c++}|if|'ами (хоть \mintinline{c++}|if constexpr|, хоть \mintinline{c++}|std::conditional_t|), новые классы с новыми свойствами не добавить.
    \paragraph{SFINAE.}
    И есть способ. Напишем вот что:
    \begin{minted}{c++}
        template <class C>
        void erase(C& cont, typename C::iterator pos)
        {}

        template <class T, size_t N>
        void erase(T (&cont)[N], T* pos)
        {}
    \end{minted}
    Когда мы вызываем это от чего-то, у нас сначала вывод параметров, потом подстановка. Что будет при вызове от \mintinline{c++}|int arr[100]|? Вывод даст нам \mintinline{c++}|C| = \mintinline{c++}|int[100]| в первом случае, \mintinline{c++}|T| = \mintinline{c++}|int|, \mintinline{c++}|N| = \mintinline{c++}|100| во втором. Но когда мы подставим тип в аргументы, во втором случае всё получится, а в первом мы увидим \mintinline{c++}|int[100]::iterator|. Так нельзя, это ошибка компиляции! Но тогда как-то совсем было бы грустно жить с таким кодом. К тому же зачем, если у нас есть корректная подстановка. Поэтому считается, что если ошибка подстановки, то вариант просто не рассматривается. Это имеет название: substitution failure is not an error (SFINAE). Провал вывода также не является ошибкой компиляции, если что.
    \subparagraph{\texttt{std::enable\char`_if}.}
    Теперь, вооружившись SFINAE, сделаем так, чтобы наш \mintinline{c++}|destroy| работал без \mintinline{c++}|if|'ов:
    \begin{minted}{c++}
        template <bool>
        struct enable_if
        {};

        template <>
        struct enable_if<true>
        {
            using type = void;
        };

        template <class T>
        typename enable_if<std::is_trivially_destructible_v<T>>::type // Это возвращаемое значение.
        destroy(T* first, T* last)
        {}

        template <class T>
        typename enable_if<!std::is_trivially_destructible_v<T>>::type
        destroy(T* first, T* last)
        {
            if (!std::is_trivially_destructible_v<T>)
                for (T* p = first, p != last; p++)
                    p->~T();
        }
    \end{minted}
    Опять же, подобная штука в стандартной библиотеке есть, и называется \mintinline{c++}|std::enable_if|. Для \mintinline{c++}|typename enable_if</*...*/>::type| также создана короткая версия: \mintinline{c++}|std::enable_if_t|. На практике SFINAE применимо где-нибудь в таком месте:
    \begin{minted}{c++}
        template <class T>
        struct vector
        {
            void assign(size_t count, T const& value);
            
            template <class InputIt>
            void assign(InputIt first, InputIt last);
        };

        int main()
        {
            vector<size_t> v;
            
            v.assign(10, 0); // Выбирается шаблонная перегрузка, потому что подходит идеально.
        }
    \end{minted}
    Исправляется вот так:
    \begin{minted}{c++}
        #include <iterator_traits>
        #include <type_traits>

        template <class T>
        struct vector
        {
            void assign(size_t count, T const& value);

            template <class InputIt>
            std::enable_if_t<
               std::is_base_of_v<
                    std::input_iterator_tag,
                    std::iterator_traits<InputIt>::category
                >
            > assign(InputIt first, InputIt last);
        };

        int main()
        {
            vector<size_t> v;
            
            v.assign(10, 0);
        }
    \end{minted}
    Это долго и неудобно. Зато работает. Но есть вам очень не нравится, в C++20 есть концепты. Пример выше с их использованием вообще пишется на ура:
    \begin{minted}{c++}
        #include <iterator>

        template <class T>
        struct vector
        {
            void assign(size_t count, T const& value);
            
            template <std::input_iterator InputIt>
            void assign(InputIt first, InputIt last);

            /* Также можно вот так:
            template <class InputIt>
                requires std::input_iterator<InputIt>
            void assign(InputIt first, InputIt last);

            После requires можно и что-то более сложное писать. */
        };

        int main()
        {
            vector<size_t> v;
            
            v.assign(10, 0);
        }
    \end{minted}
    У концептов есть ещё одно преимущество, помимо размера. Когда мы пользуемся SFINAE, нам необходимо перебрать все случаи перегрузок. Если вы в \mintinline{c++}|destroy| написали перегрузку под \mintinline{c++}|std::trivially_destructible|, напишите под \mintinline{c++}|!std::trivially_destructible|. А если вы хотите расширять, будьте добры изменить предикаты. А концепты умеют понимать, что один концепт расширяет другой, как с шаблонами. И выбирать наиболее специализированный вариант.
    \section{Наследование.}
    Предполагается, что что-то о наследовании вы знаете и примерно представляете, что это такое (хотя бы на уровне концепта). Если нет~--- жаль. А мы не будем обсуждать всё в мельчайших деталях, потому что в книжках оно обсасывается очень подробно.\\
    Про наследование сложно говорить в том же ключе, в котором мы говорили об исключениях/шаблонах и т.п. Говорили мы о том, что есть проблема, и вот как она решается. Нет конкретной задачи, где необходимо наследование. Поэтому на эту тему таким способом смотреть не будем, а будем иначе: у нас сначала будет механизм, и потом мы будем его применять.
    \paragraph{Немного введения.}
    Итак, откуда идёт наследование? Пусть мы решаем моделирование дорожной сети, хотим понять, как переключать светофоры, где построить дорогу и т.п. И в этой области у нас есть какие-то объекты. И вот объектам предметной области сопоставим объекты нашей программы. И у нас очень естественно получается полиморфизм~--- у нас есть произвольные транспортные средства, которые очень похожи, а есть автобусы, трамваи и подобное, то есть более специализированные штуки. И есть мы можем что-то сделать с транспортным средством в общем, давайте так и будем делать. Это не столько способ организации программы, сколько образ мысли. Причём полезный: мы можем сразу начать декомпозировать задачу (даже не зная её решения), можем сразу объяснить, что где происходит и т.д. И, кстати, совсем необязательно объекту реальности сопоставлять объект программы, это может быть неэффективно~--- если мы решаем задачу о минимизации чего-то (за минимальные деньги перестроить дорогу так что...), то совершенно необязательно у вас будут такие же объекты. А ещё бывает ситуация, когда вы придумываете движок регулярных выражений~--- никакие структуры из внешнего мира не приходят, вы делаете что-то, не имеющее отношения к реальности. И реальные программы где-то посередине: часть из реального мира, часть к нему не имеет отношения.
    \paragraph{Итак, наследование.}
    Итак, как делать наследование в C++.
    \begin{minted}{c++}
        struct vehicle
        {
            size_t registration_number;
        };

        struct bus : vehicle
        {};

        struct truck : vehicle
        {};
    \end{minted}
    (Надо понимать, что вам не нужно создавать класс \mintinline{c++}|bus|, если с автобусом вы не хотите как-то особо взаимодействовать.)\\
    Так вот, что тут происходит? Тут у классов \mintinline{c++}|bus| и \mintinline{c++}|truck| также есть регистрационный номер. Правильный способ думать об этом~--- как будто у них есть особое поле типа \mintinline{c++}|vehicle|, и если вы обращаетесь в чему-то в вашем классе, чего в нём нет, то вы ищете это в базовом классе. Что будет, кстати, есть в базовом и производном классе есть переменная с одним и тем же именем? Во-первых, это разрешено компилятором~--- у вас будет две разных переменные с одним именем (потому что вы можете не знать своих родителей полностью, или когда вы добавляли поле себе, у родителя его не было). Если вы хотите обратиться к переменной базового класса, то делается это вот как:
    \begin{minted}{c++}
        struct base
        {
            int xyz; // 1
        };

        struct derived : base
        {
            int xyz; // 2
        };

        int main()
        {
            derived d;
            d.xyz = 123; // Изменяется 2.
            ((base&)d).xyz = 123; // Изменяется 1.
            d.base::xyz = 123; // Специальный синтаксис для изменения 1.
        }
    \end{minted}
    Второе, что позволяет делать наследование~--- приведение указателей и ссылок наследуемого класса к указателям и ссылкам базового, как тут в предпоследней строке. Те же самые правила применимы к методам.
    \paragraph{Worst practices.}
    Во-первых, не надо наследоваться, если вам нужно только расширить класс. Вот хотите вы добавить новый функционал в \mintinline{c++}|std::string|, не нужно от него наследоваться. Потому что вы и ваш коллега захотят расширить строки по-разному, получите два новых типа, замените \mintinline{c++}|std::string| на свой, а потом не сможете вызывать функции друг друга. Не надо так, создайте обычную функцию. Обычные функции~--- это хорошо, не надо писать всё классами от того, что вы научились.\\
    Во-вторых, не надо создавать отдельный класс под одну операцию.
    \begin{minted}{c++}
        struct string_printer
        {
        private:
            std::string msg;

        public:
            string_printer(const std::string& msg)
                : msg(msg)
            {}

            void print()
            {
                std::cout << msg;
            }
        };
    \end{minted}
    Это просто шиза, этим и является, но это пока пример простой выглядит идиотски. К тому же, у этого есть другая проблема~--- вот сделали вы \mintinline{c++}|string_printer("Hello, world").print()|. А что если вы не сделаете \mintinline{c++}|print|, или сделаете дважды? Потому что напечатать-то вы можете и в конструкторе, зачем вам метод? Мораль: не заводите класс, если вам нужно сделать действие. Исключение~--- какие-нибудь компараторы, которые в общем случае могут быть полноценными классами, но вообще могут являться и обёрткой вокруг функции. И вот тут ничего не поделаешь, \mintinline{c++}|std::map| принимает класс, а не функцию.
    \paragraph{Виртуальные функции.}
    Виртуальные функции~--- единственное, для чего вам нужно наследование. Если вы не используете виртуальные функции, наследование вам по сути не нужно.
    \begin{minted}{c++}
        struct vehicle
        {
            void print()
            {
                std::cout << "vehicle" << std::endl;
            }
        };

        struct bus : vehicle
        {
            void print()
            {
                std::cout << "bus" << std::endl;
            }
            
        };

        struct truck : vehicle
        {};

        int main()
        {
            vehicle v;
            v.print(); // vehicle
            bus b;
            b.print(); // bus
            truck t;
            t.print(); // vehicle
        }
    \end{minted}
    А теперь мы делаем функцию \mintinline{c++}|foo|:
    \begin{minted}{c++}
        void foo(vehicle& v)
        {
            v.print();
        }
    \end{minted}
    Тут всегда мы смотрим на \mintinline{c++}|vehicle| и всегда вызываем его функцию \mintinline{c++}|print|, даже если передадим туда \mintinline{c++}|bus|. А не хочется. Сначала введём пару определений. Есть статический тип~--- это то, что видит компилятор (в данном случае \mintinline{c++}|vehicle|). Но по сути ваш \mintinline{c++}|vehicle| может быть \mintinline{c++}|bus|'ом или \mintinline{c++}|truck|'ом. И вот это называется динамическим типом. Так вот, виртуальные функции позволяют выбирать метод исходя из динамического типа, а не статического:
    \begin{minted}{c++}
        struct vehicle
        {
            virtual void print()
            {
                std::cout << "vehicle" << std::endl;
            }
        };

        struct bus : vehicle
        {
            void print()
            {
                std::cout << "bus" << std::endl;
            }
            
        };

        struct truck : vehicle
        {};

        int main()
        {
            vehicle v;
            foo(v); // vehicle
            bus b;
            foo(b); // bus
            truck t;
            foo(t); // vehicle
        }
    \end{minted}
    Где это бывает нужно в жизни? Ну, например, вы можете вывести в поток что-то:
    \begin{minted}{c++}
        std::ostream& operator<<(std::ostream& ostr, /*something*/)
        {
            return ostr << /* something */ << /* something else */;
        }
    \end{minted}
    И теперь, поскольку и \mintinline{c++}|std::stringstream|, и \mintinline{c++}|std::ofstream| наследуются от \mintinline{c++}|std::ostream|, это работает для совершенно любых потоков, учитывая то, что у них по-разному определён оператор \mintinline{c++}|<<| от, например, числа.
    \paragraph{Срезка (slicing) наследуемого класса.}
    \label{par:slicing}
    \begin{minted}{c++}
        int main()
        {
            bus b;

            vehicle v = b;
            v.print();
        }
    \end{minted}
    Тут \mintinline{c++}|b| неявно приводится к \mintinline{c++}|vehicle&|, после чего вызывается созданный компилятором конструктор копирования \mintinline{c++}|vehicle(vehicle const&)|. И создаётся новый объект, у которого динамический тип \mintinline{c++}|vehicle|, и у него вызывается его \mintinline{c++}|print|.\\
    Это называется срезкой и в большинстве случаев~--- не то что вы хотите. Так что удалите конструктор копирования и оператор присваивания у класса \mintinline{c++}|vehicle|.
    \paragraph{Виртуальные деструкторы.}
    \begin{minted}{c++}
        int main()
        {
            bus* b = new bus();

            vehicle* v = b;
            v->print();
            
            delete v;
        }
    \end{minted}
    Тут вызывается \mintinline{c++}|v->~vehicle|. А если \mintinline{c++}|bus| имеет какой-то нетривиальный деструктор, он не вызовется. Поэтому тут вам всё также надо вызывать деструктор в зависимости от динамического типа, а не статического.
    \begin{minted}{c++}
        struct vehicle
        {
            virtual ~vehicle() {}
        };
    \end{minted}
    С точки зрения языка, вы не имеете права делать \mintinline{c++}|delete| у базового класса, есть создали наследуемый и не пометили деструктор базового как \mintinline{c++}|virtual|. Если будете так делать~--- UB. \textbf{Даже если все деструкторы тривиальные.} Почему? А вот:
    \paragraph{Множественное наследование.}
    \begin{minted}{c++}
        struct base1
        {
            int x;
        };
        struct base2
        {
            int y;
        };
        struct derived : base1, base2
        {};
        
        int main()
        {
            derived* d = new derived;
            base2* b2 = d;

            delete b2;
        }
    \end{minted}
    Это некорректно, потому что первый базовый класс лежит по тому же адресу, что и оригинальный класс, а второй~--- со смещением. Поэтому его удалить нельзя, вы освобождаете память не по тому указателю. А виртуальный деструктор вас спасёт.\\
    Ещё про множественное наследование нужно сказать вот что:
    \begin{minted}{c++}
        struct base1
        {
            int x;
        };
        struct base2
        {
            unsigned x;
        };
        struct derived : base1, base2
        {};
        
        int main()
        {
            derived d;
            std::cout << d.x; // Некорректно, непонятно, какой x имеется ввиду.
            std::cout << d.base1::x; // Корректно, x из base1.
            std::cout << d.base2::x; // Корректно, x из base2.
        }
    \end{minted}
    Ещё один интересный момент про множественное наследование:
    \begin{minted}{c++}
        struct base2;
        struct derived;
        base2& to_base2(derived& d)
        {
            return (base2&)d;
        }

        struct base1
        {
            int x;
            base1(int x) : x(x) {}
        };
        struct base2
        {
            int y;
            base2(int y) : y(y) {}
        };
        struct derived : base1, base2
        {
            derived(int x, int y)
                : base1(x), base2(y) {} // Кстати, так вызываются конструкторы базовых.
        };

        int main()
        {
            derived d(1, 2);
            std::cout << to_base2(d).y << std::endl; // Выводится 1.
        }
    \end{minted}
    Почему? А вот почему. Когда мы пишем \mintinline{c++}|to_base2|, мы ещё не знаем, что один класс наследуется от другого, причём так, что ещё и указатели надо двигать. Он будет их двигать, если написать \mintinline{c++}|to_base2| после классов, а так нет. Поэтому в C++ запретили касты из C, а добавили 4 новых.
    \paragraph{Касты.}
    \subparagraph{\texttt{static\char`_cast}.} Чаще всего вам нужен именно он. Кастует числа друг в друга, ссылки и указатели по иерархии наследования в любую сторону, \mintinline{c++}|void*| в любой указатель и обратно. При этом, понятно, кастовать \mintinline{c++}|void*| куда-то корректно, если там изначально было то, куда вы кастуете. Аналогично, вниз по иерархии (от базового к наследуемому) можно кастовать только тогда, когда совпадает динамический тип. Иначе UB.
    \subparagraph{\texttt{const\char`_cast}.} Снимает модификаторы \mintinline{c++}|const| и \mintinline{c++}|volatile|. Чаще всего это делать не надо, но иногда бывает нужно всё-таки. В стародавние времена, когда \mintinline{c++}|const|'ов не было, были функции, принимавшие указатель. Неконстантный. Хотя не меняли его содержимое. И вот в таком случае вы можете снять \mintinline{c++}|const| с указателя. Про снятие \mintinline{c++}|const|'ов мы уже говорили, если изначальный объект был \mintinline{c++}|const|, снимать с него \mintinline{c++}|const| ни в коем случае нельзя. Если изначальный объект константным не был, а потом вы сначала навесили \mintinline{c++}|const|, а потом сняли, то всё хорошо.
    \subparagraph{\texttt{reinterpret\char`_cast}.} Это всё зашкварное из C-style cast'а. Перевод указателей из несвязанных друг с другом типов, указатели в число. Простой и эффективный способ получить UB. В стандарте так и написано, это implementation-defined cast. Обратитесь к поставщику вашего компилятора, чтобы понять, как у вас работает \mintinline{c++}|reinterpret_cast|.
    \subparagraph{\texttt{dynamic\char`_cast}.} Это немного другое, нежели все остальные касты. \mintinline{c++}|dynamic_cast| работает только для указателей и ссылок на полиморфные (хотя бы одна виртуальная функция) классы. Кастует по иерархии вниз (это, напомню, от базового к наследуемому), но, в отличие от \mintinline{c++}|static_cast|'а, может проверять, что преобразование корректно. То есть \mintinline{c++}|static_cast| по иерархии вниз берёт и кастует. А \mintinline{c++}|dynamic_cast| кастовать пытается, и если у него не получается, то возвращает \mintinline{c++}|nullptr| в случае указателей, или кидает \mintinline{c++}|std::bad_cast| в случае ссылок. Чтобы понять, как это работает, надо понять, как вообще работают виртуальные функции изнутри.
    \paragraph{Полиморфизм изнутри.}
    Как бы мы сделали полиморфизм руками, если бы у нас его не было? Ну, через указатели на функции. По-другому не получится, потому что мы не знаем список всех наших наследников:
    \begin{minted}{c++}
        struct base
        {
            base();
            
            void (*foo)(base*);
            void (*bar)(base*, int);
            void (*baz)(base*, double);
        };
        void foo_base(base* self)
        {
            // ...
        }
        void bar_base(base* self, int x)
        {
            // ...
        }
        void baz_base(base* self, double y)
        {
            // ...
        }
        base::base()
            : foo(foo_base), bar(bar_base), baz(baz_base)
        {}

        struct derived : base
        {
            derived();
        };
        
        void foo_derived(base* self)
        {
            derived* derived_self = static_cast<derived*>(self);
            // ...
        }
        void bar_derived(base* self, int x)
        {
            derived* derived_self = static_cast<derived*>(self);
            // ...
        }
        void baz_derived(base* self, double y)
        {
            derived* derived_self = static_cast<derived*>(self);
            // ...
            
        }
        derived::derived()
        : foo(foo_derived), bar(bar_derived), baz(baz_derived)
        {}

        int main()
        {
            derived d;
            d.bar(&d, 42);
        }
    \end{minted}
    Так в целом можно, но можно и чуть оптимальнее. У нас наши тройки функций не могут комбинироваться как им вздумается, всегда либо все из \mintinline{c++}|base|, либо все из \mintinline{c++}|derived|. И к тому же, нам не хочется с каждой новой функцией увеличивать размер структуры. Поэтому есть такая штука как таблица виртуальных функций. Это мы берём наши 3 указателя и выносим их в особый объект, указатель на который помещается в нашу структуру. А таких структур создать под каждый класс глобальными переменными. Это даёт нам ещё один indirection, но сокращает размер структур. И именно так это и работает во всех компиляторах. Во множественном наследовании у класса просто появляются две таблицы, под каждый базовый класс своя.
    \subparagraph{RTTI. \texttt{typeid}.}
    И как же работает \mintinline{c++}|dynamic_cast|? И почему требует полиморфных типов? А потому что в таблицах виртуальных функций может хранится что-то другое, не только указатели на функции. В частности, в них хранится такая штука как RTTI~--- runtime type information. Это какая-то информация, которую компилятор вставляет в таблицу, чтобы понимать динамический тип. И к ней даже можно получить. Для этого есть такая штука как ключевое слово \mintinline{c++}|typeid|, который вам возвращает \mintinline{c++}|std::type_info const&|, который по сути и является RTTI.\\
    Кстати, в большинстве компиляторов можно выключать RTTI, чтобы не тратить лишнее место. И в каких-то кодовых базах можно увидеть код без \mintinline{c++}|dynamic_cast|'ов и \mintinline{c++}|typeid|.
    \paragraph{Чисто виртуальные функции.}
    Вот создали вы, скажем, логгер. И отнаследовались из него, создав логгер, который пишет в файл, логгер, который пишет в консоль и т.д. Возникает вопрос~--- а что должен делать базовый логгер? Ну, непонятно. Ничего путного. Для этого есть механизм чисто виртуальных (абстрактных) функций~--- пометить, что этой функции не существует:
    \begin{minted}{c++}
        struct logger
        {
            virtual void log_message(std::string const& str) = 0;
        };
    \end{minted}
    Тогда вы не можете её вызвать. И не можете создать класс, содержащий чисто виртуальную функцию. Но есть проблема:
    \begin{minted}{c++}
        struct base
        {
            base()
            {
                foo();
            }
            void foo()
            {
                bar();
            }
            virtual void bar() = 0;
        };

        struct derived : base
        {
            void bar() {};
        };
    \end{minted}
    Тут, когда вы создадите \mintinline{c++}|derived|, вам на этапе исполнения скажут, что вы вызываете чисто виртуальную функцию. Почему? Если бы вы вызывали \mintinline{c++}|derived::bar|, то вы бы вызвали его тогда, когда у вас даже поля \mintinline{c++}|derived| не проинициализированы. Поэтому считается, что когда вы конструируете объект типа \mintinline{c++}|derived|, когда вы конструируете \mintinline{c++}|base|, в тот момент ваш динамический тип равен \mintinline{c++}|base|. То есть когда вызывается конструктор объекта, он не сразу с тем динамическим типом, который у него есть, а изменяется по чуть-чуть, сначала он базовый, а потом нормальный. Когда иерархия больше, динамический тип меняется большее количество раз.\\
    А ещё этот пример не работает без прослойки вида \mintinline{c++}|foo|. Почему так? А вот смотрите. У вас есть возможность вызвать виртуальную функцию напрямую (без виртуальных функций), например так: \mintinline{c++}|base::foo|. Но это не единственный пример. Если вы вызываете функцию в конструкторе и деструкторе, то вы точно знаете, что сейчас ваш динамический тип правильный. Поэтому, написав код
    \begin{minted}{c++}
        struct base
        {
            base()
            {
                bar();
            }
            virtual void bar() = 0;
        };
        
        struct derived : base
        {
            void bar() {};
        };
    \end{minted}
    Вы получите ошибку компиляции, потому что в \mintinline{c++}|base::base| происходит вызов \mintinline{c++}|base::bar|, а не просто \mintinline{c++}|bar|, а значит мы явно вызываем виртуальную функцию. А у функции \mintinline{c++}|base::bar| нет тела, её нельзя вызвать.
    \paragraph{Парочка полезных ключевых слов.}
    \subparagraph{\texttt{final}.}
    \mintinline{c++}|final|~--- нельзя наследовать. Либо нельзя наследовать класс, либо больше нельзя больше изменять функцию. Пишется так:
    \begin{minted}{c++}
        struct inderriveable final
        {
            // ...
        };

        struct base
        {
            virtual void foo() {}
        };

        struct derived : base
        {
            void foo() final {}
        };
    \end{minted}
    \subparagraph{\texttt{override}.}
    Явно указать, что вы наследуете виртуальную функцию, а не пишете что-то своё. Очень советуется это писать. Если кто-то изменит базовый класс, вы хотите явно видеть, что все функции поломаются. Пишется в том же месте, где и \mintinline{c++}|final|.
    \paragraph{Наследование против \texttt{union}'а.}
    Мы же можем использовать наследование для той же цели, что и \mintinline{c++}|union|/\mintinline{c++}|std::variant|~--- выбирать из альтернативы. В случае с \mintinline{c++}|std::variant| мы даже можем проверять корректность обращения. Что же лучше?
    \begin{figure}[H]
        \begin{tabular}{|m{0.5\textwidth}|m{0.5\textwidth}|}
            \hline
            Наследование & \mintinline{c++}|union|\\
            \hline
            Если альтернативы разного размера, то \mintinline{c++}|union| жрёт много памяти. & Наследование работает по указателю, а это даёт лишнюю индирекцию.\\
            \hline
            Можно легко добавить новую альтернативу. & Можно легко добавить новую операцию.\\
            \hline
        \end{tabular}
    \end{figure}
    \paragraph{\texttt{protected}.}
    Представим, что мы пишем виджет на основе QT. Там есть базовый виджет, у которого есть операции, что делать в случае нажатия мышки, в случае перемещения колёсика и прочее подобное. Вам всё это нужно переопределить, и всё будет хорошо. И в таком случае используется ключевое слово \mintinline{c++}|protected|. Оно для похожих случаев и было создано, лол. Это модификатор доступа, дающий доступ только дочерним классам и себе. С ним есть вопрос, как идейно с ним жить. Если метод не ломает инвариант, почему он не \mintinline{c++}|public|, а если ломает, то хотим ли мы давать доступ дочерним классам. Тем не менее, эти вопросы не риторические, если вы нашли на них ответ~--- делайте \mintinline{c++}|protected|.
    \paragraph{Best practices.}
    Давайте дополним наш пример с виджетами. Вот есть у нас виджет, который знает, как его красить. И это виртуальная функция. Мы наследуется, меняем функцию, всё хорошо. Но есть второй вариант~--- создать отдельный класс, который отвечает за покраску, наследовать только его, и передавать этот объект в конструктор виджета. Это может быть очень полезно, если мы хотим, например, одинаково красить разные классы в разных местах. Более того, мы можем собирать наш виджет из кусочков. В QT, например, используется оба подхода. Реакция на мышку, на клавиатуру, перекраска и некоторые другие штуки обычно очень сильно связаны с самим классом, а какая-нибудь стилизация~--- уже что-то внешнее.\\
    Надо лишь понимать, что комбинируя кусочки, можно зайти так далеко, что вы будете складывать $2+2$, получая двойки из какого-то \mintinline{c++}|data_provider|'а, складывая каким-нибудь классом \mintinline{c++}|adder| и подобное. Не надо плодить фабрики непонятных классов. Когда вы делаете точку настройки, вы делаете ставку на то, что будете менять. Тут надо сильно думать. Более того, если вы сделали какие-то точки настройки, а расширять надо в другую сторону, то ваши точки настройки будут вам во вред, потому что вам надо будет их с новыми согласовывать.\\
    Мораль: когда вы делайте фабрики/точки настройки/всё остальное, думайте, для чего вы это делаете.
    \subparagraph{Квадрат и прямоугольник.}
    Посмотрите лекцию по Java. Посмотрели? Класс. Теперь посмотрим, как с этим жить. У нас есть квадрат и прямоугольник. Вопрос в том, кого из их откуда наследовать. Ответ на этот вопрос нельзя дать без вопроса, какие операции нам нужны. Например, вот так:
    \begin{figure}[H]
        \begin{tabular}{|c|c|c|}
            \hline
            Квадрат & Прямоугольник & Оба\\
            \hline
            \Verb|get_side| & \Verb|set_width| & \Verb|get_width|\\
            & \Verb|set_height| & \Verb|get_height|\\
            && \Verb|set_side|\\
            \hline
        \end{tabular}
    \end{figure}
    Тогда ни один из классов нельзя наследовать от другого (согласно принципу подстановки Лисков). Но если у нас внезапно пропадают \Verb|set_*|, то у прямоугольника нет специфичных методов, а значит можно отнаследовать квадрат от него. А ещё вопрос в том, зачем вам наследование, правда ли вы хотите полиморфно использовать один как другой?
    \paragraph{Виртуальное наследование.}
    \begin{minted}{c++}
        struct A
        {
            int x;
        };
        struct B : A {};
        struct C : A {};
        struct D : B, C {};

        int main()
        {
            D d;
            d.x = 7; // Не работает, x is ambiguous.
            d.B::x = 7; // Работает.
            d.C::x = 7; // Работает.
        }
    \end{minted}
    Если две копии \mintinline{c++}|x|~--- это то, что вы хотите, то хорошо. А иначе есть виртуальное наследование:
    \begin{minted}{c++}
        struct A
        {
            int x;
        };
        struct B : virtual A {};
        struct C : virtual A {};
        struct D : B, C {};
        
        int main()
        {
            D d;
            d.x = 7; // Работает.
        }
    \end{minted}
    По сути у вас в \mintinline{c++}|D| есть только один подобъект типа \mintinline{c++}|A|, а не два, в отличие от предыдущего случая. Хорошо, а что будет, если то же самое сделать с функцией?
    \begin{minted}{c++}
        struct A
        {
            void foo();
        };
        struct B : A {};
        struct C : A {};
        struct D : B, C {};
    \end{minted}
    Ведь функция-то всего одна, какая ей разница. Но ведь в эту функцию вы передаёте \mintinline{c++}|this|, и какой \mintinline{c++}|this| её передавать, зависит от того, какой подобъект \mintinline{c++}|A| вы хотите передать. Так что с функциями это работает точно также.\\
    А как это сочетается с виртуальными функциями?
    \begin{minted}{c++}
        struct A
        {
            virtual void foo() = 0;
        };
        struct B : A
        {
            void foo() override {}
        };
        struct C : A {};
        struct D : B, C {};
        
        int main()
        {
            D d;
        }
    \end{minted}
    Это даже в таком случае не компилируется, потому что \mintinline{c++}|D| считается абстрактным классом, у него есть абстрактный подкласс \mintinline{c++}|C| с абстрактным подклассом \mintinline{c++}|A|. Понятно, что если мы сделаем так:
    \begin{minted}{c++}
        struct A
        {
            virtual void foo() = 0;
        };
        struct B : A
        {
            void foo() override {}
        };
        struct C : A
        {
            void foo() override {}
        };
        struct D : B, C {};
        
        int main()
        {
            D d;
        }
    \end{minted}
    То класс создать мы вполне сможем (но не сможем вызвать \mintinline{c++}|foo|). А с виртуальным наследованием это взаимодействует так:
    \begin{minted}{c++}
        struct A
        {
            virtual void foo() = 0;
        };
        struct B : virtual A
        {
            void foo() override {}
        };
        struct C : virtual A {};
        struct D : B, C {};
    \end{minted}
    Это корректно. Потому что у вас есть только одна виртуальная функция \mintinline{c++}|foo|, и вы её отнаследовали.
    \begin{minted}{c++}
        struct A
        {
            virtual void foo() = 0;
        };
        struct B : virtual A
        {
            void foo() override {}
        };
        struct C : virtual A
        {
            void foo() override {}
        };
        struct D : B, C {};
    \end{minted}
    А это некорректно, потому что в классе \mintinline{c++}|D| непонятно, что за \mintinline{c++}|foo|. Разве что вы переопределите её и там. И это, кстати, работает вообще с любыми функцими и данными одного имени, не только с виртуальными функциями. То есть вот так тоже можно:
    \begin{minted}{c++}
        struct A
        {
            int x;
        };
        struct B : virtual A
        {
            int x;
        };
        struct C : virtual A {};
        struct D : B, C {};
    \end{minted}
    Тут у вас действительно две переменных \mintinline{c++}|x|, но в \mintinline{c++}|D| по-умолчанию берётся \mintinline{c++}|B::x|.
    \paragraph{Модификаторы доступа наследования.}
    Как и у полей, можно указывать такие штуки как\\\mintinline{c++}|class A : public B|. Причём в случае приватного наследования, вы не только поля из \mintinline{c++}|B| не будете видеть в \mintinline{c++}|A|, у вас даже \mintinline{c++}|static_cast| не сработает. То есть наследование с модификаторами доступа~--- то, кто знает об этом наследовании.
    \paragraph{Применения предыдущих двух параграфов.}
    Где это может пригодится? Ну, например, вы имеете какой-то публичный базовый класс (например, \mintinline{c++}|widget_painter|), и вы создаёте несколько похожих его наследников. А потом видите, что наследники похожи, их можно обобщить, и получить какую-то такую иерархию:
    \begin{minted}{c++}
        struct widget_painter
        {
            virtual void paint() {/* ... */}
        };

        // ...

        struct my_base_painter : widget_painter
        {
            void paint() override {/* ... */}
        };
        struct my_painter1 : my_base_painter
        {};
        struct my_painter2 : my_base_painter
        {};
    \end{minted}
    Но мы не хотим, чтобы кто-то приводил наши классы \mintinline{c++}|my_painter| к \mintinline{c++}|my_base_painter|, это деталь реализации. Поэтому хочется написать \mintinline{c++}|struct my_painter1 : private my_base_painter|. Но это не сработает, потому что тогда никто снаружи и наследование от \mintinline{c++}|widget_painter| видеть не будет. Поэтому вот как надо:
    \begin{minted}{c++}
        struct my_base_painter : virtual widget_painter
        {
            void paint() override {/* ... */}
        };
        struct my_painter1 : private my_base_painter, virtual widget_painter
        {};
        struct my_painter2 : private my_base_painter, virtual widget_painter
        {};
    \end{minted}
    Ещё хороший пример~--- если мы хотим реализовывать интерфейсы по чуть-чуть. У нас есть виртуальная база, которая умеет, там, рендериться, изменяться, что-то ещё делать, и мы её часть в одном классе, часть~--- в другом. Тогда для сборки этих штук в одну придётся использовать виртуальное наследование:
    \begin{minted}{c++}
        struct game_object
        {
            virtual void render() = 0;
            virtual void update() = 0;
        };

        struct billbord_object : virtual game_object
        {
            void render() override {/* ... */};
        };

        struct static_object : virtual game_object
        {
            void update() override {/* ... */};
        };

        struct static_billboard : billbord_object, static_object
        {};
    \end{minted}
    Мораль: не надо бояться и пренебрегать виртуальным наследованием.
    \paragraph{Виртуальное наследование from the inside.}
    Во что бы мы оттранслировали виртуальное наследование? Давайте вместо того, чтобы внутри объекта \mintinline{c++}|B| хранить объект \mintinline{c++}|A|, хранить указатель на него. Но если у нас много виртуальных баз, то хочется табличку. А табличку нельзя, у всех объектов типа \mintinline{c++}|D| они свои. Давайте хранить не указатель, а смещение до нужной виртуальной базы. И тогда в каждом объекте всё одинаковое, а значит можно объединить в табличку~--- табличку виртуальных баз.
    \begin{figure}[H]
        \begin{tikzpicture}[scale=2/3]
            \draw[fill=white] (-.1,-1) rectangle (10.6,1.25);
            \node at (5.15,-1.5) {\Verb|D|};
            \draw[fill=white] (0,0) rectangle (4,1);
            \node at (2,-.5) {\Verb|B|};
            \draw[fill=white] (4.5,0) rectangle (8.5,1);
            \node at (6.5,-.5) {\Verb|C|};
            \draw[fill=white,step=.4,shift={(.1,.1)}] (0,.4) grid (2,.8);
            \draw[fill=white,step=.4,shift={(4.6,.1)}] (0,.4) grid (2,.8);
            \draw[fill=white] (11.1,-1) rectangle (13.1,1.25) node[midway] (tmp) {\Verb|A1|} node[coordinate] (A0) at (0,1.25 -| tmp) {};
            \draw[fill=white] (13.6,-1) rectangle (15.6,1.25) node[midway] (tmp) {\Verb|A2|} node[coordinate] (A1) at (0,1.25 -| tmp) {};
            \draw[fill=white] (16.1,-1) rectangle (18.1,1.25) node[midway] (tmp) {\Verb|A3|} node[coordinate] (A2) at (0,1.25 -| tmp) {};
            \draw[fill=white] (18.6,-1) rectangle (20.6,1.25) node[midway] (tmp) {\Verb|A4|} node[coordinate] (A3) at (0,1.25 -| tmp) {};
            \draw[fill=white] (21.1,-1) rectangle (23.1,1.25) node[midway] (tmp) {\Verb|A5|} node[coordinate] (A4) at (0,1.25 -| tmp) {};
            \newcounter{tmp}
            \setcounter{tmp}{0}
            \foreach\c in {blue,darkgreen,red,violet,yellow}
            {
                \pgfmathparse{\value{tmp}}
                \pgfmathsetmacro\i\pgfmathresult
                \draw[\c,->] (.3+\i*.4,.7) -- ++(0,1+\i*.5) -| (A\i);
                \draw[\c] (4.8+\i*.4,.7) -- ++(0,1+\i*.5);
                \addtocounter{tmp}{1}
            }
        \end{tikzpicture}
    \end{figure}\deletecounter{tmp}\noindent
    А теперь пример:
    \begin{minted}{c++}
        struct base {};
        struct derived : virtual base {};

        derived& test(base& b)
        {
            return static_cast<derived&>(b);
        }
    \end{minted}
    Так вот это не компилируется, потому что мы совершенно не шарим, откуда в объекте \mintinline{c++}|b| взять смещение, которое хранится в \mintinline{c++}|derived|. Но зато можно так:
    \begin{minted}{c++}
        struct base {
            virtual ~base() {}
        };
        struct derived : virtual base {};

        derived& test(base& b)
        {
            return dynamic_cast<derived&>(b);
        }
    \end{minted}
    Это, как ни странно, компилируется, потому что вы можете взять RTTI из \mintinline{c++}|b|, и всё. Более того, с \mintinline{c++}|dynamic_cast| есть ещё б\'{о}льший мем:
    \begin{minted}{c++}
        struct A
        {
            virtual void foo() {}
        };
        struct B {};
        B& test(A& a)
        {
            return dynamic_cast<B&>(a);
        }
    \end{minted}
    Как ни странно, это компилируется, более того, даже может быть корректно, если вы создадите класс \mintinline{c++}|C| и отнаследуете его и от \mintinline{c++}|A|, и от \mintinline{c++}|B|.
    \paragraph{Наследование и исключения.}
    На самом деле вы можете кинуть наследуемый тип, а поймать базовый (по ссылке, разумеется). Даже если в них нет RTTI. Как это работает~--- хз. Нужно понимать, что \mintinline{c++}|catch| работает тогда, когда можно однозначно определить подобъект. В частности такой код:
    \begin{minted}{c++}
        struct A {};
        struct B : A {};
        struct C : A {};
        struct D : B, C {};

        int main()
        {
            try
            {
                throw D();
            }
            catch (A const&)
            {}
        }
    \end{minted}
    не поймает исключение, пока \mintinline{c++}|B| и \mintinline{c++}|C| отнаследованы не виртуально.
    \paragraph{Наследование и \texttt{using}.}
    Давайте вот на какой пример посмотрим:
    \begin{minted}{c++}
        struct base
        {
            void foo(int) {}
        };
        struct derived : base
        {
            void foo(float) {}
        };
        int main()
        {
            derived d;
            d.foo(42);
        }
    \end{minted}
    Тут у вас вызовется \mintinline{c++}|foo(float)|, потому что он найдёт его раньше. А если мы хотим, чтобы у нас честно было 2 перегрузки, делаем так:
    \begin{minted}{c++}
        struct base
        {
            void foo(int) {}
        };
        struct derived : base
        {
            void foo(float) {}
            using base::foo;
        };
    \end{minted}
    То же самое работает, если у вас множественное наследование:
    \begin{minted}{c++}
        struct base1
        {
            void foo(int) {}
        };
        struct base2
        {
            void foo(float) {}
        };
        struct derived : base1, base2
        {};
        int main()
        {
            derived d;
            d.foo(42); // Ambiguous.
        }
    \end{minted}
    Если вы хотите не ambiguous, придётся сделать два \mintinline{c++}|using|'а.\\
    Также \mintinline{c++}|using|'и можно применять к конструкторам, чтобы указанная база конструировалась мы знаем как, а всё остальное~--- по-умолчанию.
    \paragraph{Наследование и ADL.}
    В argument-dependent lookup входят также все, от кого вы наследуетесь.
\end{document}