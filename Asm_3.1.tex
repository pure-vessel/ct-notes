\documentclass{article}
\input{Headers/header}
\input{Headers/formal}

\usepackage[outputdir=Output, cachedir=mintedcache]{minted}

\begin{document}
    \tableofcontents
    \section{Intro.}
    Напоминание: ассемблер~--- такой язык, который сильно отличается от остальных тем, что полностью зависит от процессора. Ассемблер~--- набор мнемоник для процессора. А значит ассемблеров столько же, сколько и ISA.\\
    На нашем курсе будет изучаться x86. Помимо него можно встретить ARM (хотя это семейство ISA, они не совместимы друг с другом), MIPS (старое, встречается в роутерах и первых двух PlayStation, из роутеров замещается т.к. мертво), Power (старые маки). А ещё есть новая ISA: RISC-V. Она очень хорошо если захватит мир (т.к. это открытая ISA), но пока нет. Сейчас она очень быстро захватывает контроллеры. Например, контроллеры винчестера. Раньше там были ARM'ы. С ARM сейчас все активно убегают, потому что они отозвали лицензию Huawei, и все остальные боятся, что у них тоже отзовут. Кроме Apple, которые участвовали в создании ARM. Но это точно не всё. Потому что есть видеокарты, которые вполне можно считать специализированными устройствами со своими ISA. В линейке новых видеокарт AMD публикуют документацию к их ассемблеру. И ровно также существует тьма специализированных популярных ISA, но мы их касаться не будем.\\
    При этом важно следующее. ISA и ассемблер сопоставляются друг другу почти один к одному. Одно только: в x86 есть два \textbf{синтаксиса} ассемблера: Intel и AT\&T+GNU. Первый \mintinline{nasm}|ADD RAX, RBX|~--- прибавление \mintinline{nasm}|RBX| к \mintinline{nasm}|RAX| и запись в \mintinline{nasm}|RAX|. GNU же выглядит как-то так: \mintinline{nasm}|ADDL %RBX, %RAX|. То есть у команды уточнена битность (зачем-то), поменяны аргументы местами и стоят проценты. Мы будем использовать первый, а наш ассемблер (как программа) будет nasm.
    \section{История x86.}
    x86 странноват по историческим причинам. Сначала был 16-битный процессор i8086. К тогда мелкой кампании Intel пришла корпорация IBM и заказала процессоры. i8086 был середнячком того времени. Он уже был обременён совместимостью с 8-битным i8080. Intel позиционировала это как временную меру, но то крутое, что она хотела сделать, так и не состоялось. Что интересно про i8086~--- 20-битная адресация. Как это делать с 16-битными регистрами? Сложно сказать.\\
    В итоге i8086 попал в очень популярную линейку компов IBM, где был MS-DOS. Короче, i8086 просто повезло. Потом Intel выпустила i8088~--- более дешёвую версию, у которого была 8-битная шина, поэтому он работал медленнее. За i8086 вышли его настоящие последователи: i80186, i80286, i80386, i80486... Всё это обратно совместимо баг в баг. Отсюда и название x86.\\
    Совместимость была лютейшая, и вот промер: команда, которая считает синус, имела баг. При числе $x$ в районе $\pi$ его синус равен примерно $x-\pi$. Значит надо вставить точную константу $\pi$. Но оказалось, что константа недостаточно точная. Это поправили AMD, пользователи подняли крик, и они вернули старую неточную константу. Впрочем, практически это никого не напрягает, потому что там точность~--- относительное понятие (потому что совсем точно знать ответ бесполезно, потому что \mintinline{c}|double| уже скорее всего округлён). Или другой пример: до сих пор современные x86 запускается в начале именно в режиме i8086.\\
    В i80286 добавили защищённый режим, в i80386~--- 32-битный режим. В i80486 не скажу, что было, а потом был Pentium (архитектура P5), который стал первым суперскалярным процессором (что, конечно, на ISA не повлияло). Из интересного, Pentium сейчас используется для разных экспериментов. Например, когда они показывали процессор на солнечной батарее, это был именно Pentium. Дальше был Pentium MMX, в котором добавили первое расширение на SIMD~--- single instruction multiple data. Предназначено для обработки мультимедиа (например, там есть встроенное сложение с насыщением), или любых других больших массивов данных. Отсюда и название, MultiMedia Extension. Параллельно с этим был Pentium Pro (архитектура P6) (out-of-order superscalar, в отличие от Pentium, который in-order superscalar), но он дорогой, а значит непопулярный.
    \paragraph{Немного офф-топ о том, кто использует ассемблер.}
    SIMD (и в целом модные расширения, в которые компилятор не очень умеет)~--- одна из основных причин писать на ассемблере, потому что писать что-то целиком на ассемблере бессмыслено~--- хороший компилятор вам сильно поможет. Другие причины:
    \begin{itemize}
        \item Сделать что-то, что умеет ОС, и что не умеет ваш язык.
        \item Системы защиты, вирусы и антивирусы. Код там, кстати, похожий, лол. Более того, они иногда лезут в машинный код, кодогенерацию на лету, более того код может даже полиморфным получаться. (Так Denuvo работает.)
        \item Низкоуровневые оптимизации. Если вы компилятор пишете, например. Если вы пишете код с арифметикой с насыщением. Вопрос: догадается ли компилятор, что вам надо использовать инструкцию? Можно напрямую писать на ассемблере, если вы переписываете какую-нибудь функцию, которая занимает существенное время.\\
        Что интересно, вы обычно пишете несколько ассемблерных вставок под одно и то же. Почему? Потому что ISA разные.\\
        Обычно речь идёт именно про SIMD. Не только потому, что его сложно заметить в высокоуровневом коде, но ещё и потому, что обычно SIMD происходит в числах с пониженной точностью. А значит ваш язык может просто не уметь выражать то, что вы хотите.
        \item Отладка программ. А вы думали иначе? Если есть исходники, то всё круто. Если нет, со знанием ассемблера вы всё равно можете. В т.ч. когда происходят баги компилятора.
    \end{itemize}
    \paragraph{Продолжаем историю.}
    Pentium MMX был первым процессором, на котором можно было смотреть видео 320\texttimes 240 30 кадров в секунду в MPEG-I без аппаратных ускорителей. После него появился Pentium 2 (который позиционировался как помесь Pentium MMX и Pentium Pro; это правда, но процессор подешевле, конечно, чем Pro) и Pentium 3. Там появился SSE~--- своеобразный SIMD для вещественных чисел. Потом произошла неудача с Pentium 4 и SSE2 (и SSE3). Если до этого микроархитектура была одинаковой и работающей, то Pentium 4 с новой микроархитектурой дико грелся (по тем временам) и выдавал низкую скорость (из-за извращённой архитектуры) несмотря на адские мегагерцы.\\
    Почему нет 64-битного режима? Потому что во время Pentium 4 Intel хотели выпустить Intel Itanium, свой, новый и с лицензией только у себя. Но он по многим причинам был окрещён Intel Itanic и утонул. В итоге Intel поддержали AMD-шное расширение на 64 бита. Спойлер: оно называется amd64.\\
    Параллельно был Pentium M~--- развитие Pentium 3 с оптимизацией в энергопотребление. Это для ноутбуков. Когда стало ясно, что Pentium 4~--- это провал, инженеры взяли Pentium M и сделали из него Core 2, в котором добавили расширение SSSE3. Это расширение уже про целые числа, и довольно полезные. В полее поздних ревизиях было SSE 4.1. Core 2 был хорош.\\
    Дальше была линейка i7 с микроархитектурой Nehalem (из которых уже потом были урезанные i5), и там добавили SSE4.2. Дальше серия ix-2xxx и микроархитектура Sendy Bridge, где добавили AVX., потом i7-4xxx (микроархитектура Haswell), где появился AVX2~--- расширили регистры SIMD до 256 бит. А ещё там FMA~--- возможность сделать \mintinline{c}|d = a * b + c| с толко одним округлением в конце. Она хороша, но считается и за сложение, и за умножение, потому что увеличивает вдвое FLOPS. Потом была серия ix-6xxx (в этот момент начинают расходится цифры для десктопов и всего остального), так что будем смотреть по микроархитектуре (тут Skylake). Тут было AVX512, но было оно только у серверного Skylake. Обещали, что добавят в десктопы, когда будет новый техпроцесс (10 нм). Спойлер: нового техпроцесса не произошло.\\
    Отсюда и до 10xxx происходит Skylake.\\
    Что дальше? Серия 11xxx (Cypress Cove), которая быстро умерла, в которой они добавили AVX512. Но тут им дали пинка AMD, потому что они начали отгружать ядра подешёвке (и по деньгам, и по энергии). А Intel так не могли, в энергию не лезет. Поэтому в серии 12xxx надо было откуда-то кучу ядер. Поэтому туда добавили слабые ядра. Откуда их взяли? Из Atom~--- попытки Intel зайти на мобильный рынок (но провалились). Короче теперь в 12xxx (Golden Cove~--- сильные ядра + Gracemont~--- слабые ядра) и 13xxx с 14xxx (Raptor Cove + Gracemont) сериях крутые ядра поставляются вместе с пачкой убогих, которые не умеют AVX512. Поэтому Intel решили не поставлять AVX512 туда, где есть слабые ядра. Из интересного, когда 12xxx только выходили, люди научились в BIOS-е выключать убогие ядра и включать AVX512. Больше так нельзя, Intel теперь аппаратно отключают AVX512.
    \paragraph{AMD.}
    Ни одна компания не хочет завязываться на другую компанию. Поэтому когда IBM пришли к Intel, они поставили одно условие: они дадут одну лицензию компании AMD. Есть ещё одна лицензия, но она переходила по рукам, выпускала банкоматы под виндой, а сейчас её просто держат в подвале и не используют. Из интересного компания, которая имела третью лицензию, сделала себе аппаратное перепрограммирование команды, которая говорит, кто производитель процессора. Зачем им прикидываться Intel'ом или AMD? Потому что они обнаружили, что винда не грузится. А в винде было написано, что если Intel, делаем одно, если AMD~--- другое, а иначе нечто нерабочее. При помощи этого ещё тестировали Intel-компилятор, чтобы доказать, что он не использует расширения (даже если может) на процессорах AMD.\\
    i8086 просто склонировали, а дальше, AMD выпускали то же самое (с названиями Am286, Am386, Am486 и Am5x86), но нестандартными расширениями. Потом был K5, K6 (Pentium 2), K6-2 (в который добавили MMX), и K6-3, в котором появилось расширение 3DNow! (теперь можно считать 2 \mintinline{c}|float| на MMX; Intel её естественно не поддержали, а вместо этого скрафтили SSE, в котором можно считать 4 \mintinline{c}|float|'а). Во время Pentium 3 появился Atlon (3DNow! Pro).\\
    Дальше был Atlon XP, в котором наконец-то появился SSE. Дальше неинтересно до тех пор, пока не появился Atlon64 (времена Pentium 4). И он был сильно круче, чем Pentium, несмотря на низкую частоту. Да ещё и в Atlon64 был 64-битный режим (и SSE2). Зачем 64 бита? Потому что адресное пространство очень маленькое. А значит что? Что все (особенно любители серверов) покупают Atlon64. Вместо уходящего в закат и сомнительного Pentium 4 и откровенно отстойного Intel Itanium.\\
    После этого был какой-то непопулярный кал (Phenom и линейка с названиями строительной техники), а сейчас ядро Zen (линейка Ryzen), в которым убрали всякий мусор (типа 3DNow!) и сделали сразу AVX2. Из интересного~--- Zen 4, который поддерживает AVX512. Ядра поменьше там тоже есть, но не в обычных процессорах, а в мобильных, причём следующего поколения. Ещё есть Zen 4c: <<c>>~--- более плотная паковка деталек Zen 4 + порезанная максимальная частота и порезанный L3 вдвое. За счёт этого туда запихали побольше ядер на кристалл. А потом начали мешать обычные и <<c>>, что сильно круче, чем происходящее у Intel. Дальше Zen 5, которых 3 вида: обычные, <<c>> и мобильные, и мобильные порезаны.
    \section{Займёмся делом.}
    Как закончить программу? Одной командой: \mintinline{nasm}|ret|. Одна проблема: надо объяснить, что с этого надо начинать. Проще всего жить по правилам C и сказать, что это конец функции \mintinline{nasm}|main|. Можно иначе, но так проще и логичнее. И вот программа
    \begin{minted}{nasm}
    main:
        ret
    \end{minted}
    Разве что под Windows лучше написать \mintinline{nasm}|_main| (64бит такого прикола не имеет). Это уже почти работает: надо только сказать, что \mintinline{nasm}|main| должно быть видно снаружи:
    \begin{minted}{nasm}
        global main
    main:
        ret
    \end{minted}
    Возможно, потребуется сказать
    \begin{minted}{nasm}
        global main
        section .text
    main:
        ret
    \end{minted}
    Если хочется код возврата дать, то так:
    \begin{minted}{nasm}
        global main
        section .text
    main:
        mov eax, 0
        ret
    \end{minted}
    Уже хорошо. Теперь возьмём nasm и попросим его скомпилировать это. Правда, надо ему указать, под какую систему компилировать. Например, \mintinline{console}|-f win32| под Windows. У вас появится объектный файл, который можно скормить линковщику (gcc, например).\\
    \subsection{Регистры.}\label{par:registers}
    Первое: x86~--- reg-mem-2 архитектура. И дальше мы будем говорить про регистры, про которые мы что-то можем знать. Т.е. регистры общего назначения. Они вот такие:
    \begin{itemize}
        \item \mintinline{nasm}|ax|~--- аккумулятор.
        \item \mintinline{nasm}|cx|~--- счётчик.
        \item \mintinline{nasm}|dx|~--- данные + расширение аккумулятора.
        \item \mintinline{nasm}|bx|~--- базовый.
        \item \mintinline{nasm}|bp|~--- немного по-другому базовый.
        \item \mintinline{nasm}|sp|~--- указатель в стек.
        \item \mintinline{nasm}|si|~--- source.
        \item \mintinline{nasm}|di|~--- destination.
    \end{itemize}
    При этом начиная с 32 битов эта специализация ослабла, но не исчезла. Всё описанное тут~--- 16-битное. Причём для обратной совместимости с 8-битным i8080 к регистрам \Verb|*x| можно обратиться не полностью, а по половинкам: \Verb|*l|~--- младшая, \Verb|*h|~--- старшая. При этом при изменении частей другая часть не меняется. Когда началось 32-битное расширение, все регистры расширили до 32 бит, написав \Verb|e| в начале имени регистра. Теперь, например, \mintinline{nasm}|ax|~--- младшие 16 бит \mintinline{nasm}|eax|. Потом добавили 64-битные версии, да ещё и новых регистров добавили, но о них не сейчас.\\
    Кроме этого и совсем системных существуют два интересных: flags (eflags, rflags) и ip (eip, rip). Что такое флаги? Когда вы делаете действие, помимо нормального результата устанавливают флажки. Они представлены битами регистра FLAGS. Например: сложение может переполниться и тогда он установит CF~--- carry flag. Есть, например, ZF~--- её ставят, например, сложение и вычитание, если в результате ноль. Из ещё полезного SF~--- sign flag~--- равен старшему биту результата, а значит что он показывает знак результата. Сильно позднее нам будет интересен DF, а сейчас обсуждать его не будем.\\
    А ip~--- instruction pointer. Хранит адрес следующей исполняемой инструкции. Ни к флагам, ни к ip нельзя обратиться напрямую, но некоторые команды могут с ними взаимодействовать.
    \subsection{Адресация.}
    Когда в качестве аргумента какой-то команды хочется использовать штуку, которая находится по адресу какому-то, вокруг адреса ставятся квадратные скобки. Что можно использовать в качестве адреса? В разных режимах разное. В 16-битном: сумма произвольного подмножества из: базы (регистра \mintinline{nasm}|bx| или \mintinline{nasm}|bp|), индекса (\mintinline{nasm}|di| или \mintinline{nasm}|si|) и сдвига~--- 16-битной константы. В 32-битном: (любой регистр) + (любой регистр, кроме \mintinline{nasm}|esp|) * (число из 1, 2, 4, 8) + (32-битная константа). Опять же, любая часть опускается. В некоторых ассемблерах можно менять штуки местами, в большинстве умножение на 1 можно опустить, а ещё некоторые понимают \mintinline{nasm}|[eax * 5]|. Как? Это равносильно \mintinline{nasm}|[eax + eax * 4]|. Про 64-битную адресацию не расскажем.
    \subsection{Инструкции.}
    \paragraph{Присваивания.}
    Никто из инструкций этого параграфа не меняет флаги.
    \subparagraph{mov и его друзья.}
    Присваивание.
    \begin{itemize}
        \item В нормальном синтаксисе \mintinline{nasm}|mov dst, src| присваивает \mintinline{nasm}|src| в \mintinline{nasm}|dst|. Один любой из аргументов может быть памятью. Например, \mintinline{nasm}|mov eax, [ebx]|. Хм-м, сколько данных тут будет присвоено? 4 байта т.к. \mintinline{nasm}|eax| имеет 32 бита. Поэтому из памяти, адресом которой является \mintinline{nasm}|ebx| читается 4 байта и пишется в \mintinline{nasm}|eax|. Каким образом? Берётся \mintinline{nasm}|ebx| и ещё следующие 3 байта, и читаются. В x86 раньше в памяти идут младшие байты числа. Это называется little-endian. В других системах может быть строго наоборот, тогда это называется big-endian. В упоротых системах может быть смесь. В сетевых протоколах, к сожалению, выбран big-endian.\\
        Кстати, на последнем месте может быть константа. Но это может привести к неясности. \mintinline{nasm}|mov [eax], 123|~--- это присваивание какой битности? Так команда (в нормальных ассемблерах, таких как nasm) некорректна, поэтому нужно уточнить: \mintinline{nasm}|mov byte [eax], 5| или \mintinline{nasm}|mov [eax], byte 5|. Принято первое. Получается, что один байт. Можно также написать \mintinline{nasm}|word|, \mintinline{nasm}|dword|, \mintinline{nasm}|qword| для 16, 32 и 64 бит соотвественно. Ещё перед памятью может \mintinline{nasm}|ptr| стоять, но это не nasm, а masm или её такой кринж.
        \item Ещё есть \mintinline{nasm}|movsx| и \mintinline{nasm}|movzx|~--- копируют меньшее в большее следующим образом: меньшая часть копируется, остаток заполняется нулём для \mintinline{nasm}|movzx| либо знаковым битом для \mintinline{nasm}|movsx|. Best practices: если нужно присвоить байт в большой регистр, применение этих команд намного лучше чем \mintinline{nasm}|xor| с самим собой + \mintinline{nasm}|mov| байта. Это потому, что присваивание регистров размера равного битности системы осуществляется быстрее.
        \item Ещё есть \mintinline{nasm}|cmov|\textsubscript{\Verb|cc|}. Они, имеют чуть меньше вариантов откуда и куда загружать. Например, нельзя на второй аргумент написать константу. А прикол их в том, что они загружают значение при определённом условии. Например, \mintinline{nasm}|cmovz|~--- присваивает, если стоит ZF и \mintinline{nasm}|cmovnz|~--- если не стоит. Помимо таких простых штук есть ещё комбинации, которые позволяют сравнивать числа. Как сравнивать числа? По сути, вычитанием. Если аргументы равны, будет \Verb|ZF|, если первое меньше второго в беззнаковом типе, то это \Verb|CF|. А если в знакомом, то \Verb|OF|. И можно скомбинировать их в, например, \mintinline{nasm}|cmovbe|~--- меньше либо равно (комбинация c || z).\\
        Но у этого семейства команд есть беды. Во-первых, \mintinline{nasm}|cmov| умеет присваивать только регистры (т.е. не работает ни с памятью, ни с константами). Во-вторых, она не умеет в 8-битные регистры.
    \end{itemize}
    \subparagraph{xchg.}
    Обмен без дополнительной памяти. \textbf{Атомарный} swap. Если вы хотите поменять значения двух регистров, то вы делаете что-то странное, но ладно. Но если вы делаете \mintinline{nasm}|xchg| с памятью, то она работает невероятно долго (из-за атомарности).
    \subparagraph{bswap и movbe.}
    \mintinline{nasm}|bswap|: Берёт 32-битный (в 64-битном режиме можно и 64-битный) регистр, меняет endianness на противоположный (т.е. меняет байтики местами). \mintinline{nasm}|movbe|: \mintinline{nasm}|mov|, но с попутным изменением endianness. \mintinline{nasm}|movbe|~--- относительно новая команда, а следовательно может не быть, и код может не оптимизироваться компилятором без указания процессора в коде.
    \subparagraph{lea.}
    Имеет два аргумента: регистр и память. Она считает адрес памяти, НЕ ОБРАЩАЕТСЯ В ПАМЯТЬ и просто присваивает адрес в регистр. Типичное применение~--- трёхаргументное сложение, но насколько оно эффективнее~--- вопрос.
    \subparagraph{cwd и друзья.}\label{subpar:cwd}
    \mintinline{nasm}|cwd|~--- берёт старший бит \mintinline{nasm}|ax| и заполняем им \mintinline{nasm}|dx|. \mintinline{nasm}|cdq|, \mintinline{nasm}|cdo| делают то же самое, но с парами \mintinline{nasm}|eax|:\mintinline{nasm}|edx| и \mintinline{nasm}|rax|:\mintinline{nasm}|rdx|.\\
    Ещё есть \mintinline{nasm}|cwde|, \mintinline{nasm}|cbw| и \mintinline{nasm}|cdqe|~--- соотвественно расширяют знаковым битом \mintinline{nasm}|al| до \mintinline{nasm}|ax|, \mintinline{nasm}|ax| до \mintinline{nasm}|eax| и \mintinline{nasm}|eax| до \mintinline{nasm}|rax|. Зачем~--- поймёте потом.
    \paragraph{Арифметика.}
    Важное замечание: в языках мы привыкли что типы имеют знаковость, а операции~--- нет. Тут ровно наоборот: регистры и память~--- это просто биты. А арифметика интерпретирует их как число (знаковое или беззнаковое), и совершает операцию.
    \subparagraph{Сложение и вычитание.}
    \mintinline{nasm}|add| и \mintinline{nasm}|sub|. Делают соотвественно += и -=, в синтаксисе как \mintinline{nasm}|mov|. Попутно ставят флаги. Также есть \mintinline{nasm}|adc|~--- складывает два числа и прибавляет к ним CF в качестве единички~--- и \mintinline{nasm}|sbb|~--- вычитание, и вычесть флаг переноса.
    \subparagraph{Умножение.}
    Беззнаковое~--- \mintinline{nasm}|mul|, знаковое~--- \mintinline{nasm}|imul|. Принимает один аргумент (регистр или память, не константу) и умножает его на \mintinline{nasm}|ax| (или аналог аналогичной битности). Результат имеет битность вдвое больше. Куда присваивается результат~--- чуть сложнее:
    \begin{itemize}
        \item \mintinline{nasm}|ax| = \mintinline{nasm}|al| * arg8.
        \item \mintinline{nasm}|dx:ax| = \mintinline{nasm}|ax| * arg16.
        \item \mintinline{nasm}|edx:eax| = \mintinline{nasm}|eax| * arg32.
        \item \mintinline{nasm}|rdx:rax| = \mintinline{nasm}|rax| * arg64.
    \end{itemize}
    Что за непонятное двоеточие? Возьмём два регистра, склеим из них одно число побольше, где первый регистр~--- старшая часть.\\
    А ещё есть \mintinline{nasm}|imul reg, reg|~--- делает *=, отбрасывает старшую часть. Почему нет такого же для беззнаковых? А потому что верно следующее утверждение: младшая половина результата получается одинаковой для знакового и беззнакового умножения.\\
    А ещё есть \mintinline{nasm}|imul reg, reg, const|~--- умножает второе на третье, присваивает в первое. Опять же, знаковость на самом деле не важна.
    \subparagraph{Деление.}
    Есть \mintinline{nasm}|div| и \mintinline{nasm}|idiv|, и в их классической форме они похожи на правила для умножения. Например, он берёт пару \mintinline{nasm}|edx:eax| и делит на аргумент (всё ещё регистр или память). Частное записывается в \mintinline{nasm}|eax|. Что более интересно, он также считает остаток и присваивает в \mintinline{nasm}|edx|. Для 16 битов и 64 битов понятно, для 8~--- остаток присваивается в \mintinline{nasm}|ah|.\\
    Деление на ноль? Это определено как исключительная ситуация, и дальше происходит ситуация, похожая на \hyperref[subpar:int]{прерывание}: система останавливает выполнение, переходит в ядро к обработчику ОС и начинает делать какой-то другой код. Но это ладно. Мы делим 64-битное число на 32-битное. Оно легко может не влезть в 32-битное. И это тоже считается делением на ноль. Единственный способ заработать это на C~--- знаково поделить \mintinline{c}|INT_MIN| на \mintinline{c}|-1|.\\
    Что делать, если мы хотим делить друг на друга числа одинакового размера? Ну, если числа беззнаковые, то старшую часть надо обнулить. Если знаковые, то заполнить знаковым битом, и тут мы вспоминаем \hyperref[subpar:cwd]{\mintinline{nasm}|cwd| и друзей}.
    \subparagraph{Инкремент и декремент.}
    \mintinline{nasm}|inc| и \mintinline{nasm}|dec|. Делают почти всё как надо, но не меняют флаг переноса. Если вы используете этот факт, они сильно замедляются. Что в них хорошего~--- занимают меньше памяти, а чем меньше памяти, тем больше команд влезет в кэш.
    \subparagraph{neg.}
    Меняет знак числа на противоположный. Флаги ставит ровно как <<инвертировать все биты, добавить один>>.
    \paragraph{Логика.}
    \mintinline{nasm}|and|, \mintinline{nasm}|or|, \mintinline{nasm}|xor|. Побитовые логические операции. И \mintinline{nasm}|not|~--- побитовое отрицание.
    \subparagraph{xor для обнуления.}
    Традиционно для обнуления регистра принято использовать \mintinline{nasm}|xor| его самого с собой. Эта инструкция занимает меньше памяти, и более того распознаётся процессорами как некоторая идиома, и если вы сделали, например \mintinline{nasm}|xor eax, eax|, то дальше если вы используете \mintinline{nasm}|eax|, то его использование не приостанавливает Superscalar.
    \subparagraph{cmp и test.}
    \mintinline{nasm}|cmp|~--- делает то же самое, что \mintinline{nasm}|sub|, но не пишет результат, пишет только флаги. \mintinline{nasm}|test|~--- то же самое, но \mintinline{nasm}|and|, а не \mintinline{nasm}|sub|. Первое используется для сравнений на больше или меньше, второе~--- для установленных битов и сравнения с нулём т.к. \mintinline{nasm}|cmp| чего-то и нуля занимает много места (т.к. надо записать 32-битную константу 0).
    \subparagraph{Сдвиги.}
    \mintinline{nasm}|shr|, \mintinline{nasm}|shl|, \mintinline{nasm}|sar|, \mintinline{nasm}|sal|.\\
    Это всё логические или арифметические сдвиги. Сдвиги принимают два аргумента: что двигать и насколько. Сдвиг вправо двигает битики на несколько позиций в сторону меньших битов. Самый последний сдвинутый бит перемещается в CF. Но тут лучше документацию читать. Логический сдвиг заполняет освободившиеся позиции нулями (а значит полностью аналогичен делению на слепень двойки). Арифметический сдвиг заполняет их знаковым битом, что почти аналогично делению. Разница в том, что арифметический сдвиг округляет к $-\infty$. Сдвиги влево одинаковы и сдвигают в другую сторону. В CF пишется младший сдвинутый бит.\\
    Тут есть проблема с аргументами. Первым аргументом может являться только регистр или память, а вторым~--- константа или \mintinline{nasm}|cl|. Причём из него берутся только младшие биты в необходимом для этого количестве. Например, при сдвиге 32-битных чисел берутся только 5 бит.\\
    А ещё есть сдвиги двойной точности: \mintinline{nasm}|shld| и \mintinline{nasm}|shrd|. Принимают на вход два регистра и число (либо CL вместо числа), двигает первый регистр в нужную сторону, но пустые места заполняются частью второго аргумента. То есть для сдвига вправо пустые места заполняются младшими битами второго регистра. Для сдвига влево~--- заполняются старшими битами второго регистра. CF заполняется так же, как и для обычных сдвигов.\\
    И наконец \mintinline{nasm}|rol| и \mintinline{nasm}|ror|~--- циклический сдвиг битов в одну из сторон. Последний выдвинутый бит всё ещё отправляется во флаг переноса. Ещё в ту же степь есть \mintinline{nasm}|rcr| и \mintinline{nasm}|rcl|. Возьмём параметр, приклеим к нему CF, сделаем циклический, сука, сдвиг полученного числа, битности на 1 больше, чем аргумент.
    \paragraph{Работа со стеком.}
    У вас есть стек, он растёт вниз по адресному пространству. И вы можете класть туда значения и брать их оттуда.
    \subparagraph{push/pop.}
    Пушить на стек можно регистры, память, константы. Это по сути сдвиг \mintinline{nasm}|esp| выше по стеку на размер аргумента (то есть вычитание) + запись туда. \mintinline{nasm}|pop| принимает один аргумент (регистр или память), куда записать то, что сняли со стека. Если записывать никуда не надо, то что? Ну, можно просто прибавить значение к \mintinline{nasm}|esp|.\\
    Совет: очень хорошо для производительности, если все штуки на стеке выровнены кратно режиму программы.\\
    Ещё интересное: вы не можете класть на стек (и убирать со стека) 8-битные значения.
    \subparagraph{pusha(d)/popa(d).}
    Здесь и далее круглые скобки означают, что это дополнительный суффикс. Т.е. тут две пары команд: \mintinline{nasm}|pusha|, \mintinline{nasm}|pushad| и \mintinline{nasm}|popa|, \mintinline{nasm}|popad|.\\
    \mintinline{nasm}|pusha| пишет на стек все регистры (в порядке, указанном \hyperref[par:registers]{выше}). При этом в зависимости от ассемблера, на стек пишутся либо все регистры текущей битности, либо все 16-битные регистры. С суффиксом \Verb|d| гарантированно кладёт 32-битные регистры. Ещё некоторые ассемблеры понимают \mintinline{nasm}|pushaw|~--- точно положить 16-битные регистры. \mintinline{nasm}|popa| читает все регистры и восстанавливает все, кроме \mintinline{nasm}|sp|.
    \paragraph{Передача управления.}
    Самый простой~--- \mintinline{nasm}|jmp|~--- переход по метке, регистру или значению в памяти. На практике всё это пересчитывается в смещение относительно текущей команды.
    \subparagraph{Условные переходы.}
    \Verb|j|\textsubscript{\Verb|cc|}, где \Verb|cc|~--- то, что мы видели выше в разделе с \mintinline{nasm}|cmov|. Применимо только к меткам, если хочется по регистру или памяти, делайте абсолютный переход и обходите его условным переходом.
    \subparagraph{Вызовы функций.}
    \mintinline{nasm}|call| и \mintinline{nasm}|ret|. \mintinline{nasm}|call|~--- принимает на вход метку, регистр или адрес, записывает на стек адрес следующей команды и делает \mintinline{nasm}|jmp| по своему параметру.\\
    \mintinline{nasm}|ret|~--- снимает со стека значение и переходит по нему.\\
    \mintinline{nasm}|ret n|~--- снимает со стека адрес, увеличивает \mintinline{nasm}|esp| на \Verb|n|, переходит по тому, что в первый раз снял.
    \subparagraph{Прерывания.}\label{subpar:int}
    Прерывания предназначены для взаимодействия с внешними устройствами. Пример: пользователь нажимает на клавиатуру, а мы узнаём, что он там нажал. Можно периодически спрашивать клавиатуру, что там нажато, но это плохо из-за  того, что если вы часто спрашиваете, это активное ожидание (значит долго), а если редко, то мы пропустим, как пользователь нажал и отпустил. Это Polling называется. Поэтому используем прерывание: устройство посылает прерывание. Процессору похрен на клавиатуру до тех пор, пока ему не придёт прерывание. Тогда процесс перейдёт на обработчик прерываний (его устанавливает ОС). Тут уже клавиатура опрашивается, данные сохраняются, и вы продолжаете исполняться как ни в чём не бывало. Но тут нужна аппаратная поддержка: PS/2 работает через прерывание, а USB клавиатура работает через Polling. Ещё из интересного: PS/2 работает тупо и всегда. А USB может перестать работать из-за проблем с дровами.\\
    Так вот \mintinline{nasm}|int|~--- переходит на обработчик прерываний. Принимает на вход константу от 0 до 255. По сути программная эмуляция настоящих прерываний. Пример: \mintinline{nasm}|int 80h| зовёт ядро (на Linux). Ещё есть парная команда~--- \mintinline{nasm}|iret| т.к. прерывание сохраняет на стек побольше, чем функция (а именно адрес возврата, флаги, иногда стек). Впрочем, программные прерывания~--- не рекомендуемый способ позвать привелегированный режим, потому что это прерывания~--- это долго и неэнергоэффективно.\\
    У \mintinline{nasm}|int| есть несколько специальных форм, например \mintinline{nasm}|int3|~--- отладочное прерывание. Если у вас нет отладчика, вы умираете, если есть, то он её перехватит и начнёт делать что-то своё. Из прикольного у \mintinline{nasm}|int3| однобайтовый код \mintinline{c}|0xCC|, а у обычных прерываний код двухбайтовый.
    \paragraph{Вызовы ядра.}
    \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysexit|. Первое~--- джамп в ядро, второй~--- из ядра. Куда конкретно ядро? Есть машинно-специфичные регистры (MSR), и там есть в частности адрес, куда \mintinline{nasm}|sysenter| переходит.\\
    В отличие от \mintinline{nasm}|int| эти команды не сохраняют значение на стек. Поэтому прямое использование этих команд затруднено. Обычно ОС Вам делает \mintinline{nasm}|call| по адресу, в котором находятся \mintinline{nasm}|sysenter| и \mintinline{nasm}|ret|. И ОС делает так, чтобы возвращаться на этот \mintinline{nasm}|ret|. Но это всё равно быстрее прерываний.\\
    \mintinline{nasm}|syscall| и \mintinline{nasm}|sysret|. То же самое, что и \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysret|, но сохраняет адрес возврата на стек. Проблема в том, что это придумали AMD, поэтому в 32-битном режиме этих команд может не быть. Но это не всё. Ведь 64-битный режим придумали AMD, и они объявили, что в 64-битном режиме \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysexit| не поддерживаются. Intel, естественно, их поддерживает, но по умолчанию в 64-битном режиме все делают \mintinline{nasm}|syscall|.\\
    Из интересного в Windows вам дают системную библиотеку, в которую вы делаете \mintinline{nasm}|call|, и она сама там разбирается, как трогать ядро. И вам не надо думать, какие у вас поддерживаются прерывания, вызывать ли вам \mintinline{nasm}|sysenter| или \mintinline{nasm}|syscall|. Хотите не иметь проблем~--- залезьте в системную библиотеку.
    \paragraph{nop.}
    Делает ничего. Формально эквивалентен \mintinline{nasm}|xchg eax, eax|. А ещё есть многобайтовые версии \mintinline{nasm}|nop|. Применяется, чтобы начало короткого цикла выравнять по границе кэш-линии.
    \paragraph{ud2.}
    Команда, которой не существует. Исполняя её, гарантированно упадёт с ошибкой <<команда некорректна>>.
    \section{Calling conventions.}
    Calling convention~--- договоренность о том, как передаются параметры в функцию, куда помещается возвращаемое значение, где сохраняется адрес возврата (именно то, что отличает \mintinline{nasm}|call| от \mintinline{nasm}|jmp|), какие регистры функция обязана вернуть в исходное состояние.\\
    Если вы хотите указать прямо около функции, какого соглашения она должна придерживаться (например, \Verb|cdecl|), в clang и MSVC это делается примерно так: \mintinline{c}|void __cdecl foobar();|, а в gcc~--- при помощи: \mintinline{c}|__attrubite((cdecl))__|.\\
    Ниже будет краткое описание происходящего в 32-битных системах. Если вам этого мало, вот \href{https://www.agner.org/optimize/calling_conventions.pdf}{очень крутая ссылка}:
    \paragraph{cdecl}
    C-шная библиотека использует конвенцию \Verb|cdecl|, которую сейчас и опишем: адрес возврата сохраняется на стеке, аргументы кладутся на стек тем ниже, чем раньше аргумент. То есть сначала кладётся последний аргумент, потом предпоследний, и так далее, а после первого кладётся адрес возврата.\\
    Например, в функции вида \mintinline{c}|int f(int a, int b, int c)|. Тогда для вызова надо сделать так:
    \begin{minted}{nasm}
        push c
        push b
        push a
        call f
        add esp, 12
    \end{minted}
    С возвращаемым значением есть беда. Если оно влезает в регистр, его положат в соответствующую часть аккумулятора соответствующей битности. То есть если вы вернули \mintinline{cpp}|bool| или \mintinline{cpp}|char|, вам запишут результат в \mintinline{nasm}|al| (а в остальной части \mintinline{nasm}|eax| будет мусор). Если результат 16-битный~--- вернут в \mintinline{nasm}|ax|, если 32-битный~--- \mintinline{cpp}|eax|, а если 64-битный (в 32-битном режиме)~--- \mintinline{nasm}|edx:eax|. Что если больше? Тогда функция внезапно преобразовывается: нулевым её аргументом начинает идти адрес того, куда положить возвращаемое значение. Её выделяет вызывающий, потому что вызываемая функция почистить её не сможет (т.к. закончится). А выделять и освобождать в разных функциях... Не, ну, можно, конечно, если в соглашении о вызовах постулировать, как именно она выделяется, но у нас могут быть разные аллокаторы, например... Поэтому нет, кто освободил, тот и чистит.\\
    Также конвенция вызовов заставляет вас сохранять некоторые регистры (а именно \mintinline{nasm}|ebx|, \mintinline{nasm}|ebp|, \mintinline{nasm}|esi| и \mintinline{nasm}|edi|), поэтому если вы хотите испортить их значение, положите их на стек в начале функции, а потом снимите обратно. Ещё функция с соглашением \Verb|cdecl| должна гарантировать, что \mintinline{nasm}|esp| останется как был до вызова (т.е. аргументы со стека снимать нельзя; но можно их менять, там уже всем будет похрен).\\
    Из интересного если класть на стек аргумент меньше 32-х бит, он всё равно дополнится до 32-х бит. Если аргумент 64-х битный, пушится 64 бита в порядке little-endian, то есть младшие биты в младших адресах (или младшие биты раньше на стеке).
    \subparagraph{Mangling}
    Если вы хотите вызывать функцию из C++, у вас большие проблемы, потому что, как мы помним из курса C++, там у функций могут быть одинаковые имена и разные наборы аргументов, поэтому просто по имени функцию не найти. И тут у вас есть два варианта: либо повесить на функцию модификатор \mintinline{cpp}|extern "C"|, что заставит её называться ровно по имени, либо узнать, как она называется на самом деле, и использовать это имя. Например, вот так под gcc 14.2 выглядит \mintinline{cpp}|std::vector<int>::push_back(const int&)|: \Verb|_ZNSt6vectorIiSaIiEE9push_backERKi|. А вот так под MSVC 19.40: \Verb|?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z|. Мораль проста: если вы пишете библиотеку, наружу лучше вытаскивать функции с \mintinline{cpp}|extern "C"|, чтобы быть кроссплатформенным.\\
    Из интересного: декорирование имён существует не только в C++, но и в C под 32-битной Windows, где вместо \Verb|main| у вас \Verb|_main|, вместо \Verb|printf|~--- \Verb|_printf| и т.п.
    \paragraph{Пример с Hello world}
    Как положить в память строчку символов? В nasm вот так:
    \begin{minted}{nasm}
        format: db "abc", 0xa, 0
    \end{minted}
    Инструкция \mintinline{nasm}|db| кладёт в память указанный набор байт (по адресу текущей инструкции). Конкретно в данном случае в память кладётся \mintinline{c}|"abc\n"| (с 0-терминатором, чтобы \mintinline{c}|printf| смог её вывести). И устанавливается метка \mintinline{nasm}|format:|, которая указывает на данную строку.\\
    В каком месте лучше всего написать \mintinline{nasm}|db|? Ну, эту строчку мы менять не собираемся, и для неизменяемых данных как раз есть специальная секция \mintinline{nasm}|section .rdata|.\\
    Так, что ещё. Если мы просто сделаем \mintinline{nasm}|call printf|, нам скажут, что не нашли \mintinline{c}|printf|, поэтому надо его объявить командой \mintinline{nasm}|extern printf|:
    \begin{minted}{nasm}
        section .text
        global main
        extern printf
        main:
        push 123
        push format
        call printf
        pop eax ; Можно просто двигать стек,
        pop eax ; если вы знаете, куда его двигать
        xor eax, eax
        ret
        
        section .rdata
        format:
        db "%i", 0xa, 0
    \end{minted}
    Примечание: этот код не будет работать под 32-битной Windows, даже если заменить \Verb|printf| на \Verb|_printf| (об этом было выше). Дело в том, что с некоторым шансом вам подсунут стандартную библиотеку, в которой \mintinline{c}|printf| определён как \mintinline{c}|inline|-функция прямо в \Verb|stdio.h|, и поэтому ни в одной статической библиотеке его не найти.
    \paragraph{stdcall}
    Эта конвенция очень похожа на \Verb|cdecl| и отличается только одним: функция сама чистит стек от параметров. Например, функция \mintinline{c}|int f(int a, int b)| заканчивается командой \mintinline{nasm}|ret 8| (напоминание: это значит, что после чтения адреса возврата со стека и прыжком по нему надо увеличить \mintinline{nasm}|esp| на 8). Это немного упрощает ваш код, но такая конвенция не позволяет делать функции с переменным количеством аргументов (ведь функция тупо не знает их количество).
    \paragraph{pascal}
    По сути \Verb|stdcall|, у которого аргументы поменяли местами.\\
    Никому нахрен не нужен. Как минимум потому, что он говно (если у тебя не vararg, то зачем тебе чистить стек самому, а если vararg, то ты фиг ты найдёшь, где там первый аргумент). А ещё потому, что Pascal мёртв, а тот, что не мёртв (Pascal ABC.Net)~--- это на самом деле .NET.\\
    В 16-битном мире ещё хоть как-то использовался, а сейчас больше нет.
    \paragraph{thiscall, методы}
    Похоже на \Verb|stdcall|, но это специальная конвенция по умолчанию (в майкросовтовских компиляторах) для методов. Так вот \mintinline{cpp}|this| передаётся в \mintinline{nasm}|ecx|.\\
    Вопрос: а как методы класса работают, если им указать другую конвенцию? Ну, \mintinline{cpp}|this| добавляется нулевым аргументом. Но тут новая проблема: а если мы решили создать метод класса, который возвращает большой объект? Кто раньше будет \mintinline{cpp}|this|, а кто возвращаемое значение? А не договорились, разные компиляторы делают это по-разному. Отсюда вы вообще не хотите, чтобы методы классов возвращали что-то большое. Если на DirectX посмотреть, то там нигде никакой метод не возвращает то, что не поместится в аккумулятор.\\
    Из ещё более грустного, вообще не всё равно в каком порядке эти аргументы положить. Намного лучше класть сначала возврат, потом \mintinline{cpp}|this|, потому что тогда вы сможете трактовать эту функцию как нормальную функцию из C (объявив ей первый аргумент явно). А возвращаемое значение как было норм, так и остаётся. Microsoft сделали хреново, все остальные~--- нормально.
    \paragraph{fastcall}
    Тут не договорились ни о чём вообще. Какие-то аргументы передаются через регистры в каком-то порядке, сколько и как~--- никто не знает. Не вытаскивайте это за пределы одного компилятора.
    \paragraph{Как правильно писать if.}
    Вот у нас в if есть что-то типа \mintinline{c}|eax > 5|. Чтобы сформулировать, как писать условие на ассемблере, надо сначала понять, как мы сравниваем: знаково или беззнаково. если это сравнение беззнаковое, нам надо использовать прыжки с \Verb|a| и \Verb|b|. Иначе~--- \Verb|l| и \Verb|r|. При этом если в if несколько условий, то написание \mintinline{c}|if|'а на ассемблере отличается в зависимости от того, как связаны условия.\\
    Например:
    \begin{minted}{c}
        if (eax > 5 && ebx) {
            // then-branch
        }
    \end{minted}
    трансформируется в
    \begin{minted}{nasm}
        cmp eax, 5
        jbe .lend
        test ebx ebx ; так традиционно сравнивать с нулём само число
        jnz .lend
        then-branch
    .lend:
    \end{minted}
    Заметим, что тут хорошо работает правило из C про ленивое исполнение. Это важно. Алгоритм может зависеть от факта, что второе условие не выполнят, если не надо.\\
    Другой пример:
    \begin{minted}{c}
        if (eax > 5 || ebx) {
            // then-branch
        }
    \end{minted}
    трансформируется в
    \begin{minted}{nasm}
        cmp eax, 5
        ja .lthen
        test ebx ebx
        jnz .lend
    .lthen
        then-branch
    .lend:
    \end{minted}
    Что делать, если есть else? Да всё просто, переходы на \mintinline{nasm}|.lend| заменить на переходы в \mintinline{c}|else|, а после конца \mintinline{c}|if| сделать безусловный переход на метку после окончания if'а.\\
    Вы не хотите разрывать проверку от условного перехода. Например, потому, что современные процессоры умеют в macro-fusion. Обычно одна внешняя команда превращается в одну или несколько микроопераций, в зависимости от наличия железа для выполнения команды как одной. Например, \mintinline{nasm}|add eax, [ecx]| свободно может превратиться в две команды: чтение памяти и сложение. Из интересного, эти действия могут происходить в разное время. Так вот macro-fusion~--- это фича, которая позволяет превращать несколько команд в одну. В x86 такое типично может быть для сравнения + перехода.\\
    Мы уже говорили про то, что порядок условных переходов иногда критичен для алгоритма. Но если нет, этим можно пользоваться. Если есть условный переход, который легко предсказывается, и который позволяет обойти остальные, то его имеет смысл вставлять в начало, если можно.\\
    И ещё best practice. Пусть мы хотим сравнить \mintinline{c}|if (x >= 3 && x < 7)|, где \mintinline{c}|x| беззнаковый. Это отлично можно сделать за один переход.
    \begin{minted}{nasm}
        mov ecx, x
        sub ecx, 3
        cmp ecx, 4
        jae ecx .lend
        ; then-branch
    .lend
    \end{minted}
    Но тут вопрос в том, насколько хорошо это предсказывается. Если значения расположены случайно, один переход лучше, чем два. Более того, такой же прикол в C работает.\\
    Что ещё интереснее, то же работает для знаковых типов. На ассемблерах буквально, а в C придётся написать пару букв: \Verb|if (x - 3u < 4u)|.
    \paragraph{Как писать циклы.}
    \begin{itemize}
        \item Начнём с цикла \mintinline{c}|do { /* X */ } while (eax < 5u);|. Как выглядит на ассемблере? Ну, очевидно:
        \begin{minted}{nasm}
        .loop:
            ; X
            cmp eax, 5
            jb .loop
        \end{minted}
        \item Теперь \mintinline{c}||while (eax < 5u) { /* X */ }|. Окей:
        \begin{minted}{nasm}
            cmp eax, 5
            jnb .lend
        .loop:
            ; X
            cmp eax, 5
            jb .loop
        .lend
        \end{minted}
        То есть компилятор превращает while в do-while с условием в начале. Более того, если компилятор умеет доказывать, что цикл while исполняется хотя бы раз, он может это убрать.
        \item И, наконец, цикл for. \mintinline{c}|for (eax = 0; eax < ebx; eax++) { /* X */ }|. От while он отличается ничем по сути, и его можно переписать так:
        \begin{minted}{c}
            eax = 0;
            if (eax < ebx) {
                do {
                    // X
                    eax++;
                } while (eax < ebx);
            }
        \end{minted}
        Конкретно в данном случае if можно убрать.\\
        Но это ладно. Немногие знают, что лучше работают циклы в обратном порядке (от числа до нуля). Почему? Потому что \mintinline{nasm}|dec| отлично проставляет ZF (но не CF, это важно). Более того, macro-fusion отлично работает для комбинаций \mintinline{nasm}|dec| + \mintinline{nasm}|jz| и \mintinline{nasm}|dec| + \mintinline{nasm}|jnz| (и прочих условных переходов, если они не используют CF). И также работает сложение и вычитание с переходами. Более того, компиляторы умеют переворачивать циклы:
        \begin{minted}{nasm}
            mov eax, ebx
        .L1
            X
            dec eax
            jnz .L1
        \end{minted}
        Но эта штука идёт от 5 до 1, а не от 4 до 0. Надо починить. Ну, всё просто
        \begin{minted}{nasm}
            lea eax, [ebx - 1]
        .L1
            X
            sub eax, 1
            jnc .L1
        \end{minted}
        Это правильный вариант. Но есть ещё более крутой, если \mintinline{nasm}|eax| не очень большой.
        \begin{minted}{nasm}
            lea eax, [ebx - 1]
        .L1
            X
            dec eax
            jns .L1
        \end{minted}
        Но это ладно. Что если мы хотим двигаться вперёд? Можно двигаться вперёд к нулю. Типа такого:
        \begin{minted}{c}
            for (eax = -ebx; eax < 0; eax++) { /* X */ }
        \end{minted}
        Тут надо пошаманить с \Verb|X|, но если мы там к массиву хотим обратиться, то всё вообще круто. Например, \Verb|X := ecx[eax]++|, где \Verb|ecx|~--- массив dword'ов.. Тогда делаем так:
        \begin{minted}{nasm}
            lea ecx, [ecx + ebx * 4]
            mov eax, ebx
            neg eax
        .L1
            inc dword [ecx + eax * 4]
            inc eax
            jnz .L1
        \end{minted}
        \textbf{Важное примечание}: везде вышенаписанный код опирается на то, что хотя бы раз условие цикла выполнится. Иначе сверху надо бахнуть ещё одно сравнение.
    \end{itemize}
    \paragraph{Как писать switch.}
    Для начала: аргументом switch может быть только целое число. Веткой case~--- только константа времени компиляции. В честь чего? В честь того, что только так это можно скомпилировать лучше, чем в кучу if'ов. Возьмём такой switch:
    \begin{minted}{c}
        switch (eax) {
        case 1:
        case 2:
            // X
            break;
        case 3:
            // Y
        case 5:
            // Z
        }
    \end{minted}
    Так вот, это отлично компилируется в такое:
    \begin{minted}{nasm}
    section .text
        cmp eax, 5
        ja .lend
        jmp [table + eax * 4]
    .L1:
        ; X
        jmp .lend
    .L2:
        ; Y
    .L3:
        ; Z
    .lend:

    section .rdata
    .table: dd .lend, .L1, .L1, .L2, .lend, .L3
    \end{minted}
    Короче, тут безусловный переход по табличке. Если значения разнородные (типа 1, 2, 4 и 100000), компилятор их распилит. А если они совсем рандомные, то будет куча if'ов. Возможно, с двоичным поиском.
    \section{Немного про оптимизации.}
    Самое главное, определить проблему.
    \paragraph{Время.}
    За время отвечает команда \mintinline{nasm}|rdtsc| и её вариации. Например, \mintinline{nasm}|rdtscp|. Обе пишут в \mintinline{nasm}|edx:eax| время с момента reset в тактах. Вторая портит \mintinline{nasm}|ecx|, но её менее вольно можно переставлять в Superscalar'е. При этом кратность может быть больше одного такта. А ещё команда достаточно тяжёлая (около 100 тактов). Вообще зная тактовую частоту, можно пересчитать в секунды. А после того, как процессоры научились разгоняться, незадолго после этого таймер \mintinline{nasm}|rdtsc| отвязали от таймера процессора. А частота этого таймера примерно равна базовой частоте процессора. И да. Точность любых других способов очень мала. Тут точность~--- сотни тактов. В том, что даёт операционная система, точность~--- миллисекунды.\\
    Как с этим жить? Да на самом деле не очень хорошо. Если Вы измеряете скорость кода и всё, то ладно. Но если вам нужно понять, почем
    у, надо ставить профилировщик. Причём лучше всего, чтобы профилировщик был от того производителя, что и процессор. Правда, у AMD профайлер не очень. Но зато там есть норм такое API доступа ко всяким встроенным счётчикам, которые могут помочь. А ещё можно стабилизировать частоту процессора, но довольно сложно. На Windows такое может aida64 (как профилировщик она не очень, но там можно попросить выключить турбо). На Linux нужно как-то добраться до MSR и найти, какой флаг отвечает за турбо. Правда, стабилизация частоты, вероятно, сильно снизит скорость работы. Зато \mintinline{nasm}|rdtsc| будет более стабильным.
    \paragraph{Ещё важное.}
    Чтобы что-то оптимизировать, надо ещё понимать, насколько быстро работают команды. Например, это можно сделать \href{https://uops.info/table.html}{тут}. Тут надо знать, что есть две скорости: latency и throughput. Первая~--- количество тактов от начала вычисления до получения результата. Вторая~--- сколько команд в единицу времени может исполнять процессор. Концептуально, первое о последовательности зависимых команд, второе~--- об одновременном количестве исполняемых команд.
    \section{FPU.}
    Оно же имеет название x87. Это модуль работы с плавающей точкой. Изначально это был отдельный набор команд и отдельные микросхемы, которые назывались так же, как и процессор, но с семёркой на конце. Такая топология, что FPU вычисляется на сопроцессоре, повлияла на сущность этих команд.
    \subsection{Регистры.}
    Служебные мы тут обсуждать не будем. Только общего назначения. Они называются \mintinline{nasm}|R0|, \mintinline{nasm}|R1| и т.д. до \mintinline{nasm}|R7|, но в таком виде их не применяют. А всё потому, что эти регистры организованы в виде стека. \mintinline{nasm}|R0| снизу, \mintinline{nasm}|R7| сверху. А указатель стека находится в определённом месте и называется \mintinline{nasm}|ST0|. Если мы делаем \mintinline{nasm}|push|, то \mintinline{nasm}|ST0| сдвигается вниз.\\
    И это всё ладно. Но самое плохое, что ячейки помечены как занятые или свободные. И попытка прочитать не занятую или записать в занятую производит NaN.\\
    Все регистры~--- 80-битные. И в формате extended-precision они хранят число. При этом FPU умеют автоматически конвертировать типы данных. Они поддерживают целые числа \textbf{со знаком} (16, 32 и 64 бита), плавающую точку в форматах single, double и extended (кажется, обозначение \Verb|tbyte|) и BCD80. BCD80~--- это про десятичные цифры в байтиках. Каждые 4 бита хранят десятичную цифру, и байтов 10.
    \subsection{Инструкции пересылки.}
    \paragraph{FLD, FILD, FBLD.}
    Загрузка на стек. Имеют один аргумент (адрес в памяти). \mintinline{nasm}|FLD| ещё умеет в \Verb|ST(i)|. А отличаются они тем, что \mintinline{nasm}|FLD| оперирует числами с плавающей точкой, \mintinline{nasm}|FILD|~--- целыми числами, \mintinline{nasm}|FBLD|~--- BCD80.\\
    Плюс есть \mintinline{nasm}|FLDZ|, \mintinline{nasm}|FLD1| и \mintinline{nasm}|FLDPI|, которые загружают константы (0, 1 и $\pi$ соотвественно). Есть ещё несколько, но это можно загуглить.
    \paragraph{FST(P), FIST(P), FBST(P).}
    Если без \Verb|P|~--- взять значение из \mintinline{nasm}|ST0| и поставить в память или в указанное место на стеке. Если с \Verb|P|, то записать и после этого освободить ячейку и увеличить указатель стека (если делать версию с \Verb|P| и в качестве аргумента дать стек, запись будет по старым адресам).
    \paragraph{FXCH.}
    Меняет местами вершину стека и ещё одно значение стека. Она, как и \mintinline{nasm}|mov|, выполняется за 0 тактов.
    \paragraph{FCMOV\textsubscript{cc}.}
    Условная загрузка. Использует флаги процессора.
    \subsection{Инструкции арифметики.}
    Всегда: один аргумент~--- вершина стека. Другой~--- стек или память. Если команда обращается к памяти, то память~--- второй аргумент. При этом вершина стека может быть любым аргументом, но по умолчанию он первый.
    \paragraph{FADD, FADDP, FIADD.}
    \mintinline{nasm}|FADD|~--- складывет и присваивает в первый аргумент. \mintinline{nasm}|FADDP|~--- складывает и делает pop со стека. \mintinline{nasm}|FIADD|~--- складывает \mintinline{nasm}|ST0| и целочисленную константу из памяти.
    \paragraph{FSUB, FSUBP, FISUB; FSUBR, FSUBRP, FISUBR.}
    Обычное вычитание берёт первый аргумент, вычитает второй и присваивает в первый. Обратное вычитание берёт второй аргумент, вычитает первый и присваивает в первый.
    \paragraph{FMUL, FMULP, FIMUL.}
    Понятно.
    \paragraph{FDIV, FDIVP, FIDIV; FDIVR, FDIVRP, FIDIVR.}
    Тоже понятно.
    \paragraph{FPREM(1).}
    Вычитает \mintinline{nasm}|ST1| из \mintinline{nasm}|ST0| не более чем 64 раза до тех пор, пока модуль разности не будет меньше модуля \mintinline{nasm}|ST1|. Версия с единичкой отличается округлением.
    \paragraph{FABS.}
    Присваивает в \mintinline{nasm}|ST0| его модуль.
    \paragraph{FCHS.}
    Меняет знак \mintinline{nasm}|ST0|.
    \paragraph{FRNDINT.}
    Округляет к ближайшему чётному.
    \paragraph{FSQRT.}
    Берёт квадратный корень.
    \paragraph{FSIN.}
    Берёт синус.
    \paragraph{FCOS.}
    Берёт косинус.
    \paragraph{FSINCOS.}
    Берёт синус и косинус (берёт значение со стека, кладёт, кажется, сначала синус, потом косинус).
    \paragraph{FPTAN.}
    Берёт тангенс.
    \paragraph{FPATAN.}
    Считает \mintinline{c}|atan2|. То есть арктангенс \Verb|ST1 / ST0|. Снимает со стека обоих.
    \paragraph{FCOMI(P).}
    Сравнивает \mintinline{nasm}|ST0| с \Verb|ST(i)| и ставит флаги \Verb|ZF|, \Verb|PF|, \Verb|CF|. При этом делает он сравнение как будто беззнаковое. Вариация с P снимает значение со стека.
    \paragraph{FINCSTP, FDECSTP.}
    Двигает указатель стека на единичку. Не меняет занятость.
    \paragraph{FFREE.}
    Пометить \Verb|ST(i)| как свободную ячейку.
    \paragraph{FNOP.}
    Делает ничего. Но не совсем. Он умеет бросить возникшее, но ещё не брошенное исключение. Да, IEEE-754 умеет в исключения. И железо это умеет, но надо включить это через служебные регистры. А вообще если исключение происходит, происходит системное прерывание (и гипотетически его можно обработать).
    \subsection{Конвенции вызовов (32 bit).}
    Аргументы single и double лежат на стеке как число соответствующей битности. С extended сложнее. Возвращаемое значение лежит на вершине стека сопроцессора. При вызове функции стек сопроцессора должен быть чист, при возврате, если возвращаемого значения нет, то стек должен быть чист, если есть, то чист кроме \mintinline{nasm}|ST0|, где лежит результат.
\end{document}