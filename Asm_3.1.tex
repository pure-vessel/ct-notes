\documentclass{article}
\input{Headers/header}
\input{Headers/formal}

\usepackage[outputdir=Output, cachedir=mintedcache]{minted}

\begin{document}
    \tableofcontents
    \section{Intro.}
    Напоминание: ассемблер~--- такой язык, который сильно отличается от остальных тем, что полностью зависит от процессора. Ассемблер~--- набор мнемоник для процессора. А значит ассемблеров столько же, сколько и ISA.\\
    На нашем курсе будет изучаться x86. Помимо него можно встретить ARM (хотя это семейство ISA, они не совместимы друг с другом), MIPS (старое, встречается в роутерах и первых двух PlayStation, из роутеров замещается т.к. мертво), Power (старые маки). А ещё есть новая ISA: RISC-V. Она очень хорошо если захватит мир (т.к. это открытая ISA), но пока нет. Сейчас она очень быстро захватывает контроллеры. Например, контроллеры винчестера. Раньше там были ARM'ы. С ARM сейчас все активно убегают, потому что они отозвали лицензию Huawei, и все остальные боятся, что у них тоже отзовут. Кроме Apple, которые участвовали в создании ARM. Но это точно не всё. Потому что есть видеокарты, которые вполне можно считать специализированными устройствами со своими ISA. В линейке новых видеокарт AMD публикуют документацию к их ассемблеру. И ровно также существует тьма специализированных популярных ISA, но мы их касаться не будем.\\
    При этом важно следующее. ISA и ассемблер сопоставляются друг другу почти один к одному. Одно только: в x86 есть два \textbf{синтаксиса} ассемблера: Intel и AT\&T+GNU. Первый \mintinline{nasm}|ADD RAX, RBX|~--- прибавление \mintinline{nasm}|RBX| к \mintinline{nasm}|RAX| и запись в \mintinline{nasm}|RAX|. GNU же выглядит как-то так: \mintinline{nasm}|ADDL %RBX, %RAX|. То есть у команды уточнена битность (зачем-то), поменяны аргументы местами и стоят проценты. Мы будем использовать первый, а наш ассемблер (как программа) будет nasm.
    \section{История x86.}
    x86 странноват по историческим причинам. Сначала был 16-битный процессор i8086. К тогда мелкой кампании Intel пришла корпорация IBM и заказала процессоры. i8086 был середнячком того времени. Он уже был обременён совместимостью с 8-битным i8080. Intel позиционировала это как временную меру, но то крутое, что она хотела сделать, так и не состоялось. Что интересно про i8086~--- 20-битная адресация. Как это делать с 16-битными регистрами? Сложно сказать.\\
    В итоге i8086 попал в очень популярную линейку компов IBM, где был MS-DOS. Короче, i8086 просто повезло. Потом Intel выпустила i8088~--- более дешёвую версию, у которого была 8-битная шина, поэтому он работал медленнее. За i8086 вышли его настоящие последователи: i80186, i80286, i80386, i80486... Всё это обратно совместимо баг в баг. Отсюда и название x86.\\
    Совместимость была лютейшая, и вот промер: команда, которая считает синус, имела баг. При числе $x$ в районе $\pi$ его синус равен примерно $x-\pi$. Значит надо вставить точную константу $\pi$. Но оказалось, что константа недостаточно точная. Это поправили AMD, пользователи подняли крик, и они вернули старую неточную константу. Впрочем, практически это никого не напрягает, потому что там точность~--- относительное понятие (потому что совсем точно знать ответ бесполезно, потому что \mintinline{c}|double| уже скорее всего округлён). Или другой пример: до сих пор современные x86 запускается в начале именно в режиме i8086.\\
    В i80286 добавили защищённый режим, в i80386~--- 32-битный режим. В i80486 не скажу, что было, а потом был Pentium (архитектура P5), который стал первым суперскалярным процессором (что, конечно, на ISA не повлияло). Из интересного, Pentium сейчас используется для разных экспериментов. Например, когда они показывали процессор на солнечной батарее, это был именно Pentium. Дальше был Pentium MMX, в котором добавили первое расширение на SIMD~--- single instruction multiple data. Предназначено для обработки мультимедиа (например, там есть встроенное сложение с насыщением), или любых других больших массивов данных. Отсюда и название, MultiMedia Extension. Параллельно с этим был Pentium Pro (архитектура P6) (out-of-order superscalar, в отличие от Pentium, который in-order superscalar), но он дорогой, а значит непопулярный.
    \paragraph{Немного офф-топ о том, кто использует ассемблер.}
    SIMD (и в целом модные расширения, в которые компилятор не очень умеет)~--- одна из основных причин писать на ассемблере, потому что писать что-то целиком на ассемблере бессмыслено~--- хороший компилятор вам сильно поможет. Другие причины:
    \begin{itemize}
        \item Сделать что-то, что умеет ОС, и что не умеет ваш язык.
        \item Системы защиты, вирусы и антивирусы. Код там, кстати, похожий, лол. Более того, они иногда лезут в машинный код, кодогенерацию на лету, более того код может даже полиморфным получаться. (Так Denuvo работает.)
        \item Низкоуровневые оптимизации. Если вы компилятор пишете, например. Если вы пишете код с арифметикой с насыщением. Вопрос: догадается ли компилятор, что вам надо использовать инструкцию? Можно напрямую писать на ассемблере, если вы переписываете какую-нибудь функцию, которая занимает существенное время.\\
        Что интересно, вы обычно пишете несколько ассемблерных вставок под одно и то же. Почему? Потому что ISA разные.\\
        Обычно речь идёт именно про SIMD. Не только потому, что его сложно заметить в высокоуровневом коде, но ещё и потому, что обычно SIMD происходит в числах с пониженной точностью. А значит ваш язык может просто не уметь выражать то, что вы хотите.
        \item Отладка программ. А вы думали иначе? Если есть исходники, то всё круто. Если нет, со знанием ассемблера вы всё равно можете. В т.ч. когда происходят баги компилятора.
    \end{itemize}
    \paragraph{Продолжаем историю.}
    Pentium MMX был первым процессором, на котором можно было смотреть видео 320\texttimes 240 30 кадров в секунду в MPEG-I без аппаратных ускорителей. После него появился Pentium 2 (который позиционировался как помесь Pentium MMX и Pentium Pro; это правда, но процессор подешевле, конечно, чем Pro) и Pentium 3. Там появился SSE~--- своеобразный SIMD для вещественных чисел. Потом произошла неудача с Pentium 4 и SSE2 (и SSE3). Если до этого микроархитектура была одинаковой и работающей, то Pentium 4 с новой микроархитектурой дико грелся (по тем временам) и выдавал низкую скорость (из-за извращённой архитектуры) несмотря на адские мегагерцы.\\
    Почему нет 64-битного режима? Потому что во время Pentium 4 Intel хотели выпустить Intel Itanium, свой, новый и с лицензией только у себя. Но он по многим причинам был окрещён Intel Itanic и утонул. В итоге Intel поддержали AMD-шное расширение на 64 бита. Спойлер: оно называется amd64.\\
    Параллельно был Pentium M~--- развитие Pentium 3 с оптимизацией в энергопотребление. Это для ноутбуков. Когда стало ясно, что Pentium 4~--- это провал, инженеры взяли Pentium M и сделали из него Core 2, в котором добавили расширение SSSE3. Это расширение уже про целые числа, и довольно полезные. В полее поздних ревизиях было SSE 4.1. Core 2 был хорош.\\
    Дальше была линейка i7 с микроархитектурой Nehalem (из которых уже потом были урезанные i5), и там добавили SSE4.2. Дальше серия ix-2xxx и микроархитектура Sendy Bridge, где добавили AVX., потом i7-4xxx (микроархитектура Haswell), где появился AVX2~--- расширили регистры SIMD до 256 бит. А ещё там FMA~--- возможность сделать \mintinline{c}|d = a * b + c| с толко одним округлением в конце. Она хороша, но считается и за сложение, и за умножение, потому что увеличивает вдвое FLOPS. Потом была серия ix-6xxx (в этот момент начинают расходится цифры для десктопов и всего остального), так что будем смотреть по микроархитектуре (тут Skylake). Тут было AVX512, но было оно только у серверного Skylake. Обещали, что добавят в десктопы, когда будет новый техпроцесс (10 нм). Спойлер: нового техпроцесса не произошло.\\
    Отсюда и до 10xxx происходит Skylake.\\
    Что дальше? Серия 11xxx (Cypress Cove), которая быстро умерла, в которой они добавили AVX512. Но тут им дали пинка AMD, потому что они начали отгружать ядра подешёвке (и по деньгам, и по энергии). А Intel так не могли, в энергию не лезет. Поэтому в серии 12xxx надо было откуда-то кучу ядер. Поэтому туда добавили слабые ядра. Откуда их взяли? Из Atom~--- попытки Intel зайти на мобильный рынок (но провалились). Короче теперь в 12xxx (Golden Cove~--- сильные ядра + Gracemont~--- слабые ядра) и 13xxx с 14xxx (Raptor Cove + Gracemont) сериях крутые ядра поставляются вместе с пачкой убогих, которые не умеют AVX512. Поэтому Intel решили не поставлять AVX512 туда, где есть слабые ядра. Из интересного, когда 12xxx только выходили, люди научились в BIOS-е выключать убогие ядра и включать AVX512. Больше так нельзя, Intel теперь аппаратно отключают AVX512.
    \paragraph{AMD.}
    Ни одна компания не хочет завязываться на другую компанию. Поэтому когда IBM пришли к Intel, они поставили одно условие: они дадут одну лицензию компании AMD. Есть ещё одна лицензия, но она переходила по рукам, выпускала банкоматы под виндой, а сейчас её просто держат в подвале и не используют. Из интересного компания, которая имела третью лицензию, сделала себе аппаратное перепрограммирование команды, которая говорит, кто производитель процессора. Зачем им прикидываться Intel'ом или AMD? Потому что они обнаружили, что винда не грузится. А в винде было написано, что если Intel, делаем одно, если AMD~--- другое, а иначе нечто нерабочее. При помощи этого ещё тестировали Intel-компилятор, чтобы доказать, что он не использует расширения (даже если может) на процессорах AMD.\\
    i8086 просто склонировали, а дальше, AMD выпускали то же самое (с названиями Am286, Am386, Am486 и Am5x86), но нестандартными расширениями. Потом был K5, K6 (Pentium 2), K6-2 (в который добавили MMX), и K6-3, в котором появилось расширение 3DNow! (теперь можно считать 2 \mintinline{c}|float| на MMX; Intel её естественно не поддержали, а вместо этого скрафтили SSE, в котором можно считать 4 \mintinline{c}|float|'а). Во время Pentium 3 появился Atlon (3DNow! Pro).\\
    Дальше был Atlon XP, в котором наконец-то появился SSE. Дальше неинтересно до тех пор, пока не появился Atlon64 (времена Pentium 4). И он был сильно круче, чем Pentium, несмотря на низкую частоту. Да ещё и в Atlon64 был 64-битный режим (и SSE2). Зачем 64 бита? Потому что адресное пространство очень маленькое. А значит что? Что все (особенно любители серверов) покупают Atlon64. Вместо уходящего в закат и сомнительного Pentium 4 и откровенно отстойного Intel Itanium.\\
    После этого был какой-то непопулярный кал (Phenom и линейка с названиями строительной техники), а сейчас ядро Zen (линейка Ryzen), в которым убрали всякий мусор (типа 3DNow!) и сделали сразу AVX2. Из интересного~--- Zen 4, который поддерживает AVX512. Ядра поменьше там тоже есть, но не в обычных процессорах, а в мобильных, причём следующего поколения. Ещё есть Zen 4c: <<c>>~--- более плотная паковка деталек Zen 4 + порезанная максимальная частота и порезанный L3 вдвое. За счёт этого туда запихали побольше ядер на кристалл. А потом начали мешать обычные и <<c>>, что сильно круче, чем происходящее у Intel. Дальше Zen 5, которых 3 вида: обычные, <<c>> и мобильные, и мобильные порезаны.
    \section{Займёмся делом.}
    Как закончить программу? Одной командой: \mintinline{nasm}|ret|. Одна проблема: надо объяснить, что с этого надо начинать. Проще всего жить по правилам C и сказать, что это конец функции \mintinline{nasm}|main|. Можно иначе, но так проще и логичнее. И вот программа
    \begin{minted}{nasm}
    main:
        ret
    \end{minted}
    Разве что под Windows лучше написать \mintinline{nasm}|_main| (64бит такого прикола не имеет). Это уже почти работает: надо только сказать, что \mintinline{nasm}|main| должно быть видно снаружи:
    \begin{minted}{nasm}
        global main
    main:
        ret
    \end{minted}
    Возможно, потребуется сказать
    \begin{minted}{nasm}
        global main
        section .text
    main:
        ret
    \end{minted}
    Если хочется код возврата дать, то так:
    \begin{minted}{nasm}
        global main
        section .text
    main:
        mov eax, 0
        ret
    \end{minted}
    Уже хорошо. Теперь возьмём nasm и попросим его скомпилировать это. Правда, надо ему указать, под какую систему компилировать. Например, \mintinline{console}|-f win32| под Windows. У вас появится объектный файл, который можно скормить линковщику (gcc, например).\\
    \subsection{Регистры.}\label{par:registers}
    Первое: x86~--- reg-mem-2 архитектура. И дальше мы будем говорить про регистры, про которые мы что-то можем знать. Т.е. регистры общего назначения. Они вот такие:
    \begin{itemize}
        \item \mintinline{nasm}|ax|~--- аккумулятор.
        \item \mintinline{nasm}|cx|~--- счётчик.
        \item \mintinline{nasm}|dx|~--- данные + расширение аккумулятора.
        \item \mintinline{nasm}|bx|~--- базовый.
        \item \mintinline{nasm}|bp|~--- немного по-другому базовый.
        \item \mintinline{nasm}|sp|~--- указатель в стек.
        \item \mintinline{nasm}|si|~--- source.
        \item \mintinline{nasm}|di|~--- destination.
    \end{itemize}
    При этом начиная с 32 битов эта специализация ослабла, но не исчезла. Всё описанное тут~--- 16-битное. Причём для обратной совместимости с 8-битным i8080 к регистрам \Verb|*x| можно обратиться не полностью, а по половинкам: \Verb|*l|~--- младшая, \Verb|*h|~--- старшая. При этом при изменении частей другая часть не меняется. Когда началось 32-битное расширение, все регистры расширили до 32 бит, написав \Verb|e| в начале имени регистра. Теперь, например, \mintinline{nasm}|ax|~--- младшие 16 бит \mintinline{nasm}|eax|. Потом добавили 64-битные версии, да ещё и новых регистров добавили, но о них не сейчас.\\
    Кроме этого и совсем системных существуют два интересных: flags (eflags, rflags) и ip (eip, rip). Что такое флаги? Когда вы делаете действие, помимо нормального результата устанавливают флажки. Они представлены битами регистра FLAGS. Например: сложение может переполниться и тогда он установит CF~--- carry flag. Есть, например, ZF~--- её ставят, например, сложение и вычитание, если в результате ноль. Из ещё полезного SF~--- sign flag~--- равен старшему биту результата, а значит что он показывает знак результата. Сильно позднее нам будет интересен DF, а сейчас обсуждать его не будем.\\
    А ip~--- instruction pointer. Хранит адрес следующей исполняемой инструкции. Ни к флагам, ни к ip нельзя обратиться напрямую, но некоторые команды могут с ними взаимодействовать.
    \subsection{Адресация.}
    Когда в качестве аргумента какой-то команды хочется использовать штуку, которая находится по адресу какому-то, вокруг адреса ставятся квадратные скобки. Что можно использовать в качестве адреса? В разных режимах разное. В 16-битном: сумма произвольного подмножества из: базы (регистра \mintinline{nasm}|bx| или \mintinline{nasm}|bp|), индекса (\mintinline{nasm}|di| или \mintinline{nasm}|si|) и сдвига~--- 16-битной константы. В 32-битном: (любой регистр) + (любой регистр, кроме \mintinline{nasm}|esp|) * (число из 1, 2, 4, 8) + (32-битная константа). Опять же, любая часть опускается. В некоторых ассемблерах можно менять штуки местами, в большинстве умножение на 1 можно опустить, а ещё некоторые понимают \mintinline{nasm}|[eax * 5]|. Как? Это равносильно \mintinline{nasm}|[eax + eax * 4]|. Про 64-битную адресацию не расскажем.
    \subsection{Инструкции.}
    \paragraph{Присваивания.}
    Никто из инструкций этого параграфа не меняет флаги.
    \subparagraph{mov и его друзья.}
    Присваивание.
    \begin{itemize}
        \item В нормальном синтаксисе \mintinline{nasm}|mov dst, src| присваивает \mintinline{nasm}|src| в \mintinline{nasm}|dst|. Один любой из аргументов может быть памятью. Например, \mintinline{nasm}|mov eax, [ebx]|. Хм-м, сколько данных тут будет присвоено? 4 байта т.к. \mintinline{nasm}|eax| имеет 32 бита. Поэтому из памяти, адресом которой является \mintinline{nasm}|ebx| читается 4 байта и пишется в \mintinline{nasm}|eax|. Каким образом? Берётся \mintinline{nasm}|ebx| и ещё следующие 3 байта, и читаются. В x86 раньше в памяти идут младшие байты числа. Это называется little-endian. В других системах может быть строго наоборот, тогда это называется big-endian. В упоротых системах может быть смесь. В сетевых протоколах, к сожалению, выбран big-endian.\\
        Кстати, на последнем месте может быть константа. Но это может привести к неясности. \mintinline{nasm}|mov [eax], 123|~--- это присваивание какой битности? Так команда (в нормальных ассемблерах, таких как nasm) некорректна, поэтому нужно уточнить: \mintinline{nasm}|mov byte [eax], 5| или \mintinline{nasm}|mov [eax], byte 5|. Принято первое. Получается, что один байт. Можно также написать \mintinline{nasm}|word|, \mintinline{nasm}|dword|, \mintinline{nasm}|qword| для 16, 32 и 64 бит соотвественно. Ещё перед памятью может \mintinline{nasm}|ptr| стоять, но это не nasm, а masm или её такой кринж.
        \item Ещё есть \mintinline{nasm}|movsx| и \mintinline{nasm}|movzx|~--- копируют меньшее в большее следующим образом: меньшая часть копируется, остаток заполняется нулём для \mintinline{nasm}|movzx| либо знаковым битом для \mintinline{nasm}|movsx|. Best practices: если нужно присвоить байт в большой регистр, применение этих команд намного лучше чем \mintinline{nasm}|xor| с самим собой + \mintinline{nasm}|mov| байта. Это потому, что присваивание регистров размера равного битности системы осуществляется быстрее.
        \item Ещё есть \mintinline{nasm}|cmov|\textsubscript{\Verb|cc|}. Они, имеют чуть меньше вариантов откуда и куда загружать. Например, нельзя на второй аргумент написать константу. А прикол их в том, что они загружают значение при определённом условии. Например, \mintinline{nasm}|cmovz|~--- присваивает, если стоит ZF и \mintinline{nasm}|cmovnz|~--- если не стоит. Помимо таких простых штук есть ещё комбинации, которые позволяют сравнивать числа. Как сравнивать числа? По сути, вычитанием. Если аргументы равны, будет \Verb|ZF|, если первое меньше второго в беззнаковом типе, то это \Verb|CF|. А если в знакомом, то \Verb|OF|. И можно скомбинировать их в, например, \mintinline{nasm}|cmovbe|~--- меньше либо равно (комбинация c || z).\\
        Но у этого семейства команд есть беды. Во-первых, \mintinline{nasm}|cmov| умеет присваивать только регистры (т.е. не работает ни с памятью, ни с константами). Во-вторых, она не умеет в 8-битные регистры.
    \end{itemize}
    \subparagraph{xchg.}
    Обмен без дополнительной памяти. \textbf{Атомарный} swap. Если вы хотите поменять значения двух регистров, то вы делаете что-то странное, но ладно. Но если вы делаете \mintinline{nasm}|xchg| с памятью, то она работает невероятно долго (из-за атомарности).
    \subparagraph{bswap и movbe.}
    \mintinline{nasm}|bswap|: Берёт 32-битный (в 64-битном режиме можно и 64-битный) регистр, меняет endianness на противоположный (т.е. меняет байтики местами). \mintinline{nasm}|movbe|: \mintinline{nasm}|mov|, но с попутным изменением endianness. \mintinline{nasm}|movbe|~--- относительно новая команда, а следовательно может не быть, и код может не оптимизироваться компилятором без указания процессора в коде.
    \subparagraph{lea.}
    Имеет два аргумента: регистр и память. Она считает адрес памяти, НЕ ОБРАЩАЕТСЯ В ПАМЯТЬ и просто присваивает адрес в регистр. Типичное применение~--- трёхаргументное сложение, но насколько оно эффективнее~--- вопрос.
    \subparagraph{cwd и друзья.}\label{subpar:cwd}
    \mintinline{nasm}|cwd|~--- берёт старший бит \mintinline{nasm}|ax| и заполняем им \mintinline{nasm}|dx|. \mintinline{nasm}|cdq|, \mintinline{nasm}|cdo| делают то же самое, но с парами \mintinline{nasm}|eax|:\mintinline{nasm}|edx| и \mintinline{nasm}|rax|:\mintinline{nasm}|rdx|.\\
    Ещё есть \mintinline{nasm}|cwde|, \mintinline{nasm}|cbw| и \mintinline{nasm}|cdqe|~--- соотвественно расширяют знаковым битом \mintinline{nasm}|al| до \mintinline{nasm}|ax|, \mintinline{nasm}|ax| до \mintinline{nasm}|eax| и \mintinline{nasm}|eax| до \mintinline{nasm}|rax|. Зачем~--- поймёте потом.
    \paragraph{Арифметика.}
    Важное замечание: в языках мы привыкли что типы имеют знаковость, а операции~--- нет. Тут ровно наоборот: регистры и память~--- это просто биты. А арифметика интерпретирует их как число (знаковое или беззнаковое), и совершает операцию.
    \subparagraph{Сложение и вычитание.}
    \mintinline{nasm}|add| и \mintinline{nasm}|sub|. Делают соотвественно += и -=, в синтаксисе как \mintinline{nasm}|mov|. Попутно ставят флаги. Также есть \mintinline{nasm}|adc|~--- складывает два числа и прибавляет к ним CF в качестве единички~--- и \mintinline{nasm}|sbb|~--- вычитание, и вычесть флаг переноса.
    \subparagraph{Умножение.}
    Беззнаковое~--- \mintinline{nasm}|mul|, знаковое~--- \mintinline{nasm}|imul|. Принимает один аргумент (регистр или память, не константу) и умножает его на \mintinline{nasm}|ax| (или аналог аналогичной битности). Результат имеет битность вдвое больше. Куда присваивается результат~--- чуть сложнее:
    \begin{itemize}
        \item \mintinline{nasm}|ax| = \mintinline{nasm}|al| * arg8.
        \item \mintinline{nasm}|dx:ax| = \mintinline{nasm}|ax| * arg16.
        \item \mintinline{nasm}|edx:eax| = \mintinline{nasm}|eax| * arg32.
        \item \mintinline{nasm}|rdx:rax| = \mintinline{nasm}|rax| * arg64.
    \end{itemize}
    Что за непонятное двоеточие? Возьмём два регистра, склеим из них одно число побольше, где первый регистр~--- старшая часть.\\
    А ещё есть \mintinline{nasm}|imul reg, reg|~--- делает *=, отбрасывает старшую часть. Почему нет такого же для беззнаковых? А потому что верно следующее утверждение: младшая половина результата получается одинаковой для знакового и беззнакового умножения.\\
    А ещё есть \mintinline{nasm}|imul reg, reg, const|~--- умножает второе на третье, присваивает в первое. Опять же, знаковость на самом деле не важна.
    \subparagraph{Деление.}
    Есть \mintinline{nasm}|div| и \mintinline{nasm}|idiv|, и в их классической форме они похожи на правила для умножения. Например, он берёт пару \mintinline{nasm}|edx:eax| и делит на аргумент (всё ещё регистр или память). Частное записывается в \mintinline{nasm}|eax|. Что более интересно, он также считает остаток и присваивает в \mintinline{nasm}|edx|. Для 16 битов и 64 битов понятно, для 8~--- остаток присваивается в \mintinline{nasm}|ah|.\\
    Деление на ноль? Это определено как исключительная ситуация, и дальше происходит ситуация, похожая на \hyperref[subpar:int]{прерывание}: система останавливает выполнение, переходит в ядро к обработчику ОС и начинает делать какой-то другой код. Но это ладно. Мы делим 64-битное число на 32-битное. Оно легко может не влезть в 32-битное. И это тоже считается делением на ноль. Единственный способ заработать это на C~--- знаково поделить \mintinline{c}|INT_MIN| на \mintinline{c}|-1|.\\
    Что делать, если мы хотим делить друг на друга числа одинакового размера? Ну, если числа беззнаковые, то старшую часть надо обнулить. Если знаковые, то заполнить знаковым битом, и тут мы вспоминаем \hyperref[subpar:cwd]{\mintinline{nasm}|cwd| и друзей}.
    \subparagraph{Инкремент и декремент.}
    \mintinline{nasm}|inc| и \mintinline{nasm}|dec|. Делают почти всё как надо, но не меняют флаг переноса. Если вы используете этот факт, они сильно замедляются. Что в них хорошего~--- занимают меньше памяти, а чем меньше памяти, тем больше команд влезет в кэш.
    \subparagraph{neg.}
    Меняет знак числа на противоположный. Флаги ставит ровно как <<инвертировать все биты, добавить один>>.
    \paragraph{Логика.}
    \mintinline{nasm}|and|, \mintinline{nasm}|or|, \mintinline{nasm}|xor|. Побитовые логические операции. И \mintinline{nasm}|not|~--- побитовое отрицание.
    \subparagraph{xor для обнуления.}
    Традиционно для обнуления регистра принято использовать \mintinline{nasm}|xor| его самого с собой. Эта инструкция занимает меньше памяти, и более того распознаётся процессорами как некоторая идиома, и если вы сделали, например \mintinline{nasm}|xor eax, eax|, то дальше если вы используете \mintinline{nasm}|eax|, то его использование не приостанавливает Superscalar.
    \subparagraph{cmp и test.}
    \mintinline{nasm}|cmp|~--- делает то же самое, что \mintinline{nasm}|sub|, но не пишет результат, пишет только флаги. \mintinline{nasm}|test|~--- то же самое, но \mintinline{nasm}|and|, а не \mintinline{nasm}|sub|. Первое используется для сравнений на больше или меньше, второе~--- для установленных битов и сравнения с нулём т.к. \mintinline{nasm}|cmp| чего-то и нуля занимает много места (т.к. надо записать 32-битную константу 0). А если ваша команда занимает много места в памяти, вы меньше команд поместите в кэш.
    \subparagraph{Сдвиги.}
    \mintinline{nasm}|shr|, \mintinline{nasm}|shl|, \mintinline{nasm}|sar|, \mintinline{nasm}|sal|.\\
    Это всё логические или арифметические сдвиги. Сдвиги принимают два аргумента: что двигать и насколько. Сдвиг вправо двигает битики на несколько позиций в сторону меньших битов. Самый последний сдвинутый бит перемещается в CF. Но тут лучше документацию читать. Логический сдвиг заполняет освободившиеся позиции нулями (а значит полностью аналогичен делению на слепень двойки). Арифметический сдвиг заполняет их знаковым битом, что почти аналогично делению. Разница в том, что арифметический сдвиг округляет к $-\infty$. Сдвиги влево одинаковы и сдвигают в другую сторону. В CF пишется младший сдвинутый бит.\\
    Тут есть проблема с аргументами. Первым аргументом может являться только регистр или память, а вторым~--- константа или \mintinline{nasm}|cl|. Причём из него берутся только младшие биты в необходимом для этого количестве. Например, при сдвиге 32-битных чисел берутся только 5 бит.\\
    А ещё есть сдвиги двойной точности: \mintinline{nasm}|shld| и \mintinline{nasm}|shrd|. Принимают на вход два регистра и число (либо CL вместо числа), двигает первый регистр в нужную сторону, но пустые места заполняются частью второго аргумента. То есть для сдвига вправо пустые места заполняются младшими битами второго регистра. Для сдвига влево~--- заполняются старшими битами второго регистра. CF заполняется так же, как и для обычных сдвигов.\\
    И наконец \mintinline{nasm}|rol| и \mintinline{nasm}|ror|~--- циклический сдвиг битов в одну из сторон. Последний выдвинутый бит всё ещё отправляется во флаг переноса. Ещё в ту же степь есть \mintinline{nasm}|rcr| и \mintinline{nasm}|rcl|. Возьмём параметр, приклеим к нему CF, сделаем циклический, сука, сдвиг полученного числа, битности на 1 больше, чем аргумент.
    \paragraph{Работа со стеком.}
    У вас есть стек, он растёт вниз по адресному пространству. И вы можете класть туда значения и брать их оттуда.
    \subparagraph{push/pop.}
    Пушить на стек можно регистры, память, константы. Это по сути сдвиг \mintinline{nasm}|esp| выше по стеку на размер аргумента (то есть вычитание) + запись туда. \mintinline{nasm}|pop| принимает один аргумент (регистр или память), куда записать то, что сняли со стека. Если записывать никуда не надо, то что? Ну, можно просто прибавить значение к \mintinline{nasm}|esp|.\\
    Совет: очень хорошо для производительности, если все штуки на стеке выровнены кратно режиму программы.\\
    Ещё интересное: вы не можете класть на стек (и убирать со стека) 8-битные значения.
    \subparagraph{pusha(d)/popa(d).}
    Здесь и далее круглые скобки означают, что это дополнительный суффикс. Т.е. тут две пары команд: \mintinline{nasm}|pusha|, \mintinline{nasm}|pushad| и \mintinline{nasm}|popa|, \mintinline{nasm}|popad|.\\
    \mintinline{nasm}|pusha| пишет на стек все регистры (в порядке, указанном \hyperref[par:registers]{выше}). При этом в зависимости от ассемблера, на стек пишутся либо все регистры текущей битности, либо все 16-битные регистры. С суффиксом \Verb|d| гарантированно кладёт 32-битные регистры. Ещё некоторые ассемблеры понимают \mintinline{nasm}|pushaw|~--- точно положить 16-битные регистры. \mintinline{nasm}|popa| читает все регистры и восстанавливает все, кроме \mintinline{nasm}|sp|.
    \paragraph{Передача управления.}
    Самый простой~--- \mintinline{nasm}|jmp|~--- переход по метке, регистру или значению в памяти. На практике всё это пересчитывается в смещение относительно текущей команды.
    \subparagraph{Условные переходы.}
    \Verb|j|\textsubscript{\Verb|cc|}, где \Verb|cc|~--- то, что мы видели выше в разделе с \mintinline{nasm}|cmov|. Применимо только к меткам, если хочется по регистру или памяти, делайте абсолютный переход и обходите его условным переходом.
    \subparagraph{Вызовы функций.}
    \mintinline{nasm}|call| и \mintinline{nasm}|ret|. \mintinline{nasm}|call|~--- принимает на вход метку, регистр или адрес, записывает на стек адрес следующей команды и делает \mintinline{nasm}|jmp| по своему параметру.\\
    \mintinline{nasm}|ret|~--- снимает со стека значение и переходит по нему.\\
    \mintinline{nasm}|ret n|~--- снимает со стека адрес, увеличивает \mintinline{nasm}|esp| на \Verb|n|, переходит по тому, что в первый раз снял.
    \subparagraph{Прерывания.}\label{subpar:int}
    Прерывания предназначены для взаимодействия с внешними устройствами. Пример: пользователь нажимает на клавиатуру, а мы узнаём, что он там нажал. Можно периодически спрашивать клавиатуру, что там нажато, но это плохо из-за  того, что если вы часто спрашиваете, это активное ожидание (значит долго), а если редко, то мы пропустим, как пользователь нажал и отпустил. Это Polling называется. Поэтому используем прерывание: устройство посылает прерывание. Процессору похрен на клавиатуру до тех пор, пока ему не придёт прерывание. Тогда процесс перейдёт на обработчик прерываний (его устанавливает ОС). Тут уже клавиатура опрашивается, данные сохраняются, и вы продолжаете исполняться как ни в чём не бывало. Но тут нужна аппаратная поддержка: PS/2 работает через прерывание, а USB клавиатура работает через Polling. Ещё из интересного: PS/2 работает тупо и всегда. А USB может перестать работать из-за проблем с дровами.\\
    Так вот \mintinline{nasm}|int|~--- переходит на обработчик прерываний. Принимает на вход константу от 0 до 255. По сути программная эмуляция настоящих прерываний. Пример: \mintinline{nasm}|int 80h| зовёт ядро (на Linux). Ещё есть парная команда~--- \mintinline{nasm}|iret| т.к. прерывание сохраняет на стек побольше, чем функция (а именно адрес возврата, флаги, иногда стек). Впрочем, программные прерывания~--- не рекомендуемый способ позвать привелегированный режим, потому что это прерывания~--- это долго и неэнергоэффективно.\\
    У \mintinline{nasm}|int| есть несколько специальных форм, например \mintinline{nasm}|int3|~--- отладочное прерывание. Если у вас нет отладчика, вы умираете, если есть, то он её перехватит и начнёт делать что-то своё. Из прикольного у \mintinline{nasm}|int3| однобайтовый код \mintinline{c}|0xCC|, а у обычных прерываний код двухбайтовый.
    \paragraph{Вызовы ядра.}
    \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysexit|. Первое~--- джамп в ядро, второй~--- из ядра. Куда конкретно ядро? Есть машинно-специфичные регистры (MSR), и там есть в частности адрес, куда \mintinline{nasm}|sysenter| переходит.\\
    В отличие от \mintinline{nasm}|int| эти команды не сохраняют значение на стек. Поэтому прямое использование этих команд затруднено. Обычно ОС Вам делает \mintinline{nasm}|call| по адресу, в котором находятся \mintinline{nasm}|sysenter| и \mintinline{nasm}|ret|. И ОС делает так, чтобы возвращаться на этот \mintinline{nasm}|ret|. Но это всё равно быстрее прерываний.\\
    \mintinline{nasm}|syscall| и \mintinline{nasm}|sysret|. То же самое, что и \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysret|, но сохраняет адрес возврата на стек. Проблема в том, что это придумали AMD, поэтому в 32-битном режиме этих команд может не быть. Но это не всё. Ведь 64-битный режим придумали AMD, и они объявили, что в 64-битном режиме \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysexit| не поддерживаются. Intel, естественно, их поддерживает, но по умолчанию в 64-битном режиме все делают \mintinline{nasm}|syscall|.\\
    Из интересного в Windows вам дают системную библиотеку, в которую вы делаете \mintinline{nasm}|call|, и она сама там разбирается, как трогать ядро. И вам не надо думать, какие у вас поддерживаются прерывания, вызывать ли вам \mintinline{nasm}|sysenter| или \mintinline{nasm}|syscall|. Хотите не иметь проблем~--- залезьте в системную библиотеку.
    \paragraph{nop.}
    Делает ничего. Формально эквивалентен \mintinline{nasm}|xchg eax, eax|. А ещё есть многобайтовые версии \mintinline{nasm}|nop|. Применяется, чтобы начало короткого цикла выравнять по границе кэш-линии.
    \paragraph{ud2.}
    Команда, которой не существует. Исполняя её, гарантированно упадёт с ошибкой <<команда некорректна>>.
    \section{Calling conventions.}
    Calling convention~--- договоренность о том, как передаются параметры в функцию, куда помещается возвращаемое значение, где сохраняется адрес возврата (именно то, что отличает \mintinline{nasm}|call| от \mintinline{nasm}|jmp|), какие регистры функция обязана вернуть в исходное состояние.\\
    Если вы хотите указать прямо около функции, какого соглашения она должна придерживаться (например, \Verb|cdecl|), в clang и MSVC это делается примерно так: \mintinline{c}|void __cdecl foobar();|, а в gcc~--- при помощи: \mintinline{c}|__attrubite((cdecl))__|.\\
    Ниже будет краткое описание происходящего в 32-битных системах. Если вам этого мало, вот \href{https://www.agner.org/optimize/calling_conventions.pdf}{очень крутая ссылка}:
    \paragraph{cdecl}
    C-шная библиотека использует конвенцию \Verb|cdecl|, которую сейчас и опишем: адрес возврата сохраняется на стеке, аргументы кладутся на стек тем ниже, чем раньше аргумент. То есть сначала кладётся последний аргумент, потом предпоследний, и так далее, а после первого кладётся адрес возврата.\\
    Например, в функции вида \mintinline{c}|int f(int a, int b, int c)|. Тогда для вызова надо сделать так:
    \begin{minted}{nasm}
        push c
        push b
        push a
        call f
        add esp, 12
    \end{minted}
    С возвращаемым значением есть беда. Если оно влезает в регистр, его положат в соответствующую часть аккумулятора соответствующей битности. То есть если вы вернули \mintinline{cpp}|bool| или \mintinline{cpp}|char|, вам запишут результат в \mintinline{nasm}|al| (а в остальной части \mintinline{nasm}|eax| будет мусор). Если результат 16-битный~--- вернут в \mintinline{nasm}|ax|, если 32-битный~--- \mintinline{cpp}|eax|, а если 64-битный (в 32-битном режиме)~--- \mintinline{nasm}|edx:eax|. Что если больше? Тогда функция внезапно преобразовывается: нулевым её аргументом начинает идти адрес того, куда положить возвращаемое значение. Её выделяет вызывающий, потому что вызываемая функция почистить её не сможет (т.к. закончится). А выделять и освобождать в разных функциях... Не, ну, можно, конечно, если в соглашении о вызовах постулировать, как именно она выделяется, но у нас могут быть разные аллокаторы, например... Поэтому нет, кто освободил, тот и чистит.\\
    Также конвенция вызовов заставляет вас сохранять некоторые регистры (а именно \mintinline{nasm}|ebx|, \mintinline{nasm}|ebp|, \mintinline{nasm}|esi| и \mintinline{nasm}|edi|), поэтому если вы хотите испортить их значение, положите их на стек в начале функции, а потом снимите обратно. Ещё функция с соглашением \Verb|cdecl| должна гарантировать, что \mintinline{nasm}|esp| останется как был до вызова (т.е. аргументы со стека снимать нельзя; но можно их менять, там уже всем будет похрен).\\
    Из интересного если класть на стек аргумент меньше 32-х бит, он всё равно дополнится до 32-х бит. Если аргумент 64-х битный, пушится 64 бита в порядке little-endian, то есть младшие биты в младших адресах (или младшие биты раньше на стеке).
    \subparagraph{Mangling}
    Если вы хотите вызывать функцию из C++, у вас большие проблемы, потому что, как мы помним из курса C++, там у функций могут быть одинаковые имена и разные наборы аргументов, поэтому просто по имени функцию не найти. И тут у вас есть два варианта: либо повесить на функцию модификатор \mintinline{cpp}|extern "C"|, что заставит её называться ровно по имени, либо узнать, как она называется на самом деле, и использовать это имя. Например, вот так под gcc 14.2 выглядит \mintinline{cpp}|std::vector<int>::push_back(const int&)|: \Verb|_ZNSt6vectorIiSaIiEE9push_backERKi|. А вот так под MSVC 19.40: \Verb|?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z|. Мораль проста: если вы пишете библиотеку, наружу лучше вытаскивать функции с \mintinline{cpp}|extern "C"|, чтобы быть кроссплатформенным.\\
    Из интересного: декорирование имён существует не только в C++, но и в C под 32-битной Windows, где вместо \Verb|main| у вас \Verb|_main|, вместо \Verb|printf|~--- \Verb|_printf| и т.п.
    \paragraph{Пример с Hello world}
    Как положить в память строчку символов? В nasm вот так:
    \begin{minted}{nasm}
        format: db "abc", 0xa, 0
    \end{minted}
    Инструкция \mintinline{nasm}|db| кладёт в память указанный набор байт (по адресу текущей инструкции). Конкретно в данном случае в память кладётся \mintinline{c}|"abc\n"| (с 0-терминатором, чтобы \mintinline{c}|printf| смог её вывести). И устанавливается метка \mintinline{nasm}|format:|, которая указывает на данную строку.\\
    В каком месте лучше всего написать \mintinline{nasm}|db|? Ну, эту строчку мы менять не собираемся, и для неизменяемых данных как раз есть специальная секция \mintinline{nasm}|section .rdata|.\\
    Так, что ещё. Если мы просто сделаем \mintinline{nasm}|call printf|, нам скажут, что не нашли \mintinline{c}|printf|, поэтому надо его объявить командой \mintinline{nasm}|extern printf|:
    \begin{minted}{nasm}
        section .text
        global main
        extern printf
        main:
        push 123
        push format
        call printf
        pop eax ; Можно просто двигать стек,
        pop eax ; если вы знаете, куда его двигать
        xor eax, eax
        ret
        
        section .rdata
        format:
        db "%i", 0xa, 0
    \end{minted}
    Примечание: этот код не будет работать под 32-битной Windows, даже если заменить \Verb|printf| на \Verb|_printf| (об этом было выше). Дело в том, что с некоторым шансом вам подсунут стандартную библиотеку, в которой \mintinline{c}|printf| определён как \mintinline{c}|inline|-функция прямо в \Verb|stdio.h|, и поэтому ни в одной статической библиотеке его не найти.
    \paragraph{stdcall}
    Эта конвенция очень похожа на \Verb|cdecl| и отличается только одним: функция сама чистит стек от параметров. Например, функция \mintinline{c}|int f(int a, int b)| заканчивается командой \mintinline{nasm}|ret 8| (напоминание: это значит, что после чтения адреса возврата со стека и прыжком по нему надо увеличить \mintinline{nasm}|esp| на 8). Это немного упрощает ваш код, но такая конвенция не позволяет делать функции с переменным количеством аргументов (ведь функция тупо не знает их количество).
    \paragraph{pascal}
    По сути \Verb|stdcall|, у которого аргументы поменяли местами.\\
    Никому нахрен не нужен. Как минимум потому, что он говно (если у тебя не vararg, то зачем тебе чистить стек самому, а если vararg, то ты фиг ты найдёшь, где там первый аргумент). А ещё потому, что Pascal мёртв, а тот, что не мёртв (Pascal ABC.Net)~--- это на самом деле .NET.\\
    В 16-битном мире ещё хоть как-то использовался, а сейчас больше нет.
    \paragraph{thiscall, методы}
    Похоже на \Verb|stdcall|, но это специальная конвенция по умолчанию (в майкросовтовских компиляторах) для методов. Так вот \mintinline{cpp}|this| передаётся в \mintinline{nasm}|ecx|.\\
    Вопрос: а как методы класса работают, если им указать другую конвенцию? Ну, \mintinline{cpp}|this| добавляется нулевым аргументом. Но тут новая проблема: а если мы решили создать метод класса, который возвращает большой объект? Кто раньше будет \mintinline{cpp}|this|, а кто возвращаемое значение? А не договорились, разные компиляторы делают это по-разному. Отсюда вы вообще не хотите, чтобы методы классов возвращали что-то большое. Если на DirectX посмотреть, то там нигде никакой метод не возвращает то, что не поместится в аккумулятор.\\
    Из ещё более грустного, вообще не всё равно в каком порядке эти аргументы положить. Намного лучше класть сначала возврат, потом \mintinline{cpp}|this|, потому что тогда вы сможете трактовать эту функцию как нормальную функцию из C (объявив ей первый аргумент явно). А возвращаемое значение как было норм, так и остаётся. Microsoft сделали хреново, все остальные~--- нормально.
    \paragraph{fastcall}
    Тут не договорились ни о чём вообще. Какие-то аргументы передаются через регистры в каком-то порядке, сколько и как~--- никто не знает. Не вытаскивайте это за пределы одного компилятора.
    \section{Best practices.}
    \paragraph{Как правильно писать if.}
    Вот у нас в if есть что-то типа \mintinline{c}|eax > 5|. Чтобы сформулировать, как писать условие на ассемблере, надо сначала понять, как мы сравниваем: знаково или беззнаково. если это сравнение беззнаковое, нам надо использовать прыжки с \Verb|a| и \Verb|b|. Иначе~--- \Verb|l| и \Verb|g|. При этом если в if несколько условий, то написание \mintinline{c}|if|'а на ассемблере отличается в зависимости от того, как связаны условия.\\
    Например:
    \begin{minted}{c}
        if (eax > 5 && ebx) {
            // then-branch
        }
    \end{minted}
    трансформируется в
    \begin{minted}{nasm}
        cmp eax, 5
        jbe .lend    ; полностью равносильно jna .lend
        test ebx, ebx ; так традиционно сравнивать с нулём само число
        jnz .lend
        ; then-branch
    .lend:
    \end{minted}
    Заметим, что тут хорошо работает правило из C про ленивое исполнение. Это важно. Алгоритм может зависеть от факта, что второе условие не выполнят, если не надо.\\
    Другой пример:
    \begin{minted}{c}
        if (eax > 5 || ebx) {
            // then-branch
        }
    \end{minted}
    трансформируется в
    \begin{minted}{nasm}
        cmp eax, 5
        ja .lthen
        test ebx, ebx
        jnz .lend
    .lthen
        ; then-branch
    .lend:
    \end{minted}
    Что делать, если есть else? Да всё просто, переходы на \mintinline{nasm}|.lend| заменить на переходы в \mintinline{c}|else|, а после конца \mintinline{c}|if| сделать безусловный переход на метку после окончания if'а.\\
    Вы не хотите разрывать проверку от условного перехода. Например, потому, что современные процессоры умеют в macro-fusion. Обычно одна внешняя команда превращается в одну или несколько микроопераций, в зависимости от наличия железа для выполнения команды как одной. Например, \mintinline{nasm}|add eax, [ecx]| свободно может превратиться в две команды: чтение памяти и сложение. Из интересного, эти действия могут происходить в разное время. Так вот macro-fusion~--- это фича, которая позволяет превращать несколько команд в одну. В x86 такое типично может быть для сравнения + перехода.\\
    Мы уже говорили про то, что порядок условных переходов иногда критичен для алгоритма. Но если нет, этим можно пользоваться. Если есть условный переход, который легко предсказывается, и который позволяет обойти остальные, то его имеет смысл вставлять в начало, если можно.\\
    И ещё best practice. Пусть мы хотим сравнить \mintinline{c}|if (x >= 3 && x < 7)|, где \mintinline{c}|x| беззнаковый. Это отлично можно сделать за один переход.
    \begin{minted}{nasm}
        mov ecx, x
        sub ecx, 3
        cmp ecx, 4
        jae ecx .lend
        ; then-branch
    .lend
    \end{minted}
    Но тут вопрос в том, насколько хорошо это предсказывается. Если значения расположены случайно, один переход лучше, чем два. Более того, такой же прикол в C работает, можно явно написать \mintinline{c}|if (x - 3 < 4)|. Компилятор может и сам догадаться, а может не.\\
    Что ещё интереснее, то же работает для знаковых типов. Главное, чтобы сравнение (на \Verb|<| либо \Verb|<=|) точно было беззнаковое. Поэтому на ассемблерах будет работать тот же код буквально, а в C, чтобы компилятор догадался, придётся написать пару букв: \mintinline{c}|if (x - 3u < 4u)|.\\
    Ещё из интересного, можно прямо в ассемблере писать что-то типа \mintinline{nasm}|cmp al, '9' - '0'|. Оно будет делать то, что ожидается. Более того, можно просить его посчитать разницу между двумя метками. Нужно это бывает для того, чтобы длину строки куда-нибудь захардкодить (для этого мы берём адрес конца её минус адрес начала).\\
    Интересный пример с шестнадцатеричными цифрами. Кажется, тут надо делать три проверки на диапазон (\mintinline{c}|'9' - '0'|, \mintinline{c}|'F' - 'A'| и \mintinline{c}|'f' - 'a'|). Но на самом деле, диапазон больших букв от диапазона маленьких отличается битом \mintinline{c}|0x20|. И он всегда установлен для цифр. Поэтому если мы точно знаем, что на входе цифры и шестнадцатеричные цифры, можно форсированно этот бит поставить, и цифры не изменятся, а большие буквы перейдут в маленькие.
    \paragraph{Как писать циклы.}
    \begin{itemize}
        \item Начнём с цикла \mintinline{c}|do { /* X */ } while (eax < 5u);|. Как выглядит на ассемблере? Ну, очевидно:
        \begin{minted}{nasm}
        .loop:
            ; X
            cmp eax, 5
            jb .loop
        \end{minted}
        \item Теперь \mintinline{c}|while (eax < 5u) { /* X */ }|. Окей:
        \begin{minted}{nasm}
            cmp eax, 5
            jnb .lend
        .loop:
            ; X
            cmp eax, 5
            jb .loop
        .lend
        \end{minted}
        То есть компилятор превращает while в do-while с условием в начале. Более того, если компилятор умеет доказывать, что цикл while исполняется хотя бы раз, он может это убрать.
        \item И, наконец, цикл for. \mintinline{c}|for (eax = 0; eax < ebx; eax++) { /* X */ }|. От while он отличается ничем по сути, и его можно переписать так:
        \begin{minted}{c}
            eax = 0;
            if (eax < ebx) {
                do {
                    // X
                    eax++;
                } while (eax < ebx);
            }
        \end{minted}
        Конкретно в данном случае if можно убрать.\\
        Но это ладно. Немногие знают, что лучше работают циклы в обратном порядке: \mintinline{c}|for (unsigned i = n - 1; i != -1; i--)|. Почему? Потому что \mintinline{nasm}|dec| отлично проставляет ZF (но не CF, это важно). Более того, macro-fusion отлично работает для комбинаций \mintinline{nasm}|dec| + \mintinline{nasm}|jz| и \mintinline{nasm}|dec| + \mintinline{nasm}|jnz| (и прочих условных переходов, если они не используют CF). И также работает сложение и вычитание с переходами. Более того, компиляторы умеют переворачивать циклы:
        \begin{minted}{nasm}
            mov eax, ebx
        .L1
            ; X
            dec eax
            jnz .L1
        \end{minted}
        Но эта штука идёт от 5 до 1, а не от 4 до 0. Надо починить. Ну, всё просто
        \begin{minted}{nasm}
            lea eax, [ebx - 1]
        .L1
            ; X
            sub eax, 1
            jnc .L1
        \end{minted}
        Это правильный вариант. Но есть ещё более крутой, если \mintinline{nasm}|eax| не очень большой.
        \begin{minted}{nasm}
            lea eax, [ebx - 1]
        .L1
            ; X
            dec eax
            jns .L1
        \end{minted}
        Но это ладно. Что если мы хотим двигаться вперёд? Можно двигаться вперёд к нулю. Типа такого:
        \begin{minted}{c}
            for (eax = -ebx; eax < 0; eax++) { /* X */ }
        \end{minted}
        Тут надо пошаманить с \Verb|X|, но если мы там к массиву хотим обратиться, то всё вообще круто. Например, \Verb|X := ecx[eax]++|, где \Verb|ecx|~--- массив dword'ов.. Тогда делаем так:
        \begin{minted}{nasm}
            lea ecx, [ecx + ebx * 4]
            mov eax, ebx
            neg eax
        .L1
            inc dword [ecx + eax * 4]
            inc eax
            jnz .L1
        \end{minted}
        \textbf{Важное примечание}: везде вышенаписанный код опирается на то, что хотя бы раз условие цикла выполнится. Иначе сверху надо бахнуть ещё одно сравнение.
    \end{itemize}
    \paragraph{Как писать switch.}
    Для начала: аргументом switch может быть только целое число. Веткой case~--- только константа времени компиляции. В честь чего? В честь того, что только так это можно скомпилировать лучше, чем в кучу if'ов. Возьмём такой switch:
    \begin{minted}{c}
        switch (eax) {
        case 1:
        case 2:
            // X
            break;
        case 3:
            // Y
        case 5:
            // Z
        }
    \end{minted}
    Так вот, это отлично компилируется в такое:
    \begin{minted}{nasm}
    section .text
        cmp eax, 5
        ja .lend
        jmp [table + eax * 4]
    .L1:
        ; X
        jmp .lend
    .L2:
        ; Y
    .L3:
        ; Z
    .lend:

    section .rdata
    .table: dd .lend, .L1, .L1, .L2, .lend, .L3
    \end{minted}
    Короче, тут безусловный переход по табличке. Если значения разнородные (типа 1, 2, 4 и 100000), компилятор их распилит. А если они совсем рандомные, то будет куча if'ов. Возможно, с двоичным поиском.
    \section{Время и скорость.}
    Начнём с простого: вот вы нашли какую-то команду. Как понять, быстро ли она работает? Для начала определимся с терминами: latency и throughput. Первая~--- количество тактов от начала вычисления до получения результата. Вторая~--- сколько команд в единицу времени может исполнять процессор. Концептуально, первое о последовательности зависимых команд, второе~--- об одновременном количестве исполняемых команд.\\
    Теперь к делу. Очевидно, в документации время вам никто не напишет (потому что в документации ISA, она про то, что команда делает), а время~--- это микроархитектура, про которую вам никто ничего не скажет.
    \paragraph{rdtsc}
    Можно вызвать команду \mintinline{nasm}|rdtsc| и её вариации. Например, \mintinline{nasm}|rdtscp|. Обе пишут в \mintinline{nasm}|edx:eax| время с момента reset в тактах. Вторая портит \mintinline{nasm}|ecx|, но её менее вольно можно переставлять в Superscalar'е. При этом кратность может быть больше одного такта. А ещё команда достаточно тяжёлая (около 100 тактов). Вообще зная тактовую частоту, можно пересчитать в секунды. А ещё незадолго после того, как процессоры научились разгоняться, таймер \mintinline{nasm}|rdtsc| отвязали от таймера процессора. У этой штуки точность равна сотням тактов, поэтому скорость одной инструкции не измерить. Впрочем, у способов, что даёт операционная система, точность~--- миллисекунды, так что если вам надо именно время для блока кода измерить, то на здоровье.
    \paragraph{Профилировщики.}
    Если Вы измеряете скорость кода и всё, то ладно. Но если вам нужно понять, почему она такая, надо ставить профилировщик. Причём лучше всего, чтобы профилировщик был от того производителя, что и процессор. Правда, у AMD профайлер не очень. Но зато там есть норм такое API доступа ко всяким встроенным счётчикам, которые могут помочь.\\
    А ещё чтобы что-то профилировать, по-хорошему надо стабилизировать частоту процессора. На Windows такое может AIDA64 (как профилировщик она средняя, но там можно попросить выключить турбо). На Linux нужно как-то добраться до MSR и найти, какой флаг отвечает за турбо. Правда, стабилизация частоты, вероятно, сильно снизит скорость работы. Зато \mintinline{nasm}|rdtsc| будет более стабильным.
    \paragraph{Скорость работы конкретной команды.}
    Но то было про блоки кода. А если вы хотите узнать скорость одной команды, то тут совсем мрак. Проблема в том, что ассемблерная команда, во-первых, работает очень быстро, а во-вторых, суперскаляр может ее попортить, поэтому нужно создать необходимые условия для измерения. Еще скорость команды может определяться несколькими числами. Если мы будем измерять latency, то у команды умножения есть аж три результата, получаемые с разной скоростью: младшие биты, старшие биты и флаги. Как правило, младшая половина доступна пораньше.\\
    Но вообще люди не дураки, и создали \href{https://uops.info/table.html}{вот такую табличку}, где можно почитать числа про интересующие вас инструкции для интересующего вас процессора.
    \section{FPU.}
    Оно же имеет название x87 и <<математический сопроцессор>>. Это модуль работы с плавающей точкой. Изначально это был отдельный набор команд и отдельные микросхемы, которые назывались так же, как и процессор, но с семёркой на конце. Именно поэтому команды такие странные, потому что изначально это был отдельный сопроцессор, который общался с CPU через память.
    \subsection{Регистры.}
    Служебные мы тут обсуждать не будем, только общего назначения. Они называются \mintinline{nasm}|R0|, \mintinline{nasm}|R1| и т.д. до \mintinline{nasm}|R7|, но в таком виде их не применяют. А всё потому, что эти регистры организованы в виде стека. \mintinline{nasm}|R0| снизу, \mintinline{nasm}|R7| сверху. А указатель стека находится в определённом месте, и все обращения идут относительно него. А регистры назваются \mintinline{nasm}|ST0|, \mintinline{nasm}|ST1| и так далее. Прямо под указателем стека находится \mintinline{nasm}|ST0|, следующий за ним~--- \mintinline{nasm}|ST1|.\\
    Все регистры~--- 80-битные. И в формате extended-precision они хранят число. При этом FPU умеют автоматически конвертировать типы данных. Они поддерживают целые числа \textbf{со знаком} (16, 32 и 64 бита), плавающую точку в форматах single, double и extended (кажется, уточнение для размера~--- \Verb|tbyte|) и BCD80. BCD80 (Binary Code Decimal)~--- это про десятичные цифры в байтиках. Каждые 4 бита хранят десятичную цифру.\\
    И это всё ладно. Но самое плохое, что ячейки помечены как занятые или свободные. И попытка прочитать не занятую или записать в занятую производит NaN. Поэтому пользоваться стеком по кругу не получится.\\
    \subsection{Инструкции пересылки.}
    \paragraph{FLD, FILD, FBLD.}
    Загрузка на стек (сместить указатель стека вниз, записать туда, в новое \mintinline{nasm}|ST0|, значение). Имеют один аргумент (адрес в памяти). \mintinline{nasm}|FLD| ещё умеет в \Verb|ST(i)|. А отличаются они тем, что \mintinline{nasm}|FLD| оперирует числами с плавающей точкой, \mintinline{nasm}|FILD|~--- целыми числами, \mintinline{nasm}|FBLD|~--- BCD80.
    \paragraph{FLDZ, FLD1, FLDPI}
    Пушат на стек константу (0, 1 и $\pi$ соотвественно). Есть ещё несколько, но это можно загуглить. Из интересного, \mintinline{nasm}|FLDPI| пихает на стек не просто $\pi$, а с учётом текущего режима округления.
    \paragraph{FST(P), FIST(P), FBST(P).}
    Версии с \Verb|I| и \Verb|B| отличаются тем же, чем отличались \mintinline{nasm}|FLD|, \mintinline{nasm}|FILD| и \mintinline{nasm}|FBLD|. Стоит заметить, что \mintinline{nasm}|FIST| округляет в соответствии с текущим режимом округления. По умолчанию он к ближайшему чётному (а не к нулю).\\
    Если без \Verb|P|~--- взять значение из \mintinline{nasm}|ST0| и поставить в память или в указанное место на стеке. Если с \Verb|P|, то записать и после этого освободить ячейку и увеличить указатель стека (если делать \mintinline{nasm}|FSTP| и в качестве аргумента дать ячейку стека, вам сначала запишут, а потом сдвинут указатель).
    \paragraph{FXCH.}
    Меняет местами вершину стека и ещё одно значение стека. Она, как и \mintinline{nasm}|mov|, выполняется за 0 тактов.
    \paragraph{FCMOV\textsubscript{cc}.}
    Условная загрузка. Использует флаги процессора. Что они делают, Скаков не помнит, читайте документацию.
    \subsection{Инструкции арифметики.}
    Всегда: один аргумент~--- вершина стека. Другой~--- стек или память. Если команда обращается к памяти, то память~--- второй аргумент. При этом вершина стека может быть любым аргументом, но по умолчанию он первый.\\
    То есть вы можете написать команду \mintinline{nasm}|FADD ST2, ST0| (эта команда добавит вам \mintinline{nasm}|ST0| к \mintinline{nasm}|ST2|), а ещё можете написать либо \mintinline{nasm}|FADD ST0, ST2|, либо \mintinline{nasm}|FADD ST2| (в зависимости от ассемблера, который вы используете). Эта команда добавит \mintinline{nasm}|ST2| к \mintinline{nasm}|ST0|.\\
    Из интересного, в GNU-синтаксисе порядок аргументов такой же. Хотя во всех остальных командах (кроме сопроцессора) он обратный.
    \paragraph{FADD, FADDP, FIADD.}
    \mintinline{nasm}|FADD|~--- складывает и присваивает в первый аргумент. \mintinline{nasm}|FADDP|~--- складывает и делает pop со стека. \mintinline{nasm}|FIADD|~--- складывает \mintinline{nasm}|ST0| и целочисленную константу из памяти.\\
    Никаких констант нет, очень жаль. Хотите константу, помимо предложенных~--- разместите её в памяти, читайте оттуда.
    \paragraph{FSUB, FSUBP, FISUB; FSUBR, FSUBRP, FISUBR.}
    Обычное вычитание берёт первый аргумент, вычитает второй и присваивает в первый. Обратное вычитание берёт второй аргумент, вычитает первый и присваивает в первый.
    \paragraph{FMUL, FMULP, FIMUL.}
    Понятно.
    \paragraph{FDIV, FDIVP, FIDIV; FDIVR, FDIVRP, FIDIVR.}
    Тоже понятно.
    \paragraph{FPREM(1).}
    Вычитает \mintinline{nasm}|ST1| из \mintinline{nasm}|ST0| не более чем 64 раза до тех пор, пока модуль разности не будет меньше модуля \mintinline{nasm}|ST1|. Версия с единичкой отличается округлением (без неё~--- к нулю, с ней~--- к ближайшему целому).\\
    Смысл у этого всего есть, но небольшой. Обычно используется тогда, когда вы хотите вернуть значение в диапазон от 0 до $2\pi$.
    \paragraph{FABS.}
    Присваивает в \mintinline{nasm}|ST0| его модуль.
    \paragraph{FCHS.}
    Меняет знак \mintinline{nasm}|ST0|.
    \paragraph{FRNDINT.}
    Округляет \mintinline{nasm}|ST0| до целого в соответствии с текущим режимом округления.
    \paragraph{FSQRT.}
    Берёт квадратный корень \mintinline{nasm}|ST0|.
    \paragraph{FSIN.}
    Берёт синус \mintinline{nasm}|ST0|.
    \paragraph{FCOS.}
    Берёт косинус \mintinline{nasm}|ST0|.
    \paragraph{FSINCOS.}
    Берёт синус и косинус (берёт значение со стека, кладёт на стек сначала синус, потом косинус).
    \paragraph{FPTAN.}
    Берёт тангенс \mintinline{nasm}|ST0|.
    \paragraph{FPATAN.}
    Считает \mintinline{c}|atan2|. То есть практически арктангенс \Verb|ST1 / ST0|. Снимает со стека обоих.
    \paragraph{FCOMI(P).}
    Сравнивает \mintinline{nasm}|ST0| с \Verb|ST(i)| и ставит флаги \Verb|ZF|, \Verb|PF|, \Verb|CF|. Вариация с \Verb|P| снимает значение со стека.\\
    Заметьте, что они не ставят \Verb|SF| или \Verb|OF|, поэтому после сравнения вы хотите использовать \mintinline{nasm}|ja| и \mintinline{nasm}|jb|, а не \mintinline{nasm}|jl| и \mintinline{nasm}|jg|.\\
    Есть другие команды сравнения, они ставят флаги сопроцессора, и это вы не хотите.
    \paragraph{FINCSTP, FDECSTP.}
    Двигает указатель стека на единичку. Не меняет занятость.
    \paragraph{FFREE.}
    Пометить \Verb|ST(i)| как свободную ячейку.
    \paragraph{FNOP.}
    Делает ничего. Но не совсем. Он умеет бросить возникшее, но ещё не брошенное исключение. Да, IEEE-754 умеет в исключения. И железо это умеет, но надо включить это через служебные регистры. А вообще если исключение происходит, происходит системное прерывание (и гипотетически его можно обработать).
    \subsection{Конвенции вызовов с FPU (32 bit).}
    Аргументы single и double лежат на стеке процессора как число соответствующей битности. С extended сложнее.\\
    Возвращаемое значение лежит в \mintinline{nasm}|ST0|. Поэтому конвенциям вызовов всё равно, возвращаете вы \mintinline{c}|float|, \mintinline{c}|double| или \mintinline{c}|long double|: всё равно это \mintinline{nasm}|ST0|.\\
    При вызове функции стек сопроцессора должен быть чист, при возврате, если возвращаемого значения нет, то стек должен быть чист, если есть, то чист кроме \mintinline{nasm}|ST0|, где лежит результат.
    \section{x86\_64 (оно же amd64 и x64).}
    В двух про режимы словах~--- процессор может работать в разных режимах: 16-битный, 32-битный и 64-битный. Что такое вообще "режим"? Это то, как процессор интерпретирует ваши байтики в виде команд. Например, меняются коды команд. Обычно оно меняется не сильно, но можно найти команду, которую выбросили или команду, которая закодирована иначе. Ради чего затеяли 64-битный режим? Ради того, чтобы можно было иметь 64-битные адреса. Вообще умные операционные системы могут оперировать больше чем 4ГБ памяти, даже если они 32-битные. Но честно выдать одному процессу больше 4ГБ было нельзя. Можно было сложными системными вызовами попросить операционную систему давать вам разные адреса, но это сложно и неудобно.\\
    Нам это всё не так важно. Нам важно, что в наше время битность процессора~--- это битность адреса. Их интересного, на заре вычислительной техники битностью процессора называли количество бит, которыми он оперирует за раз. Например, то, что называлось 8-битным процессором, имело 8-битные регистры, но в память обращалось по 16-битной регистровой паре. В старой терминологии наши процессоры можно было бы назвать 512-битными (потому что AVX-512 умеет обращаться с 512-битными регистрами).
    \paragraph{Регистры.}
    Наши регистры расширили, yay! Теперь у нас есть \mintinline{nasm}|rax|, \mintinline{nasm}|rbx|, \mintinline{nasm}|rcx| и так далее по всем регистрам общего назначения. Это 64-битные регистры, 32-битные версии которых являются младшими битами этих. То есть \mintinline{nasm}|eax|~--- младшие 32 бита \mintinline{nasm}|rax|.\\
    Также добавили новых регистров: \mintinline{nasm}|r8|, \mintinline{nasm}|r9|, ..., \mintinline{nasm}|r15|. Это 64-битные регистры. Если хочется, можно и к меньшим кускам обращаться: младшие 32 бита~--- \mintinline{nasm}|r8d|, младшие 16~--- \mintinline{nasm}|r8w|, младшие 8~--- \mintinline{nasm}|r8b|.\\
    И последнее нововведение. Теперь можно написать \mintinline{nasm}|sil|, \mintinline{nasm}|dil|, \mintinline{nasm}|spl| и \mintinline{nasm}|bpl|: младшие 8 бит соотвественно \mintinline{nasm}|si|, \mintinline{nasm}|di|, \mintinline{nasm}|sp| и \mintinline{nasm}|bp|.\\
    В виду особенностей кодирования доступ к \mintinline{nasm}|ah|, \mintinline{nasm}|bh|, \mintinline{nasm}|ch| и \mintinline{nasm}|dh| ограничен: в одной команде нельзя использовать одновременно их и новые регистры. Из интересного, это потому, что коды \mintinline{nasm}|ah|, \mintinline{nasm}|bh|, \mintinline{nasm}|ch| и \mintinline{nasm}|dh| забрали под \mintinline{nasm}|dil|, \mintinline{nasm}|sil|, \mintinline{nasm}|spl| и \mintinline{nasm}|bpl|.\\
    И ещё особенность. Раньше, если вы писали в \mintinline{nasm}|ax|, то старшая часть \mintinline{nasm}|eax| не меняется. Тут ситуация иная: если вы пишете в 32-битный регистр (любой), старшая часть обнуляется. Если пишете в меньшей размерности регистр, то всё по старому. На самом деле это то, что вы хотите, чтобы не создавать зависимостей при конвейерном исполнении, и чтобы не создавать длинные константы: если вы хотите загрузить в \mintinline{nasm}|rax| константу \Verb|5|, то вам не надо сохранять эту константу 64-битной. Можете сделать \mintinline{nasm}|mov eax, 5|, и у вас и в \mintinline{nasm}|rax| будет пять. Правда, так только с беззнаковыми числами работает.\\
    Мораль проста: вместо \mintinline{nasm}|xor rax, rax| лучше писать \mintinline{nasm}|xor eax, eax| (первая команда на байт длиннее, потому что для кодирования дополнительных регистров добавили специальный байт перед командой, он называется REX и хранит этот бит и флажки).\\
    А вообще из интересного, процессорам не очень вот такое:
    \begin{minted}{nasm}
        xor eax, eax
        mov al, [address]
        ; работа с eax
    \end{minted}
    Процессоры не очень любят мержить значения разного размера. Вместо этого лучше писать такое
    \begin{minted}{nasm}
        movzx eax, byte [address]
        ; работа с eax
    \end{minted}
    Ещё интересности. До 64 бит расширили и служебные регистры: например, \Verb|RFLAGS| вместо \Verb|EFLAGS| и \Verb|RIP| вместо \Verb|IP|. И если в случае флагов нам это не важно, то в случае \Verb|IP|...\\
    Ещё добавили \Verb|xmm|-регистров, но мы до них дойдём, и порезали сегментную адресацию, но до неё тоже дойдём.
    \paragraph{Адресация}.
    Адресовать можно вот такую штуку: (любой регистр, включая новые) + (любой регистр, кроме \mintinline{nasm}|rsp|, тоже включая новые) * (число из 1, 2, 4, 8) + (32-битная знаковая константа). Очень жаль, да, 32-битная. Поэтому важно, что константа знаковая, раньше такого вопроса не возникало, потому что модулярная арифметика.\\
    Но ещё есть RIP-относительная адресация, можно адресовать \mintinline{nasm}|rip| + 32-битная знаковая константа. Здесь \mintinline{nasm}|rip|~--- адрес следующей инструкции. Зачем? Можно обращаться к своим константам. Обычно вы не можете обратиться к своим константам, потому что адрес у них 64-битный, блин. Но они обычно находятся не очень далеко от вашего кода, поэтому тут 32-битного смещения должно хватить.
    \paragraph{Константы.}
    Константы ограничены 32 битами не только в адресации, а вообще почти везде. Есть только три исключения, в которых можно 64-битные константы: \mintinline{nasm}|mov reg64, const64|, \mintinline{nasm}|mov acc, [const64]| и \mintinline{nasm}|mov [const64], acc|. Здесь \Verb|acc|~--- это \mintinline{nasm}|al|, \mintinline{nasm}|ax|, \mintinline{nasm}|eax| или \mintinline{nasm}|rax|.
    \paragraph{Исчезнувшие команды.}
    Например, выкинули команду \mintinline{nasm}|aaa| и всех её друзей. Эти черти про двоично-десятичные числа (т.е. о том, когда 4 бита кодируют десятичную цифру). Вы могли написать умножение, после чего написать \mintinline{nasm}|aam|, и оно скорректировало бы результат с точки зрения того, что умножение должно было бы быть в этом двоично-десятичном представлении.\\
    Ещё выкинули \mintinline{nasm}|bound| и \mintinline{nasm}|into|~--- тоже какая-то нахрен не нужная срака, например \mintinline{nasm}|bound|~--- проверка того, что значение находится в указанном диапазоне, и если оно не, то прерывание. Понятно, это штуку тоже давно никто в здравом уме не использовал.\\
    Ну, а фиг ли. Команды никому не нужны, а коды под новые команды откуда-то взять надо.\\
    А из команд, о которых мы что-то знаем, выкинули \mintinline{nasm}|pusha| и \mintinline{nasm}|popa|. Очень даль, больше без попы.\\
    Ещё убрали короткие формы команд \mintinline{nasm}|inc| и \mintinline{nasm}|dec|. Что значит <<короткие формы>>? А вот что: у \mintinline{nasm}|inc| была полная форма (которая умеет во всё, что угодно), а была ещё краткая форма, которая только для регистров, и плюс её был в том, что она один байт. Теперь эту отдельную форму убрали (делать \mintinline{nasm}|inc| регистру всё ещё можно, просто команда не будет такой короткой), и её код переназначили под REX. Поэтому будете дизассемблировать 64-битные инструкции не с теми флагами~--- можете получить код с большим количеством \mintinline{nasm}|inc| и \mintinline{nasm}|dec|, хотя на самом деле там REX. То есть повторю: вы всё ещё можете делать \mintinline{nasm}|inc| по регистру, просто эта команда не будет занимать один байт.\\
    И убрали \mintinline{nasm}|sysenter| и \mintinline{nasm}|sysexit|, но это мы уже знаем.
    \paragraph{Соглашения о вызовах.}
    Их две, и они, к сожалению, привязаны к ОС. То есть конвенций одна под каждую ОС.\\
    Общая часть: в момент вызова функции (т.е. перед \mintinline{nasm}|call|) ваш стек должен быть кратен 16. Обычно он кратен 8, потому что вы пушите по 64 бита, потому что \mintinline{nasm}|push al| всё равно пушит 64 бита. Но перед вызовом он должен быть кратен 16 (связано это с векторизацией, это увидим). Из этого следует, что сразу в начале функции вы не можете сделать вызов другой функции.
    \subparagraph{Microsoft (fastcall64).}
    Аргументы функции вначале передаются в регистрах \mintinline{nasm}|rcx|, \mintinline{nasm}|rdx|, \mintinline{nasm}|r8|, \mintinline{nasm}|r9| или \mintinline{nasm}|xmm0|, \mintinline{nasm}|xmm1|, \mintinline{nasm}|xmm2|, \mintinline{nasm}|xmm3|. Они в 64-битном мире используются через \Verb|XMM|. То есть если вам дали \mintinline{c}|void foo(int, float, int*, int)|, эти аргументы будут в \mintinline{nasm}|rcx|, \mintinline{nasm}|xmm1|, \mintinline{nasm}|r8|, \mintinline{nasm}|r9|. Всё остальное кладётся на стек в обратном порядке, как положено.\\
    К сохраняемым регистрам относятся \mintinline{nasm}|rbx|, \mintinline{nasm}|rbp|, \mintinline{nasm}|rsi|, \mintinline{nasm}|rdi|, \mintinline{nasm}|r12|, \mintinline{nasm}|r13|, \mintinline{nasm}|r14|, \mintinline{nasm}|r15|, \mintinline{nasm}|xmm6|, ..., \mintinline{nasm}|xmm15|. Необходимость сохранять \mintinline{nasm}|xmm6|, ..., \mintinline{nasm}|xmm15|~--- это мрак и тупость со стороны того, кто это проектировал. Увидим, почему так, когда дойдём на векторизации.\\
    Возвращаемое значение: \mintinline{nasm}|al|, \mintinline{nasm}|ax|, \mintinline{nasm}|eax|, \mintinline{nasm}|rax| или \mintinline{nasm}|xmm0| (числа с плавающей точкой через \mintinline{nasm}|xmm0|, а не \mintinline{nasm}|st0|). Большие значения, как обычно, через первый аргумент, если там \mintinline{cpp}|this|, то всё как раньше в Microsoft (т.е. сначала \mintinline{cpp}|this|, потом возврат).\\
    А ещё тут есть фича: между адресом возврата и пятым аргументом вам вставили 32 байта, которые называются shadow space, и в которую вы можете внутри функции использовать как угодно. Зачем? Чтобы вы могли взять ваши 4 аргумента в регистрах, засунуть их в shadow space и иметь непрерывную последовательность аргументов. А если вам не надо, используйте как хотите, это ваши 32 байта.\\
    По-хорошему ещё вы должны внедрять в исполняемый файл специальную метаинформацию. Просто если ваш код не кончится с исключением, вас никто не поймает, если вы не внедрите её. А если случится, вашу программу убьют за отсутствием метаинформации. \href{https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170#unwindability}{Вот тут} можно почитать.
    \paragraph{Все остальные.}
    Эта конвенция никак не называется, но мы будем называть её Unix64.\\
    Аргументы: тоже в начале в регистрах, потом на стеке. В регистры в следующем порядке: \mintinline{nasm}|rdi|, \mintinline{nasm}|rsi|, \mintinline{nasm}|rdx|, \mintinline{nasm}|rcx|, \mintinline{nasm}|r8|, \mintinline{nasm}|r9| и \mintinline{nasm}|xmm0|, ..., \mintinline{nasm}|xmm7|. С некоторыми комментариями: если делать \mintinline{nasm}|syscall|, то \mintinline{nasm}|rcx| перемещается в \mintinline{nasm}|r10|. Если vararg-функция, то количество \Verb|xmm|-регистров надо указать в \mintinline{nasm}|rax|. Причём можно использовать меньше \Verb|xmm|-регистров: можно передать три вещественных числа, засунуть на стек все и записать в \mintinline{nasm}|rax| ноль. Обратите внимание на то, что тут <<и>>, а не <<или>>. То есть если вы предаёте \mintinline{c}|int|'ы и \mintinline{c}|float|'ы в рандомном порядке, то ниоткуда вы не узнаете, в каком именно, вам запишут целочисленные аргументы в первую группу (подряд), а вещественные~--- во вторую группу. Очень весело жить.\\
    Сохраняемые регистры: \mintinline{nasm}|rbx|, \mintinline{nasm}|rbp|, \mintinline{nasm}|r12|, \mintinline{nasm}|r13|, \mintinline{nasm}|r14|, \mintinline{nasm}|r15|.\\
    Возвращаемое значение: \mintinline{nasm}|al|, \mintinline{nasm}|ax|, \mintinline{nasm}|eax|, \mintinline{nasm}|rax|, \mintinline{nasm}|rdx:rax| или \mintinline{nasm}|xmm0| или \mintinline{nasm}|xmm0| и \mintinline{nasm}|xmm1|. Зачем \mintinline{nasm}|xmm1|, Скаков точно не помнит, насколько помнит, чтобы можно было вернуть \mintinline{c}|complex double|. Большие значения, как обычно, через первый аргумент, если там \mintinline{cpp}|this|, то всё как раньше (т.е. сначала возврат, потом \mintinline{cpp}|this|).\\
    Тут есть другая фича: red zone: вам уже за возвращаемым значением дают 128 байт. \textbf{Обычно} писать данные ниже \mintinline{nasm}|rsp| не хорошо, их сохранность никто не гарантировал. Например, если там отладчик сидит и туда сохраняет свои данные. Но вообще не важно, кто у вас сидит, просто никто не гарантирует сохранность данных. Хотите хранить~--- опустите stack pointer, дальше работайте. Так вот red zone гарантирует, что вам 128 байт данных никто не испортит. Хотите сохранить 128 байт данных у себя (и не хотите никого вызывать)~--- можете не опускать стек.
    \paragraph{Интересность.}
    Из интересного, в x64 модно не делать \mintinline{nasm}|push|, а потом \mintinline{nasm}|call|, а можно в начале функции опустить стек ровно на столько, сколько максимум понадобится класть на стек (с учётом shadow space, если надо), при вызове других функций делать \mintinline{nasm}|mov|, а в конце вашей функции поднять стек обратно, на сколько опустили.
    \section{SIMD.}
    \paragraph{Мотивация, intrinsic, прочие мелочи.}
    Как мы помним, это single instruction multiple data. Отличная вещь, которая ускоряет ваш код, одна лишь беда: компиляторы с очень большим трудом умеют их применять. И если вы хотите чтобы ваш код был с SIMD, то у вас по сути три опции: либо написать ассемблерную вставку, либо писать код так, чтобы компилятор догадался применить SIMD (т.е. смотреть на вывод компилятора, и если у него не получилось в SIMD, то переписывать код). И есть третий вариант: использовать расширения компилятора и intrinsic'и. Из интересных расширений компилятора, советую почитать clang extended vectors~--- это фактически OpenCL вектора, которые по причине общности LLVM middle-end'а можно использовать в C/C++. И вам с большой вероятностью сгенерируют SIMD. Это всё ещё завязывается на конкретный компилятор, но лучше, чем завязываться на MSVC, например. Intrinsic'и же~--- это штука, которая с точки зрения C/C++ выглядят как функции, но на самом деле обёртка вокруг ассемблерных команд. В x86 они практически полностью общие, потому что \href{https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html}{Intel их задаёт в документации}, поэтому их в принципе поддерживают.
    \subsection{MMX.}
    Это расширение мы рассмотрим подробно, чтобы была понятна идея, силь написания и т.п., а другие расширения рассмотрим обзорно.\\
    \paragraph{Регистры.}
    Там регистры с \mintinline{nasm}|mm0| по \mintinline{nasm}|mm7|. Они 64-битные. Под эти 8 регистров отдали младшую часть регистров с \mintinline{nasm}|r0| по \mintinline{nasm}|r7|. Это, напоминание, 80-битные регистры сопроцессора x87. Адресация к \mintinline{nasm}|mm0|..\mintinline{nasm}|mm7| прямая, без stack pointer'а. Использовать вместе x87 и MMX не удасться, увы. Что неприятно. В 32-битным мире от сопроцессора вообще никуда не убежать (там по конвенциям возвращаемое значение в \mintinline{nasm}|ST0|), в x64 лучше, но использовать его вы всё равно можете, если хотите. Чтобы вам ещё меньше хотелось использовать MMX и x87 вместе, все команды MMX, кроме одной, помечают весь стек сопроцессора как занятый.
    \paragraph{Команды.}
    У любой команды, кроме \mintinline{nasm}|movq| и \mintinline{nasm}|modv| первым аргументом может быть только регистр. Вторым может быть регистр или память.
    \begin{itemize}
        \item \mintinline{nasm}|movq| пересылает данные из одного \Verb|mm(i)| в другой или из \Verb|mm(i)| и памятью. В 32-битном мире переслать данные между \Verb|mm(i)| и обычным регистром нельзя (битность не совпадает), а существует ли способ на x64~--- сложный вопрос. Без констант, увы.
        \item \mintinline{nasm}|movd|~--- пересылает младшие 32 бита между \Verb|mm(i)| и регистром общего назначения/памяти. Если вы пишете в память или регистр общего назначения, то всё хорошо. Если в \Verb|mm(i)|~--- старшая часть обнуляется. Тоже без констант, увы.
        \item \Verb/packss(dw|wb)/ (это тактовать как команды \mintinline{nasm}|packssdw| и \mintinline{nasm}|packsswb|). Рассмотрим \mintinline{nasm}|packssdw mm0, mm1|. Происходит следующее: \mintinline{nasm}|mm0| и \mintinline{nasm}|mm1| трактуются как пары знаковых dword-ов. После чего они преобразуются в word-ы при помощи signed saturation. Это значит с насыщением, то есть числа больше 32767 превращаются в 32767, а числа меньше -32768~--- в -32768. Потом эти четыре word-а кладутся обратно в \mintinline{nasm}|mm0| с порядке
        \begin{enumerate}
            \item Старшие 32 бита \mintinline{nasm}|mm1| идут в старшие 16 бит \mintinline{nasm}|mm0|.
            \item Младшие 32 бита \mintinline{nasm}|mm1| идут в следующие 16 бит \mintinline{nasm}|mm0|.
            \item Старшие 32 бита \mintinline{nasm}|mm0| идут в следующие 16 бит \mintinline{nasm}|mm0|.
            \item Младшие 32 бита \mintinline{nasm}|mm0| идут в младшие 16 бит \mintinline{nasm}|mm0|.
        \end{enumerate}
        \mintinline{nasm}|packsswb| делает то же самое, но с байтами. То есть входные регистры трактуются как четыре word'а, сжимаются до байтов и упаковываются как 8 байт в первый аргумент.
        \item \mintinline{nasm}|packuswb|~--- знаковое насыщение. То же самое, что и \mintinline{nasm}|packsswb|, но сжатие беззнаковое. То есть входные word'ы считаются знаковыми всё ещё, но тут их сжимают с насыщением в байты не от -128 до 127, а от 0 до 255. На самом деле эта команда уже очень полезна для обработки изображений, потому что обычно вы считаете в большей размерности, и вам потом приходится сжимать, причём с насыщением. И без этой команды вы бы делали это ветвлениями, что медленно. А так она даже без параллельности очень полезна.
        \item \Verb/punpck(h|l)(bw|wd|dq)/. Пример: \mintinline{nasm}|punpcklwd xmm0, xmm1|. Пилит \mintinline{nasm}|xmm0| и \mintinline{nasm}|xmm1| на слова, отбрасывает старшую половину слов, и кладёт в старшую часть результата старший кусок \mintinline{nasm}|xmm1|, потом старший кусок \mintinline{nasm}|xmm0|, потом младший кусок \mintinline{nasm}|xmm1|, потом младший кусок \mintinline{nasm}|xmm0|.
        \item \Verb/padd(b|w|d)/. Пилит входные регистры на куски соответствующего размера, попарно складывает (в модулярной арифметике), записывает в соответствующую часть результата.
        \item \Verb/padds(b|w)/, \Verb/paddus(b|w)/. Как предыдущее, но сложение с насыщением. В первом случае~--- знаковое насыщение, во втором~--- беззнаковое.
        \item \Verb/psub(b|w|d)/, \Verb/psubs(b|w)/, \Verb/psubus(b|w)/~--- вычитание, с теми же семантиками, что раньше.
        \item \mintinline{nasm}|pmullw|~--- как \mintinline{nasm}|paddw|, но умножает. Записывает в ответ младшую часть результата. \mintinline{nasm}|pmulhw|~--- записывает старшую часть результат умножения (со знаком). (Если хочется собрать себе нормальное полное умножение, после этого делаем unpack, он делает что хочется.) \mintinline{nasm}|pmaddwd|. Попарно полно умножает (со знаком) 16-битные куски регистров, берёт полное произведение, складывает два старших произведения и два младших произведения, записывает их как 32-битные числа в результат. Зачем этот мусор можно использовать? Например, для <<горизонтального сложения>>~--- сложения пар соседних word'ов в одном регистре. Загрузите \Verb|0x1010101| в регистр и засуньте вторым аргументом.
        \item \Verb/pcmpeq(b|w|d)/, \Verb/pcmpgt(b|w|d)/. Сравнивает на равенство либо на больше со знаком байты/word'ы/dword'ы. Если равно, соответствующий кусок регистра устанавливается в минус единицу, иначе в ноль. Так можно легко заполнить регистр всеми единицами: сделать ему \Verb|pcmpeq| с самим собой.
        \item \mintinline{nasm}|pand|, \mintinline{nasm}|por|, \mintinline{nasm}|pxor|. Побитовое и/или/xor. Ещё есть \mintinline{nasm}|pandn|~--- инвертирует первый аргумент и делает побитовое и со вторым.
        \item \Verb/pssl(w|d|q)/, \Verb/psrl(w|d|q)/, \Verb/psra(w|d)/. Принимает регистр и константу. Делает сдвиг влево/вправо логический/вправо арифметический соответствующим кусочкам регистра.
        \item \mintinline{nasm}|emms|. Помечает весь стек сопроцессора пустым. Зачем? Чтобы перед вызовом функции либо после возврата сделать её, потому что конвенция вызовов этого требует.
    \end{itemize}
    Это буквально все команды MMX. Но их обычно хватает. Тут нет деления, но это ничего, для него обычно используют фиксированную точку. А вот чего реально плохо~--- отсутствие сдвигов байтов.\\
    А ещё есть универсальная боль любого SIMD-программирования~--- это обработка краёв.
    \subsection{Больше MMX.}
    Больше команд MMX (и их друзей) добавили вместе с расширением с SSE:
    \begin{itemize}
        \item \Verb/pmax(ub|sw)/, \Verb/pmin(ub|sw)/~--- минимум и максимум по байтам без знака или словам со знаком.
        \item \Verb/pavg(b|w)/~--- среднее арифметическое по байтам или словам без знака. Округляет вверх. Ура, можно делить байт на два (правда, округление не туда).
        \item \mintinline{nasm}|pinsrv|, \mintinline{nasm}|pextsrv|. Первая принимает регистр, память и фиксированное число, второе сначала память, потом регистр, потом число. \mintinline{nasm}|pinsrv| вынимает 16-битное число из памяти и засовывает в регистр по с заданному номеру (0~--- младшие, 3~--- старшие). \mintinline{nasm}|pextsrc| делает пересылку обратно.
        \item \mintinline{nasm}|pmulhuw|~--- ясно, кто.
        \item \mintinline{nasm}|psadbw|~--- побайтово (математически) вычитает байты без знака, считает модуль, просуммировать, записать в младшее слово.
        \item \mintinline{nasm}|pshufw|~--- позволяет переставить произвольным образом слова при копировании из регистра в регистр или из памяти в регистр. А именно \mintinline{nasm}|pshufw dst, src, idx| делает следующее:
        \begin{minted}{c}
            dst[0] = src[idx01];
            dst[1] = src[idx23];
            dst[2] = src[idx45];
            dst[3] = src[idx67];
        \end{minted}
        То есть в младшее слово \Verb|dst| сохраняются то слово \Verb|src|, номер которого записан в младших двух битах \Verb|idx|. И аналогично с другими словами.
        \item \mintinline{nasm}|pmovmskb|~--- взять старшие биты каждого байта, составить из них единое число, записать в регистр общего назначения.
        \item \mintinline{nasm}|maskmovq|~--- записать в \mintinline{nasm}|edi| только те байты первого аргумента, для которых во втором аргументе в этом байтике старший бит единица. Иначе оставить старые байты. Работает долго капец.
        \item \mintinline{nasm}|movntq|~--- записать в память, минуя кэш. Например, мы обрабатываем большой объём данных, которые используем один раз. Но увы, после неё кэш и память десинхронизированы.
        \item \mintinline{nasm}|sfence|~--- синхронизация \mintinline{nasm}|movntq|. То есть применение такое: делаем делаем много раз \mintinline{nasm}|movntq|, после этого \mintinline{nasm}|sfence|.
        \item \Verb/prefetch(T0|T1|T2|NTA)/. Изначально это было в 3DNow!, там были \mintinline{nasm}|prefetch| и \mintinline{nasm}|prefetchw|. Они оба работают как \mintinline{nasm}|nop|. Это \textbf{подсказка} кэш-подсистеме закэшировать эту область памяти. \mintinline{nasm}|prefetchw| подсказка закэшировать на запись. Вместо этого Intel сделали свой \mintinline{nasm}|prefetch|, который грузит в какие-то кэши в зависимости от конкретной команды.
        \begin{itemize}
            \item \Verb|T0|~--- во все кэши.
            \item \Verb|T1|~--- в кэши уровня 2 и выше.
            \item \Verb|T2|~--- в кэши уровня 3 и выше или на выбор имплементации.
            \item \Verb|NTA|~--- в не-темпоральные кэши.
        \end{itemize}
        Раньше это чудо работало божественно, пихаешь \Verb|prefetch| и живёшь счастливо. Но тут есть проблема. Префетчить надо то, к чему будете обращаться через некоторое время. Например, то, к чему будет обращение через несколько итераций цикла. А через сколько? И тут это хрен посчитаешь: если слишком мало, он не успеет подгрузить кэш. Если слишком много, данные уже выгрузят. И тут в дело входят аппаратные префетчеры, которые стоят в современных процессорах и сами занимаются префетчингом. Если 
    \end{itemize}
    \subsection{SSE.}
    Когда AMD склепали 3DNow! (расширение позволяло работать с \Verb|mm|-регистрами, как с двумя флотами), Intel это увидели и сделали расширение, в которых расщедрились на новые 8 регистров: с \mintinline{nasm}|xmm0| по \mintinline{nasm}|xmm7|. Это 128-битные регистры, которые всегда интерпретируются как 4 флота. И они новые, никак не пересекаются с \Verb|mm|-регистрами.\\
    Многие команды там имеют формы \Verb|ps| и \Verb|ss|. Первая форма векторная, она делает операцию со всеми 4 значениями. Вторая форма делает операцию только с младшим флотом, а остальные оставляет.
    \subsection{SSE2.}
    Там не столько добавии команд, сколько разрешили интерпретировать \Verb|xmm|-регистры как два дабла (суффиксы \Verb|pd| и \Verb|sd|). Также разрешили MMX-команды применять к \Verb|xmm|-регистрам, чтобы обрабатывать порции большей битности.\\
    Но тут есть гадкий подарочек. Как загружать туда данные? Так: \mintinline{nasm}|movaps|, \mintinline{nasm}|movups|, \mintinline{nasm}|movdqa| и \mintinline{nasm}|movdqu|. Почему их 4? Команды с \Verb|ps|~--- пересылка значения как будто оно с плавающей точкой, в версии с \Verb|dq|~--- пересылка целого значения. Смысл в том, что если вы мешаете команды с целыми числами и с плавающей точкой, то могут возникать задержки (потому что в процессоре целочисленные и вещественные операции могут работать в разных доменах). Но это не главная проблема. Команды с \Verb|u|~--- невыровненное обращение к памяти, а с \Verb|a|~--- выровненное. Если вы пересылаете из регистра в регистр, то пофиг. А если один из аргументов~--- память, то если адрес не кратен 16, команды с \Verb|a| падают. И из интересного, так же работают все MMX-команды, когда они 128-битные. Так что либо выравнивайте адреса, либо используйте \mintinline{nasm}|movups|, и работайте с регистрами.
\end{document}